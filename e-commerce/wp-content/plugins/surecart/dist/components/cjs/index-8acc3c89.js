"use strict";function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(s){if("default"!==s){var n=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(t,s,n.get?n:{enumerable:!0,get:function(){return e[s]}})}})),t.default=e,Object.freeze(t)}const NAMESPACE="surecart",BUILD={allRenderFn:!1,appendChildSlotFix:!1,asyncLoading:!0,asyncQueue:!1,attachStyles:!0,cloneNodeFix:!1,cmpDidLoad:!0,cmpDidRender:!1,cmpDidUnload:!1,cmpDidUpdate:!0,cmpShouldUpdate:!1,cmpWillLoad:!0,cmpWillRender:!1,cmpWillUpdate:!1,connectedCallback:!1,constructableCSS:!0,cssAnnotations:!0,devTools:!1,disconnectedCallback:!0,element:!1,event:!0,experimentalScopedSlotChanges:!1,experimentalSlotFixes:!1,formAssociated:!1,hasRenderFn:!0,hostListener:!0,hostListenerTarget:!0,hostListenerTargetBody:!1,hostListenerTargetDocument:!1,hostListenerTargetParent:!1,hostListenerTargetWindow:!0,hotModuleReplacement:!1,hydrateClientSide:!1,hydrateServerSide:!1,hydratedAttribute:!1,hydratedClass:!0,hydratedSelectorName:"hydrated",initializeNextTick:!1,invisiblePrehydration:!0,isDebug:!1,isDev:!1,isTesting:!1,lazyLoad:!0,lifecycle:!0,lifecycleDOMEvents:!1,member:!0,method:!0,mode:!1,observeAttribute:!0,profile:!1,prop:!0,propBoolean:!0,propMutable:!0,propNumber:!0,propString:!0,reflect:!0,scoped:!1,scopedSlotTextContentFix:!1,scriptDataOpts:!1,shadowDelegatesFocus:!1,shadowDom:!0,slot:!0,slotChildNodesFix:!1,slotRelocation:!0,state:!0,style:!0,svg:!0,taskQueue:!0,transformTagName:!1,updatable:!0,vdomAttribute:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomPropOrAttr:!0,vdomRef:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,vdomXlink:!0,watchCallback:!0};var __defProp=Object.defineProperty,__export=(e,t)=>{for(var s in t)__defProp(e,s,{get:t[s],enumerable:!0})},EMPTY_OBJ={},SVG_NS="http://www.w3.org/2000/svg",HTML_NS="http://www.w3.org/1999/xhtml",isDef=e=>null!=e,isComplexType=e=>"object"==(e=typeof e)||"function"===e;function queryNonceMetaTagContent(e){var t,s,n;return null!=(n=null==(s=null==(t=e.head)?void 0:t.querySelector('meta[name="csp-nonce"]'))?void 0:s.getAttribute("content"))?n:void 0}var result_exports={};__export(result_exports,{err:()=>err,map:()=>map,ok:()=>ok,unwrap:()=>unwrap,unwrapErr:()=>unwrapErr});var ok=e=>({isOk:!0,isErr:!1,value:e}),err=e=>({isOk:!1,isErr:!0,value:e});function map(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then((e=>ok(e))):ok(s)}if(e.isErr){const t=e.value;return err(t)}throw"should never get here"}var scopeId,contentRef,hostTagName,unwrap=e=>{if(e.isOk)return e.value;throw e.value},unwrapErr=e=>{if(e.isErr)return e.value;throw e.value},createTime=(e,t="")=>()=>{},uniqueTime=(e,t)=>()=>{},HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}",SLOT_FB_CSS="slot-fb{display:contents}slot-fb[hidden]{display:none}",XLINK_NS="http://www.w3.org/1999/xlink",h=(e,t,...s)=>{let n=null,o=null,l=null,r=!1,a=!1;const i=[],c=t=>{for(let s=0;s<t.length;s++)n=t[s],Array.isArray(n)?c(n):null!=n&&"boolean"!=typeof n&&((r="function"!=typeof e&&!isComplexType(n))&&(n=String(n)),r&&a?i[i.length-1].$text$+=n:i.push(r?newVNode(null,n):n),a=r)};if(c(s),t){t.key&&(o=t.key),t.name&&(l=t.name);{const e=t.className||t.class;e&&(t.class="object"!=typeof e?e:Object.keys(e).filter((t=>e[t])).join(" "))}}if("function"==typeof e)return e(null===t?{}:t,i,vdomFnUtils);const $=newVNode(e,null);return $.$attrs$=t,i.length>0&&($.$children$=i),$.$key$=o,$.$name$=l,$},newVNode=(e,t)=>({$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null,$attrs$:null,$key$:null,$name$:null}),Host={},isHost=e=>e&&e.$tag$===Host,vdomFnUtils={forEach:(e,t)=>e.map(convertToPublic).forEach(t),map:(e,t)=>e.map(convertToPublic).map(t).map(convertToPrivate)},convertToPublic=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),convertToPrivate=e=>{if("function"==typeof e.vtag){const t={...e.vattrs};return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),h(e.vtag,t,...e.vchildren||[])}const t=newVNode(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},parsePropertyValue=(e,t)=>null==e||isComplexType(e)?e:4&t?"false"!==e&&(""===e||!!e):2&t?parseFloat(e):1&t?String(e):e,getElement=e=>getHostRef(e).$hostElement$,createEvent=(e,t,s)=>{const n=getElement(e);return{emit:e=>emitEvent(n,t,{bubbles:!!(4&s),composed:!!(2&s),cancelable:!!(1&s),detail:e})}},emitEvent=(e,t,s)=>{const n=plt.ce(t,s);return e.dispatchEvent(n),n},rootAppliedStyles=new WeakMap,registerStyle=(e,t,s)=>{let n=styles.get(e);supportsConstructableStylesheets&&s?(n=n||new CSSStyleSheet,"string"==typeof n?n=t:n.replaceSync(t)):n=t,styles.set(e,n)},addStyle=(e,t,s)=>{var n;const o=getScopeId(t),l=styles.get(o);if(e=11===e.nodeType?e:doc,l)if("string"==typeof l){e=e.head||e;let s,r=rootAppliedStyles.get(e);if(r||rootAppliedStyles.set(e,r=new Set),!r.has(o)){{s=doc.createElement("style"),s.innerHTML=l;const t=null!=(n=plt.$nonce$)?n:queryNonceMetaTagContent(doc);null!=t&&s.setAttribute("nonce",t),e.insertBefore(s,e.querySelector("link"))}4&t.$flags$&&(s.innerHTML+=SLOT_FB_CSS),r&&r.add(o)}}else e.adoptedStyleSheets.includes(l)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return o},attachStyles=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,o=createTime("attachStyles",t.$tagName$),l=addStyle(s.shadowRoot?s.shadowRoot:s.getRootNode(),t);10&n&&(s["s-sc"]=l,s.classList.add(l+"-h")),o()},getScopeId=(e,t)=>"sc-"+e.$tagName$,setAccessor=(e,t,s,n,o,l)=>{if(s!==n){let r=isMemberInElement(e,t),a=t.toLowerCase();if("class"===t){const t=e.classList,o=parseClassList(s),l=parseClassList(n);t.remove(...o.filter((e=>e&&!l.includes(e)))),t.add(...l.filter((e=>e&&!o.includes(e))))}else if("style"===t){for(const t in s)n&&null!=n[t]||(t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in n)s&&n[t]===s[t]||(t.includes("-")?e.style.setProperty(t,n[t]):e.style[t]=n[t])}else if("key"===t);else if("ref"===t)n&&n(e);else if(r||"o"!==t[0]||"n"!==t[1]){const i=isComplexType(n);if((r||i&&null!==n)&&!o)try{if(e.tagName.includes("-"))e[t]=n;else{const o=null==n?"":n;"list"===t?r=!1:null!=s&&e[t]==o||(e[t]=o)}}catch(e){}let c=!1;a!==(a=a.replace(/^xlink\:?/,""))&&(t=a,c=!0),null==n||!1===n?!1===n&&""!==e.getAttribute(t)||(c?e.removeAttributeNS(XLINK_NS,t):e.removeAttribute(t)):(!r||4&l||o)&&!i&&(n=!0===n?"":n,c?e.setAttributeNS(XLINK_NS,t,n):e.setAttribute(t,n))}else if(t="-"===t[2]?t.slice(3):isMemberInElement(win,a)?a.slice(2):a[2]+t.slice(3),s||n){const o=t.endsWith(CAPTURE_EVENT_SUFFIX);t=t.replace(CAPTURE_EVENT_REGEX,""),s&&plt.rel(e,t,s,o),n&&plt.ael(e,t,n,o)}}},parseClassListRegex=/\s/,parseClassList=e=>e?e.split(parseClassListRegex):[],CAPTURE_EVENT_SUFFIX="Capture",CAPTURE_EVENT_REGEX=new RegExp(CAPTURE_EVENT_SUFFIX+"$"),updateElement=(e,t,s)=>{const n=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,o=e&&e.$attrs$||EMPTY_OBJ,l=t.$attrs$||EMPTY_OBJ;for(const e of sortedAttrNames(Object.keys(o)))e in l||setAccessor(n,e,o[e],void 0,s,t.$flags$);for(const e of sortedAttrNames(Object.keys(l)))setAccessor(n,e,o[e],l[e],s,t.$flags$)};function sortedAttrNames(e){return e.includes("ref")?[...e.filter((e=>"ref"!==e)),"ref"]:e}var useNativeShadowDom=!1,checkSlotFallbackVisibility=!1,checkSlotRelocate=!1,isSvgMode=!1,createElm=(e,t,s,n)=>{var o;const l=t.$children$[s];let r,a,i,c=0;if(useNativeShadowDom||(checkSlotRelocate=!0,"slot"===l.$tag$&&(scopeId&&n.classList.add(scopeId+"-s"),l.$flags$|=l.$children$?2:1)),null!==l.$text$)r=l.$elm$=doc.createTextNode(l.$text$);else if(1&l.$flags$)r=l.$elm$=doc.createTextNode("");else{if(isSvgMode||(isSvgMode="svg"===l.$tag$),r=l.$elm$=doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,2&l.$flags$?"slot-fb":l.$tag$),isSvgMode&&"foreignObject"===l.$tag$&&(isSvgMode=!1),updateElement(null,l,isSvgMode),isDef(scopeId)&&r["s-si"]!==scopeId&&r.classList.add(r["s-si"]=scopeId),l.$children$)for(c=0;c<l.$children$.length;++c)a=createElm(e,l,c,r),a&&r.appendChild(a);"svg"===l.$tag$?isSvgMode=!1:"foreignObject"===r.tagName&&(isSvgMode=!0)}return r["s-hn"]=hostTagName,3&l.$flags$&&(r["s-sr"]=!0,r["s-cr"]=contentRef,r["s-sn"]=l.$name$||"",r["s-rf"]=null==(o=l.$attrs$)?void 0:o.ref,i=e&&e.$children$&&e.$children$[s],i&&i.$tag$===l.$tag$&&e.$elm$&&putBackInOriginalLocation(e.$elm$,!1)),r},putBackInOriginalLocation=(e,t)=>{plt.$flags$|=1;const s=Array.from(e.childNodes);if(e["s-sr"]&&BUILD.experimentalSlotFixes){let t=e;for(;t=t.nextSibling;)t&&t["s-sn"]===e["s-sn"]&&t["s-sh"]===hostTagName&&s.push(t)}for(let e=s.length-1;e>=0;e--){const n=s[e];n["s-hn"]!==hostTagName&&n["s-ol"]&&(insertBefore(parentReferenceNode(n),n,referenceNode(n)),n["s-ol"].remove(),n["s-ol"]=void 0,n["s-sh"]=void 0,checkSlotRelocate=!0),t&&putBackInOriginalLocation(n,t)}plt.$flags$&=-2},addVnodes=(e,t,s,n,o,l)=>{let r,a=e["s-cr"]&&e["s-cr"].parentNode||e;for(a.shadowRoot&&a.tagName===hostTagName&&(a=a.shadowRoot);o<=l;++o)n[o]&&(r=createElm(null,s,o,e),r&&(n[o].$elm$=r,insertBefore(a,r,referenceNode(t))))},removeVnodes=(e,t,s)=>{for(let n=t;n<=s;++n){const t=e[n];if(t){const e=t.$elm$;nullifyVNodeRefs(t),e&&(checkSlotFallbackVisibility=!0,e["s-ol"]?e["s-ol"].remove():putBackInOriginalLocation(e,!0),e.remove())}}},updateChildren=(e,t,s,n,o=!1)=>{let l,r,a=0,i=0,c=0,$=0,d=t.length-1,p=t[0],u=t[d],m=n.length-1,f=n[0],h=n[m];for(;a<=d&&i<=m;)if(null==p)p=t[++a];else if(null==u)u=t[--d];else if(null==f)f=n[++i];else if(null==h)h=n[--m];else if(isSameVnode(p,f,o))patch(p,f,o),p=t[++a],f=n[++i];else if(isSameVnode(u,h,o))patch(u,h,o),u=t[--d],h=n[--m];else if(isSameVnode(p,h,o))"slot"!==p.$tag$&&"slot"!==h.$tag$||putBackInOriginalLocation(p.$elm$.parentNode,!1),patch(p,h,o),insertBefore(e,p.$elm$,u.$elm$.nextSibling),p=t[++a],h=n[--m];else if(isSameVnode(u,f,o))"slot"!==p.$tag$&&"slot"!==h.$tag$||putBackInOriginalLocation(u.$elm$.parentNode,!1),patch(u,f,o),insertBefore(e,u.$elm$,p.$elm$),u=t[--d],f=n[++i];else{for(c=-1,$=a;$<=d;++$)if(t[$]&&null!==t[$].$key$&&t[$].$key$===f.$key$){c=$;break}c>=0?(r=t[c],r.$tag$!==f.$tag$?l=createElm(t&&t[i],s,c,e):(patch(r,f,o),t[c]=void 0,l=r.$elm$),f=n[++i]):(l=createElm(t&&t[i],s,i,e),f=n[++i]),l&&insertBefore(parentReferenceNode(p.$elm$),l,referenceNode(p.$elm$))}a>d?addVnodes(e,null==n[m+1]?null:n[m+1].$elm$,s,n,i,m):i>m&&removeVnodes(t,a,d)},isSameVnode=(e,t,s=!1)=>e.$tag$===t.$tag$&&("slot"===e.$tag$?e.$name$===t.$name$:!!s||e.$key$===t.$key$),referenceNode=e=>e&&e["s-ol"]||e,parentReferenceNode=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,patch=(e,t,s=!1)=>{const n=t.$elm$=e.$elm$,o=e.$children$,l=t.$children$,r=t.$tag$,a=t.$text$;let i;null===a?(isSvgMode="svg"===r||"foreignObject"!==r&&isSvgMode,("slot"!==r||useNativeShadowDom)&&updateElement(e,t,isSvgMode),null!==o&&null!==l?updateChildren(n,o,t,l,s):null!==l?(null!==e.$text$&&(n.textContent=""),addVnodes(n,null,t,l,0,l.length-1)):null!==o&&removeVnodes(o,0,o.length-1),isSvgMode&&"svg"===r&&(isSvgMode=!1)):(i=n["s-cr"])?i.parentNode.textContent=a:e.$text$!==a&&(n.data=a)},updateFallbackSlotVisibility=e=>{const t=e.childNodes;for(const e of t)if(1===e.nodeType){if(e["s-sr"]){const s=e["s-sn"];e.hidden=!1;for(const n of t)if(n!==e)if(n["s-hn"]!==e["s-hn"]||""!==s){if(1===n.nodeType&&(s===n.getAttribute("slot")||s===n["s-sn"])||3===n.nodeType&&s===n["s-sn"]){e.hidden=!0;break}}else if(1===n.nodeType||3===n.nodeType&&""!==n.textContent.trim()){e.hidden=!0;break}}updateFallbackSlotVisibility(e)}},relocateNodes=[],markSlotContentForRelocation=e=>{let t,s,n;for(const o of e.childNodes){if(o["s-sr"]&&(t=o["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;const e=o["s-sn"];for(n=s.length-1;n>=0;n--)if(t=s[n],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==o["s-hn"]&&!BUILD.experimentalSlotFixes)if(isNodeLocatedInSlot(t,e)){let s=relocateNodes.find((e=>e.$nodeToRelocate$===t));checkSlotFallbackVisibility=!0,t["s-sn"]=t["s-sn"]||e,s?(s.$nodeToRelocate$["s-sh"]=o["s-hn"],s.$slotRefNode$=o):(t["s-sh"]=o["s-hn"],relocateNodes.push({$slotRefNode$:o,$nodeToRelocate$:t})),t["s-sr"]&&relocateNodes.map((e=>{isNodeLocatedInSlot(e.$nodeToRelocate$,t["s-sn"])&&(s=relocateNodes.find((e=>e.$nodeToRelocate$===t)),s&&!e.$slotRefNode$&&(e.$slotRefNode$=s.$slotRefNode$))}))}else relocateNodes.some((e=>e.$nodeToRelocate$===t))||relocateNodes.push({$nodeToRelocate$:t})}1===o.nodeType&&markSlotContentForRelocation(o)}},isNodeLocatedInSlot=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,nullifyVNodeRefs=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(nullifyVNodeRefs)},insertBefore=(e,t,s)=>null==e?void 0:e.insertBefore(t,s),renderVdom=(e,t,s=!1)=>{var n,o,l,r;const a=e.$hostElement$,i=e.$cmpMeta$,c=e.$vnode$||newVNode(null,null),$=isHost(t)?t:h(null,null,t);if(hostTagName=a.tagName,i.$attrsToReflect$&&($.$attrs$=$.$attrs$||{},i.$attrsToReflect$.map((([e,t])=>$.$attrs$[t]=a[e]))),s&&$.$attrs$)for(const e of Object.keys($.$attrs$))a.hasAttribute(e)&&!["key","ref","style","class"].includes(e)&&($.$attrs$[e]=a[e]);if($.$tag$=null,$.$flags$|=4,e.$vnode$=$,$.$elm$=c.$elm$=a.shadowRoot||a,scopeId=a["s-sc"],useNativeShadowDom=!!(1&i.$flags$),contentRef=a["s-cr"],checkSlotFallbackVisibility=!1,patch(c,$,s),plt.$flags$|=1,checkSlotRelocate){markSlotContentForRelocation($.$elm$);for(const e of relocateNodes){const t=e.$nodeToRelocate$;if(!t["s-ol"]){const e=doc.createTextNode("");e["s-nr"]=t,insertBefore(t.parentNode,t["s-ol"]=e,t)}}for(const e of relocateNodes){const t=e.$nodeToRelocate$,a=e.$slotRefNode$;if(a){const e=a.parentNode;let s=a.nextSibling;{let l=null==(n=t["s-ol"])?void 0:n.previousSibling;for(;l;){let n=null!=(o=l["s-nr"])?o:null;if(n&&n["s-sn"]===t["s-sn"]&&e===n.parentNode){for(n=n.nextSibling;n===t||(null==n?void 0:n["s-sr"]);)n=null==n?void 0:n.nextSibling;if(!n||!n["s-nr"]){s=n;break}}l=l.previousSibling}}(!s&&e!==t.parentNode||t.nextSibling!==s)&&t!==s&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),insertBefore(e,t,s),1===t.nodeType&&(t.hidden=null!=(l=t["s-ih"])&&l)),t&&"function"==typeof a["s-rf"]&&a["s-rf"](t)}else 1===t.nodeType&&(s&&(t["s-ih"]=null!=(r=t.hidden)&&r),t.hidden=!0)}}checkSlotFallbackVisibility&&updateFallbackSlotVisibility($.$elm$),plt.$flags$&=-2,relocateNodes.length=0,contentRef=void 0},attachToAncestor=(e,t)=>{t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise((t=>e.$onRenderResolve$=t)))},scheduleUpdate=(e,t)=>{if(e.$flags$|=16,!(4&e.$flags$))return attachToAncestor(e,e.$ancestorComponent$),writeTask((()=>dispatchHooks(e,t)));e.$flags$|=512},dispatchHooks=(e,t)=>{const s=e.$hostElement$,n=createTime("scheduleUpdate",e.$cmpMeta$.$tagName$),o=e.$lazyInstance$;if(!o)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let l;return t&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map((([e,t])=>safeCall(o,e,t))),e.$queuedListeners$=void 0),l=safeCall(o,"componentWillLoad")),n(),enqueue(l,(()=>updateComponent(e,o,t)))},enqueue=(e,t)=>isPromisey(e)?e.then(t):t(),isPromisey=e=>e instanceof Promise||e&&e.then&&"function"==typeof e.then,updateComponent=async(e,t,s)=>{var n;const o=e.$hostElement$,l=createTime("update",e.$cmpMeta$.$tagName$),r=o["s-rc"];s&&attachStyles(e);const a=createTime("render",e.$cmpMeta$.$tagName$);callRender(e,t,o,s),r&&(r.map((e=>e())),o["s-rc"]=void 0),a(),l();{const t=null!=(n=o["s-p"])?n:[],s=()=>postUpdateComponent(e);0===t.length?s():(Promise.all(t).then(s),e.$flags$|=4,t.length=0)}},renderingRef=null,callRender=(e,t,s,n)=>{try{renderingRef=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,renderVdom(e,t,n)}catch(t){consoleError(t,e.$hostElement$)}return renderingRef=null,null},getRenderingRef=()=>renderingRef,postUpdateComponent=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=createTime("postUpdate",t),o=e.$lazyInstance$,l=e.$ancestorComponent$;64&e.$flags$?(safeCall(o,"componentDidUpdate"),n()):(e.$flags$|=64,addHydratedFlag(s),safeCall(o,"componentDidLoad"),n(),e.$onReadyResolve$(s),l||appDidLoad()),e.$onInstanceResolve$(s),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),512&e.$flags$&&nextTick((()=>scheduleUpdate(e,!1))),e.$flags$&=-517},forceUpdate=e=>{{const t=getHostRef(e),s=t.$hostElement$.isConnected;return s&&2==(18&t.$flags$)&&scheduleUpdate(t,!1),s}},appDidLoad=e=>{addHydratedFlag(doc.documentElement),nextTick((()=>emitEvent(win,"appload",{detail:{namespace:NAMESPACE}})))},safeCall=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(e){consoleError(e)}},addHydratedFlag=e=>{var t;return e.classList.add(null!=(t=BUILD.hydratedSelectorName)?t:"hydrated")},getValue=(e,t)=>getHostRef(e).$instanceValues$.get(t),setValue=(e,t,s,n)=>{const o=getHostRef(e);if(!o)throw new Error(`Couldn't find host element for "${n.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);const l=o.$hostElement$,r=o.$instanceValues$.get(t),a=o.$flags$,i=o.$lazyInstance$;s=parsePropertyValue(s,n.$members$[t][0]);const c=Number.isNaN(r)&&Number.isNaN(s);if((!(8&a)||void 0===r)&&s!==r&&!c&&(o.$instanceValues$.set(t,s),i)){if(n.$watchers$&&128&a){const e=n.$watchers$[t];e&&e.map((e=>{try{i[e](s,r,t)}catch(e){consoleError(e,l)}}))}2==(18&a)&&scheduleUpdate(o,!1)}},proxyComponent=(e,t,s)=>{var n;const o=e.prototype;if(t.$members$){e.watchers&&(t.$watchers$=e.watchers);const l=Object.entries(t.$members$);if(l.map((([e,[n]])=>{31&n||2&s&&32&n?Object.defineProperty(o,e,{get(){return getValue(this,e)},set(s){setValue(this,e,s,t)},configurable:!0,enumerable:!0}):1&s&&64&n&&Object.defineProperty(o,e,{value(...t){var s;const n=getHostRef(this);return null==(s=null==n?void 0:n.$onInstancePromise$)?void 0:s.then((()=>{var s;return null==(s=n.$lazyInstance$)?void 0:s[e](...t)}))}})})),1&s){const s=new Map;o.attributeChangedCallback=function(e,n,l){plt.jmp((()=>{var r;const a=s.get(e);if(this.hasOwnProperty(a))l=this[a],delete this[a];else{if(o.hasOwnProperty(a)&&"number"==typeof this[a]&&this[a]==l)return;if(null==a){const s=getHostRef(this),o=null==s?void 0:s.$flags$;if(o&&!(8&o)&&128&o&&l!==n){const o=s.$lazyInstance$,a=null==(r=t.$watchers$)?void 0:r[e];null==a||a.forEach((t=>{null!=o[t]&&o[t].call(o,l,n,e)}))}return}}this[a]=(null!==l||"boolean"!=typeof this[a])&&l}))},e.observedAttributes=Array.from(new Set([...Object.keys(null!=(n=t.$watchers$)?n:{}),...l.filter((([e,t])=>15&t[0])).map((([e,n])=>{var o;const l=n[1]||e;return s.set(l,e),512&n[0]&&(null==(o=t.$attrsToReflect$)||o.push([e,l])),l}))]))}}return e},initializeComponent=async(e,t,s,n)=>{let o;if(!(32&t.$flags$)){if(t.$flags$|=32,s.$lazyBundleId$){const e=loadModule(s);if(e&&"then"in e){const t=uniqueTime();o=await e,t()}else o=e;if(!o)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);o.isProxied||(s.$watchers$=o.watchers,proxyComponent(o,s,2),o.isProxied=!0);const n=createTime("createInstance",s.$tagName$);t.$flags$|=8;try{new o(t)}catch(e){consoleError(e)}t.$flags$&=-9,t.$flags$|=128,n()}else{o=e.constructor;const s=e.localName;customElements.whenDefined(s).then((()=>t.$flags$|=128))}if(o&&o.style){let e=o.style;const t=getScopeId(s);if(!styles.has(t)){const n=createTime("registerStyles",s.$tagName$);registerStyle(t,e,!!(1&s.$flags$)),n()}}}const l=t.$ancestorComponent$,r=()=>scheduleUpdate(t,!0);l&&l["s-rc"]?l["s-rc"].push(r):r()},fireConnectedCallback=e=>{},connectedCallback=e=>{if(!(1&plt.$flags$)){const t=getHostRef(e),s=t.$cmpMeta$,n=createTime("connectedCallback",s.$tagName$);if(1&t.$flags$)addHostEventListeners(e,t,s.$listeners$),(null==t?void 0:t.$lazyInstance$)||(null==t?void 0:t.$onReadyPromise$)&&t.$onReadyPromise$.then((()=>fireConnectedCallback()));else{t.$flags$|=1,12&s.$flags$&&setContentReference(e);{let s=e;for(;s=s.parentNode||s.host;)if(s["s-p"]){attachToAncestor(t,t.$ancestorComponent$=s);break}}s.$members$&&Object.entries(s.$members$).map((([t,[s]])=>{if(31&s&&e.hasOwnProperty(t)){const s=e[t];delete e[t],e[t]=s}})),initializeComponent(e,t,s)}n()}},setContentReference=e=>{const t=e["s-cr"]=doc.createComment("");t["s-cn"]=!0,insertBefore(e,t,e.firstChild)},disconnectInstance=e=>{safeCall(e,"disconnectedCallback")},disconnectedCallback=async e=>{if(!(1&plt.$flags$)){const t=getHostRef(e);t.$rmListeners$&&(t.$rmListeners$.map((e=>e())),t.$rmListeners$=void 0),(null==t?void 0:t.$lazyInstance$)?disconnectInstance(t.$lazyInstance$):(null==t?void 0:t.$onReadyPromise$)&&t.$onReadyPromise$.then((()=>disconnectInstance(t.$lazyInstance$)))}},bootstrapLazy=(e,t={})=>{var s;const n=createTime(),o=[],l=t.exclude||[],r=win.customElements,a=doc.head,i=a.querySelector("meta[charset]"),c=doc.createElement("style"),$=[];let d,p=!0;Object.assign(plt,t),plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",doc.baseURI).href;let u=!1;if(e.map((e=>{e[1].map((t=>{var s;const n={$flags$:t[0],$tagName$:t[1],$members$:t[2],$listeners$:t[3]};4&n.$flags$&&(u=!0),n.$members$=t[2],n.$listeners$=t[3],n.$attrsToReflect$=[],n.$watchers$=null!=(s=t[4])?s:{};const a=n.$tagName$,i=class extends HTMLElement{constructor(e){super(e),registerHost(e=this,n),1&n.$flags$&&e.attachShadow({mode:"open"})}connectedCallback(){d&&(clearTimeout(d),d=null),p?$.push(this):plt.jmp((()=>connectedCallback(this)))}disconnectedCallback(){plt.jmp((()=>disconnectedCallback(this)))}componentOnReady(){return getHostRef(this).$onReadyPromise$}};n.$lazyBundleId$=e[0],l.includes(a)||r.get(a)||(o.push(a),r.define(a,proxyComponent(i,n,1)))}))})),o.length>0&&(u&&(c.textContent+=SLOT_FB_CSS),c.textContent+=o+HYDRATED_CSS,c.innerHTML.length)){c.setAttribute("data-styles","");const e=null!=(s=plt.$nonce$)?s:queryNonceMetaTagContent(doc);null!=e&&c.setAttribute("nonce",e),a.insertBefore(c,i?i.nextSibling:a.firstChild)}p=!1,$.length?$.map((e=>e.connectedCallback())):plt.jmp((()=>d=setTimeout(appDidLoad,30))),n()},Fragment=(e,t)=>t,addHostEventListeners=(e,t,s,n)=>{s&&s.map((([s,n,o])=>{const l=getHostListenerTarget(e,s),r=hostListenerProxy(t,o),a=hostListenerOpts(s);plt.ael(l,n,r,a),(t.$rmListeners$=t.$rmListeners$||[]).push((()=>plt.rel(l,n,r,a)))}))},hostListenerProxy=(e,t)=>s=>{var n;try{256&e.$flags$?null==(n=e.$lazyInstance$)||n[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s])}catch(e){consoleError(e)}},getHostListenerTarget=(e,t)=>8&t?win:e,hostListenerOpts=e=>supportsListenerOptions?{passive:!!(1&e),capture:!!(2&e)}:!!(2&e),setNonce=e=>plt.$nonce$=e,hostRefs=new WeakMap,getHostRef=e=>hostRefs.get(e),registerInstance=(e,t)=>hostRefs.set(t.$lazyInstance$=e,t),registerHost=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.$onInstancePromise$=new Promise((e=>s.$onInstanceResolve$=e)),s.$onReadyPromise$=new Promise((e=>s.$onReadyResolve$=e)),e["s-p"]=[],e["s-rc"]=[],addHostEventListeners(e,s,t.$listeners$),hostRefs.set(e,s)},isMemberInElement=(e,t)=>t in e,consoleError=(e,t)=>(0,console.error)(e,t),cmpModules=new Map,loadModule=(e,t,s)=>{const n=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(!o)return;const l=cmpModules.get(o);return l?l[n]:Promise.resolve().then((function(){return _interopNamespace(require(`./${o}.entry.js`))})).then((e=>(cmpModules.set(o,e),e[n])),consoleError)},styles=new Map,win="undefined"!=typeof window?window:{},doc=win.document||{head:{}},plt={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},supportsListenerOptions=(()=>{let e=!1;try{doc.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(e){}return e})(),promiseResolve=e=>Promise.resolve(e),supportsConstructableStylesheets=(()=>{try{return new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replaceSync}catch(e){}return!1})(),queuePending=!1,queueDomReads=[],queueDomWrites=[],queueTask=(e,t)=>s=>{e.push(s),queuePending||(queuePending=!0,t&&4&plt.$flags$?nextTick(flush):plt.raf(flush))},consume=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(e){consoleError(e)}e.length=0},flush=()=>{consume(queueDomReads),consume(queueDomWrites),(queuePending=queueDomReads.length>0)&&plt.raf(flush)},nextTick=e=>promiseResolve().then(e),writeTask=queueTask(queueDomWrites,!0);exports.Fragment=Fragment,exports.Host=Host,exports.bootstrapLazy=bootstrapLazy,exports.createEvent=createEvent,exports.forceUpdate=forceUpdate,exports.getElement=getElement,exports.getRenderingRef=getRenderingRef,exports.h=h,exports.promiseResolve=promiseResolve,exports.registerInstance=registerInstance,exports.setNonce=setNonce;