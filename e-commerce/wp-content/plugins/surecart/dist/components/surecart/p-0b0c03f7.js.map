{"version":3,"names":["validateNamespace","namespace","console","error","test","validateHookName","hookName","createAddHook","hooks","storeKey","addHook","callback","priority","hooksStore","handler","handlers","i","length","splice","__current","forEach","hookInfo","name","currentIndex","runs","doAction","createRemoveHook","removeAll","removeHook","handlersRemoved","createHasHook","hasHook","some","hook","createRunHook","returnFirstArg","runHooks","args","undefined","push","result","apply","pop","createCurrentHook","currentHook","_hooksStore$__current","createDoingHook","doingHook","createDidHook","didHook","_Hooks","constructor","this","actions","Object","create","filters","addAction","addFilter","removeAction","removeFilter","hasAction","hasFilter","removeAllActions","removeAllFilters","applyFilters","currentAction","currentFilter","doingAction","doingFilter","didAction","didFilter","createHooks","defaultHooks"],"sources":["../../node_modules/@wordpress/hooks/build-module/validateNamespace.js","../../node_modules/@wordpress/hooks/build-module/validateHookName.js","../../node_modules/@wordpress/hooks/build-module/createAddHook.js","../../node_modules/@wordpress/hooks/build-module/createRemoveHook.js","../../node_modules/@wordpress/hooks/build-module/createHasHook.js","../../node_modules/@wordpress/hooks/build-module/createRunHook.js","../../node_modules/@wordpress/hooks/build-module/createCurrentHook.js","../../node_modules/@wordpress/hooks/build-module/createDoingHook.js","../../node_modules/@wordpress/hooks/build-module/createDidHook.js","../../node_modules/@wordpress/hooks/build-module/createHooks.js","../../node_modules/@wordpress/hooks/build-module/index.js"],"sourcesContent":["/**\n * Validate a namespace string.\n *\n * @param {string} namespace The namespace to validate - should take the form\n *                           `vendor/plugin/function`.\n *\n * @return {boolean} Whether the namespace is valid.\n */\nfunction validateNamespace(namespace) {\n  if ('string' !== typeof namespace || '' === namespace) {\n    // eslint-disable-next-line no-console\n    console.error('The namespace must be a non-empty string.');\n    return false;\n  }\n  if (!/^[a-zA-Z][a-zA-Z0-9_.\\-\\/]*$/.test(namespace)) {\n    // eslint-disable-next-line no-console\n    console.error('The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.');\n    return false;\n  }\n  return true;\n}\nexport default validateNamespace;\n//# sourceMappingURL=validateNamespace.js.map","/**\n * Validate a hookName string.\n *\n * @param {string} hookName The hook name to validate. Should be a non empty string containing\n *                          only numbers, letters, dashes, periods and underscores. Also,\n *                          the hook name cannot begin with `__`.\n *\n * @return {boolean} Whether the hook name is valid.\n */\nfunction validateHookName(hookName) {\n  if ('string' !== typeof hookName || '' === hookName) {\n    // eslint-disable-next-line no-console\n    console.error('The hook name must be a non-empty string.');\n    return false;\n  }\n  if (/^__/.test(hookName)) {\n    // eslint-disable-next-line no-console\n    console.error('The hook name cannot begin with `__`.');\n    return false;\n  }\n  if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {\n    // eslint-disable-next-line no-console\n    console.error('The hook name can only contain numbers, letters, dashes, periods and underscores.');\n    return false;\n  }\n  return true;\n}\nexport default validateHookName;\n//# sourceMappingURL=validateHookName.js.map","/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace.js';\nimport validateHookName from './validateHookName.js';\n\n/**\n * @callback AddHook\n *\n * Adds the hook to the appropriate hooks container.\n *\n * @param {string}               hookName      Name of hook to add\n * @param {string}               namespace     The unique namespace identifying the callback in the form `vendor/plugin/function`.\n * @param {import('.').Callback} callback      Function to call when the hook is run\n * @param {number}               [priority=10] Priority of this hook\n */\n\n/**\n * Returns a function which, when invoked, will add a hook.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {AddHook} Function that adds a new hook.\n */\nfunction createAddHook(hooks, storeKey) {\n  return function addHook(hookName, namespace, callback, priority = 10) {\n    const hooksStore = hooks[storeKey];\n    if (!validateHookName(hookName)) {\n      return;\n    }\n    if (!validateNamespace(namespace)) {\n      return;\n    }\n    if ('function' !== typeof callback) {\n      // eslint-disable-next-line no-console\n      console.error('The hook callback must be a function.');\n      return;\n    }\n\n    // Validate numeric priority\n    if ('number' !== typeof priority) {\n      // eslint-disable-next-line no-console\n      console.error('If specified, the hook priority must be a number.');\n      return;\n    }\n    const handler = {\n      callback,\n      priority,\n      namespace\n    };\n    if (hooksStore[hookName]) {\n      // Find the correct insert index of the new hook.\n      const handlers = hooksStore[hookName].handlers;\n\n      /** @type {number} */\n      let i;\n      for (i = handlers.length; i > 0; i--) {\n        if (priority >= handlers[i - 1].priority) {\n          break;\n        }\n      }\n      if (i === handlers.length) {\n        // If append, operate via direct assignment.\n        handlers[i] = handler;\n      } else {\n        // Otherwise, insert before index via splice.\n        handlers.splice(i, 0, handler);\n      }\n\n      // We may also be currently executing this hook.  If the callback\n      // we're adding would come after the current callback, there's no\n      // problem; otherwise we need to increase the execution index of\n      // any other runs by 1 to account for the added element.\n      hooksStore.__current.forEach(hookInfo => {\n        if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {\n          hookInfo.currentIndex++;\n        }\n      });\n    } else {\n      // This is the first hook of its type.\n      hooksStore[hookName] = {\n        handlers: [handler],\n        runs: 0\n      };\n    }\n    if (hookName !== 'hookAdded') {\n      hooks.doAction('hookAdded', hookName, namespace, callback, priority);\n    }\n  };\n}\nexport default createAddHook;\n//# sourceMappingURL=createAddHook.js.map","/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace.js';\nimport validateHookName from './validateHookName.js';\n\n/**\n * @callback RemoveHook\n * Removes the specified callback (or all callbacks) from the hook with a given hookName\n * and namespace.\n *\n * @param {string} hookName  The name of the hook to modify.\n * @param {string} namespace The unique namespace identifying the callback in the\n *                           form `vendor/plugin/function`.\n *\n * @return {number | undefined} The number of callbacks removed.\n */\n\n/**\n * Returns a function which, when invoked, will remove a specified hook or all\n * hooks by the given name.\n *\n * @param {import('.').Hooks}    hooks             Hooks instance.\n * @param {import('.').StoreKey} storeKey\n * @param {boolean}              [removeAll=false] Whether to remove all callbacks for a hookName,\n *                                                 without regard to namespace. Used to create\n *                                                 `removeAll*` functions.\n *\n * @return {RemoveHook} Function that removes hooks.\n */\nfunction createRemoveHook(hooks, storeKey, removeAll = false) {\n  return function removeHook(hookName, namespace) {\n    const hooksStore = hooks[storeKey];\n    if (!validateHookName(hookName)) {\n      return;\n    }\n    if (!removeAll && !validateNamespace(namespace)) {\n      return;\n    }\n\n    // Bail if no hooks exist by this name.\n    if (!hooksStore[hookName]) {\n      return 0;\n    }\n    let handlersRemoved = 0;\n    if (removeAll) {\n      handlersRemoved = hooksStore[hookName].handlers.length;\n      hooksStore[hookName] = {\n        runs: hooksStore[hookName].runs,\n        handlers: []\n      };\n    } else {\n      // Try to find the specified callback to remove.\n      const handlers = hooksStore[hookName].handlers;\n      for (let i = handlers.length - 1; i >= 0; i--) {\n        if (handlers[i].namespace === namespace) {\n          handlers.splice(i, 1);\n          handlersRemoved++;\n          // This callback may also be part of a hook that is\n          // currently executing.  If the callback we're removing\n          // comes after the current callback, there's no problem;\n          // otherwise we need to decrease the execution index of any\n          // other runs by 1 to account for the removed element.\n          hooksStore.__current.forEach(hookInfo => {\n            if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {\n              hookInfo.currentIndex--;\n            }\n          });\n        }\n      }\n    }\n    if (hookName !== 'hookRemoved') {\n      hooks.doAction('hookRemoved', hookName, namespace);\n    }\n    return handlersRemoved;\n  };\n}\nexport default createRemoveHook;\n//# sourceMappingURL=createRemoveHook.js.map","/**\n * @callback HasHook\n *\n * Returns whether any handlers are attached for the given hookName and optional namespace.\n *\n * @param {string} hookName    The name of the hook to check for.\n * @param {string} [namespace] Optional. The unique namespace identifying the callback\n *                             in the form `vendor/plugin/function`.\n *\n * @return {boolean} Whether there are handlers that are attached to the given hook.\n */\n/**\n * Returns a function which, when invoked, will return whether any handlers are\n * attached to a particular hook.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {HasHook} Function that returns whether any handlers are\n *                   attached to a particular hook and optional namespace.\n */\nfunction createHasHook(hooks, storeKey) {\n  return function hasHook(hookName, namespace) {\n    const hooksStore = hooks[storeKey];\n\n    // Use the namespace if provided.\n    if ('undefined' !== typeof namespace) {\n      return hookName in hooksStore && hooksStore[hookName].handlers.some(hook => hook.namespace === namespace);\n    }\n    return hookName in hooksStore;\n  };\n}\nexport default createHasHook;\n//# sourceMappingURL=createHasHook.js.map","/**\n * Returns a function which, when invoked, will execute all callbacks\n * registered to a hook of the specified type, optionally returning the final\n * value of the call chain.\n *\n * @param {import('.').Hooks}    hooks                  Hooks instance.\n * @param {import('.').StoreKey} storeKey\n * @param {boolean}              [returnFirstArg=false] Whether each hook callback is expected to\n *                                                      return its first argument.\n *\n * @return {(hookName:string, ...args: unknown[]) => undefined|unknown} Function that runs hook callbacks.\n */\nfunction createRunHook(hooks, storeKey, returnFirstArg = false) {\n  return function runHooks(hookName, ...args) {\n    const hooksStore = hooks[storeKey];\n    if (!hooksStore[hookName]) {\n      hooksStore[hookName] = {\n        handlers: [],\n        runs: 0\n      };\n    }\n    hooksStore[hookName].runs++;\n    const handlers = hooksStore[hookName].handlers;\n\n    // The following code is stripped from production builds.\n    if ('production' !== process.env.NODE_ENV) {\n      // Handle any 'all' hooks registered.\n      if ('hookAdded' !== hookName && hooksStore.all) {\n        handlers.push(...hooksStore.all.handlers);\n      }\n    }\n    if (!handlers || !handlers.length) {\n      return returnFirstArg ? args[0] : undefined;\n    }\n    const hookInfo = {\n      name: hookName,\n      currentIndex: 0\n    };\n    hooksStore.__current.push(hookInfo);\n    while (hookInfo.currentIndex < handlers.length) {\n      const handler = handlers[hookInfo.currentIndex];\n      const result = handler.callback.apply(null, args);\n      if (returnFirstArg) {\n        args[0] = result;\n      }\n      hookInfo.currentIndex++;\n    }\n    hooksStore.__current.pop();\n    if (returnFirstArg) {\n      return args[0];\n    }\n    return undefined;\n  };\n}\nexport default createRunHook;\n//# sourceMappingURL=createRunHook.js.map","/**\n * Returns a function which, when invoked, will return the name of the\n * currently running hook, or `null` if no hook of the given type is currently\n * running.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {() => string | null} Function that returns the current hook name or null.\n */\nfunction createCurrentHook(hooks, storeKey) {\n  return function currentHook() {\n    var _hooksStore$__current;\n    const hooksStore = hooks[storeKey];\n    return (_hooksStore$__current = hooksStore.__current[hooksStore.__current.length - 1]?.name) !== null && _hooksStore$__current !== void 0 ? _hooksStore$__current : null;\n  };\n}\nexport default createCurrentHook;\n//# sourceMappingURL=createCurrentHook.js.map","/**\n * @callback DoingHook\n * Returns whether a hook is currently being executed.\n *\n * @param {string} [hookName] The name of the hook to check for.  If\n *                            omitted, will check for any hook being executed.\n *\n * @return {boolean} Whether the hook is being executed.\n */\n\n/**\n * Returns a function which, when invoked, will return whether a hook is\n * currently being executed.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {DoingHook} Function that returns whether a hook is currently\n *                     being executed.\n */\nfunction createDoingHook(hooks, storeKey) {\n  return function doingHook(hookName) {\n    const hooksStore = hooks[storeKey];\n\n    // If the hookName was not passed, check for any current hook.\n    if ('undefined' === typeof hookName) {\n      return 'undefined' !== typeof hooksStore.__current[0];\n    }\n\n    // Return the __current hook.\n    return hooksStore.__current[0] ? hookName === hooksStore.__current[0].name : false;\n  };\n}\nexport default createDoingHook;\n//# sourceMappingURL=createDoingHook.js.map","/**\n * Internal dependencies\n */\nimport validateHookName from './validateHookName.js';\n\n/**\n * @callback DidHook\n *\n * Returns the number of times an action has been fired.\n *\n * @param {string} hookName The hook name to check.\n *\n * @return {number | undefined} The number of times the hook has run.\n */\n\n/**\n * Returns a function which, when invoked, will return the number of times a\n * hook has been called.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {DidHook} Function that returns a hook's call count.\n */\nfunction createDidHook(hooks, storeKey) {\n  return function didHook(hookName) {\n    const hooksStore = hooks[storeKey];\n    if (!validateHookName(hookName)) {\n      return;\n    }\n    return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;\n  };\n}\nexport default createDidHook;\n//# sourceMappingURL=createDidHook.js.map","/**\n * Internal dependencies\n */\nimport createAddHook from './createAddHook';\nimport createRemoveHook from './createRemoveHook';\nimport createHasHook from './createHasHook';\nimport createRunHook from './createRunHook';\nimport createCurrentHook from './createCurrentHook';\nimport createDoingHook from './createDoingHook';\nimport createDidHook from './createDidHook';\n\n/**\n * Internal class for constructing hooks. Use `createHooks()` function\n *\n * Note, it is necessary to expose this class to make its type public.\n *\n * @private\n */\nexport class _Hooks {\n  constructor() {\n    /** @type {import('.').Store} actions */\n    this.actions = Object.create(null);\n    this.actions.__current = [];\n\n    /** @type {import('.').Store} filters */\n    this.filters = Object.create(null);\n    this.filters.__current = [];\n    this.addAction = createAddHook(this, 'actions');\n    this.addFilter = createAddHook(this, 'filters');\n    this.removeAction = createRemoveHook(this, 'actions');\n    this.removeFilter = createRemoveHook(this, 'filters');\n    this.hasAction = createHasHook(this, 'actions');\n    this.hasFilter = createHasHook(this, 'filters');\n    this.removeAllActions = createRemoveHook(this, 'actions', true);\n    this.removeAllFilters = createRemoveHook(this, 'filters', true);\n    this.doAction = createRunHook(this, 'actions');\n    this.applyFilters = createRunHook(this, 'filters', true);\n    this.currentAction = createCurrentHook(this, 'actions');\n    this.currentFilter = createCurrentHook(this, 'filters');\n    this.doingAction = createDoingHook(this, 'actions');\n    this.doingFilter = createDoingHook(this, 'filters');\n    this.didAction = createDidHook(this, 'actions');\n    this.didFilter = createDidHook(this, 'filters');\n  }\n}\n\n/** @typedef {_Hooks} Hooks */\n\n/**\n * Returns an instance of the hooks object.\n *\n * @return {Hooks} A Hooks instance.\n */\nfunction createHooks() {\n  return new _Hooks();\n}\nexport default createHooks;\n//# sourceMappingURL=createHooks.js.map","/**\n * Internal dependencies\n */\nimport createHooks from './createHooks';\n\n/** @typedef {(...args: any[])=>any} Callback */\n\n/**\n * @typedef Handler\n * @property {Callback} callback  The callback\n * @property {string}   namespace The namespace\n * @property {number}   priority  The namespace\n */\n\n/**\n * @typedef Hook\n * @property {Handler[]} handlers Array of handlers\n * @property {number}    runs     Run counter\n */\n\n/**\n * @typedef Current\n * @property {string} name         Hook name\n * @property {number} currentIndex The index\n */\n\n/**\n * @typedef {Record<string, Hook> & {__current: Current[]}} Store\n */\n\n/**\n * @typedef {'actions' | 'filters'} StoreKey\n */\n\n/**\n * @typedef {import('./createHooks').Hooks} Hooks\n */\n\nexport const defaultHooks = createHooks();\nconst {\n  addAction,\n  addFilter,\n  removeAction,\n  removeFilter,\n  hasAction,\n  hasFilter,\n  removeAllActions,\n  removeAllFilters,\n  doAction,\n  applyFilters,\n  currentAction,\n  currentFilter,\n  doingAction,\n  doingFilter,\n  didAction,\n  didFilter,\n  actions,\n  filters\n} = defaultHooks;\nexport { createHooks, addAction, addFilter, removeAction, removeFilter, hasAction, hasFilter, removeAllActions, removeAllFilters, doAction, applyFilters, currentAction, currentFilter, doingAction, doingFilter, didAction, didFilter, actions, filters };\n//# sourceMappingURL=index.js.map"],"mappings":"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","ignoreList":[]}