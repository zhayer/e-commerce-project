/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { Address, Bump, CancellationReason, Checkout, ChoiceItem, Customer, DiscountResponse, Download, Fee, FormState, FormStateSetter, FulfillmentStatus, ImageAttributes, InvoiceStatus, License, LineItem, LineItemData as LineItemData1, ManualPaymentMethod, Order, OrderFulFillmentStatus, OrderShipmentStatus, OrderStatus, PaymentInfoAddedParams, PaymentMethod, Price, PriceChoice, Prices, Processor, ProcessorName, Product, ProductGroup, Products, ProductsSearchedParams, ProductsViewedParams, Purchase, ResponseError, ReturnRequestStatus, RuleGroup, Subscription, SubscriptionProtocol, SubscriptionStatus, TaxProtocol, WordPressUser } from "./types";
import { LineItemData, Price as Price1, Product as Product1, ProductMetrics, Subscription as Subscription1 } from "./types";
import { LayoutConfig } from "./components/controllers/products/sc-product-item-list/sc-product-item-list";
import { LayoutConfig as LayoutConfig1 } from "./components/controllers/products/sc-product-item-list/sc-product-item-list";
export { Address, Bump, CancellationReason, Checkout, ChoiceItem, Customer, DiscountResponse, Download, Fee, FormState, FormStateSetter, FulfillmentStatus, ImageAttributes, InvoiceStatus, License, LineItem, LineItemData as LineItemData1, ManualPaymentMethod, Order, OrderFulFillmentStatus, OrderShipmentStatus, OrderStatus, PaymentInfoAddedParams, PaymentMethod, Price, PriceChoice, Prices, Processor, ProcessorName, Product, ProductGroup, Products, ProductsSearchedParams, ProductsViewedParams, Purchase, ResponseError, ReturnRequestStatus, RuleGroup, Subscription, SubscriptionProtocol, SubscriptionStatus, TaxProtocol, WordPressUser } from "./types";
export { LineItemData, Price as Price1, Product as Product1, ProductMetrics, Subscription as Subscription1 } from "./types";
export { LayoutConfig } from "./components/controllers/products/sc-product-item-list/sc-product-item-list";
export { LayoutConfig as LayoutConfig1 } from "./components/controllers/products/sc-product-item-list/sc-product-item-list";
export namespace Components {
    interface ScAddress {
        /**
          * The address.
         */
        "address": Partial<Address>;
        /**
          * Is this disabled?
         */
        "disabled": boolean;
        /**
          * The label for the field.
         */
        "label": string;
        /**
          * Is this loading?
         */
        "loading": boolean;
        "names": Partial<Address>;
        "placeholders": Partial<Address>;
        "reportValidity": () => Promise<boolean>;
        /**
          * Is the name required
         */
        "requireName": boolean;
        /**
          * Is this required?
         */
        "required": boolean;
        /**
          * Should we show name field?
         */
        "showLine2": boolean;
        /**
          * Should we show name field?
         */
        "showName": boolean;
    }
    interface ScAlert {
        /**
          * Makes the alert closable.
         */
        "closable": boolean;
        /**
          * The length of time, in milliseconds, the alert will show before closing itself. If the user interacts with the alert before it closes (e.g. moves the mouse over it), the timer will restart. Defaults to `Infinity`.
         */
        "duration": number;
        /**
          * Hides the alert
         */
        "hide": () => Promise<void>;
        /**
          * No icon
         */
        "noIcon": boolean;
        /**
          * Indicates whether or not the alert is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * Scroll margin
         */
        "scrollMargin": string;
        /**
          * Scroll into view.
         */
        "scrollOnOpen": boolean;
        /**
          * Shows the alert.
         */
        "show": () => Promise<void>;
        /**
          * The title.
         */
        "title": string;
        /**
          * The type of alert.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface ScAvatar {
        /**
          * The image source to use for the avatar.
         */
        "image": string;
        /**
          * Initials to use as a fallback when no image is available (1-2 characters max recommended).
         */
        "initials": string;
        /**
          * A label to use to describe the avatar to assistive devices.
         */
        "label": string;
        /**
          * Indicates how the browser should load the image.
         */
        "loading": 'eager' | 'lazy';
        /**
          * The shape of the avatar.
         */
        "shape": 'circle' | 'square' | 'rounded';
    }
    interface ScBadgeNotice {
        "label": string;
        "size": 'small' | 'medium' | 'large';
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'default';
    }
    interface ScBlockUi {
        "spinner": boolean;
        "transparent": boolean;
        "zIndex": number;
    }
    interface ScBreadcrumb {
        /**
          * Optional URL to direct the user to when the breadcrumb item is activated. When set, a link will be rendered internally. When unset, a button will be rendered instead.
         */
        "href"?: string;
        /**
          * The `rel` attribute to use on the link. Only used when `href` is set.
         */
        "rel": string;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
    }
    interface ScBreadcrumbs {
        /**
          * The label to use for the breadcrumb control. This will not be shown, but it will be announced by screen readers and other assistive devices.
         */
        "label": string;
    }
    interface ScButton {
        /**
          * Tells the browser to autofocus.
         */
        "autofocus": boolean;
        /**
          * Draws the button in a busy state.
         */
        "busy"?: boolean;
        /**
          * Draws the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Draws a circle button.
         */
        "circle"?: boolean;
        /**
          * Disables the button.
         */
        "disabled"?: boolean;
        /**
          * Tells the browser to download the linked file as this filename. Only used when `href` is set.
         */
        "download": string;
        /**
          * Draws the button full-width.
         */
        "full"?: boolean;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`.
         */
        "href": string;
        /**
          * Draws the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * An optional name for the button. Ignored when `href` is set.
         */
        "name": string;
        /**
          * Draws an outlined button.
         */
        "outline"?: boolean;
        /**
          * Draws a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Indicates if activating the button should submit the form. Ignored when `href` is set.
         */
        "submit"?: boolean;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
        /**
          * The button's type.
         */
        "type": 'default' | 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text' | 'link';
        /**
          * An optional value for the button. Ignored when `href` is set.
         */
        "value": string;
    }
    interface ScButtonGroup {
        "label": string;
        "separate": boolean;
    }
    interface ScCancelDialog {
        "open": boolean;
        "protocol": SubscriptionProtocol;
        "subscription": Subscription;
    }
    interface ScCancelDiscount {
        "comment": string;
        "protocol": SubscriptionProtocol;
        "reason": CancellationReason;
        "subscription": Subscription;
    }
    interface ScCancelSurvey {
        "protocol": SubscriptionProtocol;
        "reasons": CancellationReason[];
    }
    interface ScCard {
        /**
          * Is this card borderless.
         */
        "borderless": boolean;
        /**
          * A link for the card.
         */
        "href": string;
        /**
          * Is this card loading.
         */
        "loading": boolean;
        /**
          * Eliminate the divider
         */
        "noDivider": boolean;
        /**
          * Remove padding
         */
        "noPadding": boolean;
    }
    interface ScCart {
        /**
          * Should we force show the cart, even if there's a form on the page?
         */
        "alwaysShow": boolean;
        /**
          * The template for the cart to inject when opened.
         */
        "cartTemplate": string;
        "checkoutLink": string;
        /**
          * The checkout url for the button.
         */
        "checkoutUrl": string;
        /**
          * Whether the floating button should be visible
         */
        "floatingIconEnabled": boolean;
        /**
          * The form id to use for the cart.
         */
        "formId": string;
        /**
          * The header for the popout.
         */
        "header": string;
        /**
          * Are we in test or live mode.
         */
        "mode": 'test' | 'live';
    }
    interface ScCartButton {
        /**
          * Whether the cart icon is always shown when the cart is empty
         */
        "cartMenuAlwaysShown": boolean;
        /**
          * The form id to use for the cart.
         */
        "formId": string;
        /**
          * Are we in test or live mode.
         */
        "mode": 'test' | 'live';
        /**
          * Whether the cart count will be shown or not when the cart is empty
         */
        "showEmptyCount": boolean;
    }
    interface ScCartForm {
        /**
          * The form id to use for the cart.
         */
        "formId": string;
        /**
          * Are we in test or live mode.
         */
        "mode": 'test' | 'live';
        /**
          * The price id to add.
         */
        "priceId": string;
        /**
          * The quantity
         */
        "quantity": number;
        /**
          * The variant id to add.
         */
        "variantId": string;
    }
    interface ScCartFormSubmit {
        /**
          * Show a full-width button.
         */
        "full": boolean;
        /**
          * Icon to show.
         */
        "icon": string;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The button type.
         */
        "type": 'default' | 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text' | 'link';
    }
    interface ScCartHeader {
    }
    interface ScCartIcon {
        /**
          * The icon to show.
         */
        "icon": string;
    }
    interface ScCartLoader {
        /**
          * The cart template to inject when opened.
         */
        "template": string;
    }
    interface ScCartSessionProvider {
    }
    interface ScCartSubmit {
        /**
          * Is the cart busy
         */
        "busy": boolean;
    }
    interface ScCcLogo {
        "brand": string;
    }
    interface ScChargesList {
        "allLink": string;
        "heading": string;
        /**
          * Query to fetch charges
         */
        "query": {
    page: number;
    per_page: number;
  };
        "showPagination": boolean;
    }
    interface ScCheckbox {
        /**
          * Draws the checkbox in a checked state.
         */
        "checked": boolean;
        /**
          * Disables the checkbox.
         */
        "disabled": boolean;
        /**
          * Makes this edit and not editable.
         */
        "edit": boolean;
        /**
          * Draws the checkbox in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid": boolean;
        /**
          * The checkbox's name attribute.
         */
        "name": string;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the checkbox a required field.
         */
        "required": boolean;
        /**
          * Removes focus from the checkbox.
         */
        "triggerBlur": () => Promise<void>;
        /**
          * Simulates a click on the checkbox.
         */
        "triggerClick": () => Promise<void>;
        /**
          * Sets focus on the checkbox.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The checkbox's value attribute.
         */
        "value": string;
    }
    interface ScCheckout {
        /**
          * Is abandoned checkout enabled.
         */
        "abandonedCheckoutEnabled": boolean;
        /**
          * Alignment
         */
        "alignment": 'center' | 'wide' | 'full';
        /**
          * Currency to use for this checkout.
         */
        "currencyCode": string;
        /**
          * Stores the current customer
         */
        "customer": Customer;
        /**
          * Should we disable components validation
         */
        "disableComponentsValidation": boolean;
        /**
          * Can we edit line items?
         */
        "editLineItems": boolean;
        /**
          * The checkout form id
         */
        "formId": number;
        /**
          * Manual payment methods enabled for this form.
         */
        "manualPaymentMethods": ManualPaymentMethod[];
        /**
          * Are we in test or live mode.
         */
        "mode": 'test' | 'live';
        /**
          * When the form was modified.
         */
        "modified": string;
        /**
          * Whether to persist the session in the browser between visits.
         */
        "persistSession": boolean;
        /**
          * An array of prices to pre-fill in the form.
         */
        "prices": Array<PriceChoice>;
        /**
          * Processors enabled for this form.
         */
        "processors": Processor[];
        /**
          * A product to pre-fill the form.
         */
        "product": Product;
        /**
          * Can we remove line items?
         */
        "removeLineItems": boolean;
        /**
          * Use the Stripe payment element.
         */
        "stripePaymentElement": boolean;
        /**
          * Submit the form
         */
        "submit": ({ skip_validation }?: { skip_validation: boolean; }) => Promise<Checkout | NodeJS.Timeout | Error>;
        /**
          * Where to go on success
         */
        "successUrl": string;
        /**
          * The account tax protocol
         */
        "taxProtocol": TaxProtocol;
        /**
          * Validate the form.
         */
        "validate": () => Promise<boolean>;
    }
    /**
     * This component listens for a confirmed event and redirects to the success url.
     */
    interface ScCheckoutFormErrors {
    }
    interface ScCheckoutMolliePayment {
        "method": string;
        "processorId": string;
    }
    interface ScCheckoutPaystackPaymentProvider {
    }
    interface ScCheckoutProductPriceVariantSelector {
        /**
          * The label for the price.
         */
        "label": string;
        /**
          * The product.
         */
        "product": Product;
        "reportValidity": () => Promise<boolean>;
        /**
          * The title for price and variant selections
         */
        "selectorTitle": string;
    }
    /**
     * This component listens for stock requirements and displays a dialog to the user.
     */
    interface ScCheckoutStockAlert {
    }
    /**
     * This component listens to the order status
     * and confirms the order when payment is successful.
     */
    interface ScCheckoutTestComplete {
        /**
          * Checkout status to listen and do payment related stuff.
         */
        "checkoutStatus": string;
        /**
          * Success url.
         */
        "successUrl": string;
    }
    interface ScCheckoutUnsavedChangesWarning {
        "state": FormState;
    }
    interface ScChoice {
        /**
          * Draws the choice in a checked state.
         */
        "checked": boolean;
        /**
          * Is the choice disabled
         */
        "disabled": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid": boolean;
        /**
          * The choice name attribute
         */
        "name": string;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Is this required
         */
        "required": boolean;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        /**
          * Show the radio/checkbox control
         */
        "showControl": boolean;
        /**
          * Show the label
         */
        "showLabel": boolean;
        /**
          * Show the price
         */
        "showPrice": boolean;
        /**
          * The size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Simulates a click on the choice.
         */
        "triggerClick": () => Promise<void>;
        "triggerFocus": () => Promise<void>;
        /**
          * The choice name attribute
         */
        "type": 'radio' | 'checkbox';
        /**
          * The choice value
         */
        "value": string;
    }
    interface ScChoiceContainer {
        /**
          * Draws the choice in a checked state.
         */
        "checked": boolean;
        /**
          * Is the choice disabled
         */
        "disabled": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid": boolean;
        /**
          * The choice name attribute
         */
        "name": string;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Is this required
         */
        "required": boolean;
        /**
          * Role of radio/checkbox control
         */
        "role": string;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        /**
          * Show the radio/checkbox control
         */
        "showControl": boolean;
        /**
          * The size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Simulates a click on the choice.
         */
        "triggerClick": () => Promise<void>;
        "triggerFocus": () => Promise<void>;
        /**
          * The choice name attribute
         */
        "type": 'radio' | 'checkbox';
        /**
          * The choice value
         */
        "value": string;
    }
    interface ScChoices {
        "autoWidth": boolean;
        /**
          * Number of columns on desktop
         */
        "columns": number;
        /**
          * Validation error message.
         */
        "errorMessage": string;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * Hides the fieldset and legend that surrounds the group. The label will still be read by screen readers.
         */
        "hideLabel": boolean;
        /**
          * The group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * Required
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * Input size
         */
        "size": 'small' | 'medium' | 'large';
        "triggerFocus": () => Promise<void>;
    }
    interface ScColumn {
    }
    interface ScColumns {
        /**
          * Is this full vertical height
         */
        "isFullHeight": boolean;
        /**
          * Is this reverse ordered on mobile
         */
        "isReversedOnMobile": boolean;
        /**
          * Is this stacked on mobile
         */
        "isStackedOnMobile": boolean;
        /**
          * The vertical alignment of the columns.
         */
        "verticalAlignment": string;
    }
    interface ScCompactAddress {
        /**
          * The address.
         */
        "address": Partial<Address>;
        /**
          * Label for the address
         */
        "label": string;
        /**
          * Is this loading
         */
        "loading": boolean;
        "names": Partial<Address>;
        /**
          * Placeholders
         */
        "placeholders": Partial<Address>;
        "reportValidity": () => Promise<boolean>;
        /**
          * Is this required?
         */
        "required": boolean;
    }
    interface ScConditionalForm {
        /**
          * Selector label
         */
        "rule_groups": RuleGroup[];
    }
    interface ScConsumer {
        "renderer": any;
    }
    interface ScCouponForm {
        /**
          * Is the form calculating
         */
        "busy": boolean;
        /**
          * The text for apply button
         */
        "buttonText": string;
        "collapsed": boolean;
        /**
          * Currency
         */
        "currency": string;
        /**
          * The discount
         */
        "discount": DiscountResponse;
        /**
          * The discount amount
         */
        "discountAmount": number;
        /**
          * Is the form editable
         */
        "editable": boolean;
        /**
          * The error message
         */
        "error": string;
        /**
          * Force the form to show
         */
        "forceOpen": boolean;
        /**
          * The label for the coupon form
         */
        "label": string;
        /**
          * Is the form loading
         */
        "loading": boolean;
        /**
          * Is it open
         */
        "open": boolean;
        /**
          * The placeholder for the input
         */
        "placeholder": string;
        /**
          * Has recurring
         */
        "showInterval": boolean;
        /**
          * Focus the input.
         */
        "triggerFocus": () => Promise<void>;
    }
    interface ScCustomOrderPriceInput {
        /**
          * Is this busy
         */
        "busy": boolean;
        /**
          * Help text.
         */
        "help": string;
        /**
          * Label for the field.
         */
        "label": string;
        /**
          * Label for the choice.
         */
        "lineItems": LineItem[];
        /**
          * Is this loading
         */
        "loading": boolean;
        /**
          * Input placeholder.
         */
        "placeholder": string;
        /**
          * Stores the price
         */
        "price": Price;
        /**
          * Id of the price.
         */
        "priceId": string;
        /**
          * Is this required?
         */
        "required": boolean;
        /**
          * Show the currency code?
         */
        "showCode": boolean;
    }
    interface ScCustomerDetails {
        "customer": Customer;
        "editLink": string;
        "error": string;
        "heading": string;
        "loading": boolean;
    }
    interface ScCustomerEdit {
        "customer": Customer;
        "heading": string;
        "successUrl": string;
    }
    interface ScCustomerEmail {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * A message for tracking confirmation.
         */
        "trackingConfirmationMessage": string;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScCustomerFirstname {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * Is the user logged in.
         */
        "loggedIn": boolean;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScCustomerLastname {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * Is the user logged in.
         */
        "loggedIn": boolean;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        /**
          * Don't allow a blank space as an input here.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value": any;
    }
    interface ScCustomerName {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        /**
          * Don't allow a blank space as an input here.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value": any;
    }
    interface ScCustomerPhone {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Error focus
         */
        "error": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScDashboardCustomerDetails {
        "customerId": string;
        "heading": string;
    }
    interface ScDashboardDownloadsList {
        "allLink": string;
        "heading": string;
        "isCustomer": boolean;
        /**
          * Customer id to fetch subscriptions
         */
        "query": any;
        "requestNonce": string;
    }
    interface ScDashboardModule {
        "error": string;
        "heading": string;
        "loading": boolean;
    }
    interface ScDialog {
        /**
          * The dialog's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label": string;
        /**
          * Disables the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the dialog.
         */
        "noHeader": boolean;
        /**
          * Indicates whether or not the dialog is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
    }
    interface ScDivider {
    }
    interface ScDonationChoices {
        "busy": boolean;
        /**
          * Currency code for the donation.
         */
        "currencyCode": string;
        /**
          * The default amount to load the page with.
         */
        "defaultAmount": string;
        /**
          * The label for the field.
         */
        "label": string;
        /**
          * Order line items.
         */
        "lineItems": LineItem[];
        /**
          * Is this loading
         */
        "loading": boolean;
        /**
          * The price id for the fields.
         */
        "priceId": string;
        "removeInvalid": boolean;
        "reportValidity": () => Promise<boolean>;
    }
    interface ScDownloadsList {
        "customerId": string;
        "downloads": Download[];
        "heading": string;
    }
    interface ScDrawer {
        /**
          * By default, the drawer slides out of its containing block (usually the viewport). To make the drawer slide out of its parent element, set this prop and add `position: relative` to the parent.
         */
        "contained": boolean;
        /**
          * The drawer's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label": string;
        /**
          * Removes the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the drawer.
         */
        "noHeader": boolean;
        /**
          * Indicates whether or not the drawer is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The direction from which the drawer will open.
         */
        "placement": 'top' | 'end' | 'bottom' | 'start';
        "requestClose": (source?: 'close-button' | 'keyboard' | 'overlay' | 'method') => Promise<void>;
        /**
          * Sticky drawer header
         */
        "stickyHeader": boolean;
    }
    interface ScDropdown {
        "clickEl"?: HTMLElement;
        /**
          * Determines whether the dropdown should hide when a menu item is selected
         */
        "closeOnSelect": boolean;
        /**
          * Is this disabled.
         */
        "disabled": boolean;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance": number;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist": boolean;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The placement of the dropdown.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The placement of the dropdown panel
         */
        "position": 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding": number;
    }
    interface ScEmpty {
        "icon": string;
    }
    interface ScError {
        /**
          * Error to display.
         */
        "error": ResponseError | null;
    }
    interface ScExpressPayment {
        "debug": boolean;
        "dividerText": string;
        "hasPaymentOptions": boolean;
        "processor": ProcessorName;
    }
    interface ScFeatureDemoBanner {
        "buttonText": string;
        "url": string;
    }
    interface ScFlex {
        "alignItems": string;
        "columnGap": string;
        "flexDirection": string;
        "flexWrap": string;
        "justifyContent": string;
        "stack": string;
    }
    interface ScForm {
        /**
          * Serializes all form controls elements and returns a `FormData` object.
         */
        "getFormData": () => Promise<FormData>;
        "getFormJson": () => Promise<Record<string, unknown>>;
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate": boolean;
        "submit": () => Promise<void>;
        "validate": () => Promise<boolean>;
    }
    interface ScFormComponentsValidator {
        /**
          * Disable validation?
         */
        "disabled": boolean;
        /**
          * The tax protocol
         */
        "taxProtocol": TaxProtocol;
    }
    interface ScFormControl {
        /**
          * Help text
         */
        "help": string;
        /**
          * Help id
         */
        "helpId": string;
        /**
          * Input id.
         */
        "inputId": string;
        /**
          * Input label.
         */
        "label": string;
        /**
          * Input label id.
         */
        "labelId": string;
        /**
          * Name for the input. Used for validation errors.
         */
        "name": string;
        /**
          * Whether the input is required.
         */
        "required": boolean;
        /**
          * Show the label.
         */
        "showLabel": boolean;
        /**
          * Size of the label
         */
        "size": 'small' | 'medium' | 'large';
    }
    /**
     * This component checks to make sure there is an error component
     * and adds one if it's missing.
     */
    interface ScFormErrorProvider {
    }
    interface ScFormRow {
    }
    /**
     * This component listens for a confirmed event and redirects to the success url.
     */
    interface ScFormStateProvider {
    }
    interface ScFormatBytes {
        /**
          * Determines how to display the result, e.g. "100 bytes", "100 b", or "100b".
         */
        "display": 'long' | 'short' | 'narrow';
        /**
          * The locale to use when formatting the number.
         */
        "locale": string;
        /**
          * The unit to display.
         */
        "unit": 'byte' | 'bit';
        /**
          * The number to format in bytes.
         */
        "value": number;
    }
    interface ScFormatInterval {
        "every": string;
        "fallback": string;
        "interval": string;
        /**
          * The number to format.
         */
        "value": number;
    }
    interface ScFormatNumber {
        /**
          * The currency to use when formatting. Must be an ISO 4217 currency code such as `USD` or `EUR`.
         */
        "currency": string;
        /**
          * How to display the currency.
         */
        "currencyDisplay": 'symbol' | 'narrowSymbol' | 'code' | 'name';
        /**
          * The locale to use when formatting the number.
         */
        "locale": string;
        /**
          * The maximum number of fraction digits to use. Possible values are 0 - 20.
         */
        "maximumFractionDigits": number;
        /**
          * The maximum number of significant digits to use,. Possible values are 1 - 21.
         */
        "maximumSignificantDigits": number;
        /**
          * The minimum number of fraction digits to use. Possible values are 0 - 20.
         */
        "minimumFractionDigits": number;
        /**
          * The minimum number of integer digits to use. Possible values are 1 - 21.
         */
        "minimumIntegerDigits": number;
        /**
          * The minimum number of significant digits to use. Possible values are 1 - 21.
         */
        "minimumSignificantDigits": number;
        /**
          * Should we convert
         */
        "noConvert": boolean;
        /**
          * Turns off grouping separators.
         */
        "noGrouping": boolean;
        /**
          * The formatting style to use.
         */
        "type": 'currency' | 'decimal' | 'percent' | 'unit';
        /**
          * The unit to use when formatting.
         */
        "unit": string;
        /**
          * The number to format.
         */
        "value": number;
    }
    interface ScFulfillmentShippingStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status": FulfillmentStatus;
    }
    interface ScFulfillments {
        "heading": string;
        "orderId": string;
    }
    interface ScHeading {
        "size": 'small' | 'medium' | 'large';
    }
    interface ScIcon {
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label": string;
        /**
          * The name of a registered custom icon library.
         */
        "library": string;
        /**
          * The name of the icon to draw.
         */
        "name": string;
        /**
          * An external URL of an SVG file.
         */
        "src": string;
    }
    interface ScImageSlider {
        "autoHeight": boolean;
        "hasThumbnails": boolean;
        /**
          * Accept a string or an array of objects
         */
        "images": string | { src: string; alt: string; srcset; width: number; height: number; sizes: string; title: string }[];
        "thumbnails": string | { src: string; alt: string; srcset; width: number; height: number; sizes: string; title: string }[];
        "thumbnailsPerPage": number;
    }
    interface ScInput {
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect": string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Adds a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * Hidden
         */
        "hidden": boolean;
        /**
          * The input's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * The input's maximum value.
         */
        "max": number | string;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength": number;
        /**
          * The input's minimum value.
         */
        "min": number | string;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength": number;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * A pattern to validate input against.
         */
        "pattern": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Enables spell checking on the input.
         */
        "spellcheck": boolean;
        "squared": boolean;
        "squaredBottom": boolean;
        "squaredLeft": boolean;
        "squaredRight": boolean;
        "squaredTop": boolean;
        /**
          * The input's step attribute.
         */
        "step": number;
        /**
          * Adds a password toggle button to password inputs.
         */
        "togglePassword": boolean;
        /**
          * Removes focus from the input.
         */
        "triggerBlur": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The input's type.
         */
        "type": 'email' | 'number' | 'password' | 'search' | 'tel' | 'text' | 'url' | 'hidden';
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScInvoiceDetails {
    }
    interface ScInvoiceMemo {
        /**
          * Memo Label
         */
        "text": string;
    }
    interface ScInvoiceStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status": InvoiceStatus;
    }
    interface ScInvoicesList {
        "allLink": string;
        "heading": string;
        "isCustomer": boolean;
        /**
          * Query to fetch invoices
         */
        "query": {
    page: number;
    per_page: number;
  };
    }
    interface ScLicense {
        /**
          * The license id
         */
        "licenseId": string;
    }
    interface ScLicensesList {
        /**
          * View all link
         */
        "allLink": string;
        /**
          * The heading of the licenses
         */
        "heading": string;
        /**
          * Whether the current user is customer
         */
        "isCustomer": boolean;
        "licenses": License[];
        /**
          * Query to fetch licenses
         */
        "query": {
    page: number;
    per_page: number;
  };
    }
    interface ScLineItem {
        /**
          * Currency symbol
         */
        "currency": string;
        /**
          * Price of the item
         */
        "price": string;
    }
    interface ScLineItemBump {
        "label": string;
        "loading": boolean;
    }
    interface ScLineItemInvoiceDueDate {
    }
    interface ScLineItemInvoiceNumber {
    }
    interface ScLineItemInvoiceReceiptDownload {
        "checkout": Checkout;
    }
    interface ScLineItemShipping {
        /**
          * Label
         */
        "label": string;
    }
    interface ScLineItemTax {
        "loading": boolean;
        "order": Checkout;
    }
    interface ScLineItemTotal {
        "checkout": Checkout;
        "size": 'large' | 'medium';
        "total": 'total' | 'subtotal';
    }
    interface ScLineItemTrial {
        /**
          * The label for the trial item
         */
        "label": string;
    }
    interface ScLineItems {
        /**
          * Is the line item editable?
         */
        "editable": boolean;
        /**
          * Is the line item removable?
         */
        "removable": boolean;
    }
    interface ScLineItemsProvider {
        /**
          * Order Object
         */
        "order": Checkout;
    }
    interface ScLoginForm {
    }
    interface ScLoginProvider {
        /**
          * Is the user logged in.
         */
        "loggedIn": boolean;
        "order": Checkout;
    }
    interface ScManualPaymentMethod {
        "paymentMethod": ManualPaymentMethod;
        "showDescription": boolean;
    }
    interface ScMenu {
        "ariaLabel": string;
        "setCurrentItem": (item: HTMLScMenuItemElement) => Promise<void>;
    }
    interface ScMenuDivider {
    }
    interface ScMenuItem {
        /**
          * Draws the item in a checked state.
         */
        "checked": boolean;
        /**
          * Draws the menu item in a disabled state.
         */
        "disabled": boolean;
        /**
          * Optional link to follow.
         */
        "href": string;
        /**
          * Removes focus from the button.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The target of the link.
         */
        "target": string;
        /**
          * A unique value to store in the menu item. This can be used as a way to identify menu items when selected.
         */
        "value": string;
    }
    interface ScMenuLabel {
    }
    interface ScMollieAddMethod {
        "country": string;
        "currency": string;
        "customerId": string;
        "liveMode": boolean;
        "processorId": string;
        "successUrl": string;
    }
    interface ScOrder {
        "customerIds": string[];
        "heading": string;
        "orderId": string;
    }
    interface ScOrderBillingAddress {
        /**
          * City placeholder
         */
        "cityPlaceholder": string;
        /**
          * Country placeholder
         */
        "countryPlaceholder": string;
        /**
          * Default country for address
         */
        "defaultCountry": string;
        /**
          * Label for the field
         */
        "label": string;
        /**
          * Address placeholder
         */
        "line1Placeholder": string;
        /**
          * Address Line 2 placeholder
         */
        "line2Placeholder": string;
        /**
          * Name placeholder
         */
        "namePlaceholder": string;
        /**
          * Postal Code placeholder
         */
        "postalCodePlaceholder": string;
        "reportValidity": () => Promise<boolean>;
        /**
          * Show the name field
         */
        "showName": boolean;
        /**
          * State placeholder
         */
        "statePlaceholder": string;
        /**
          * Toggle label
         */
        "toggleLabel": string;
    }
    interface ScOrderBump {
        /**
          * The bump
         */
        "bump": Bump;
        /**
          * Should we show the controls
         */
        "showControl": boolean;
    }
    interface ScOrderBumps {
        "help": string;
        "label": string;
        "showControl": boolean;
    }
    interface ScOrderConfirmComponentsValidator {
        /**
          * The checkout
         */
        "checkout": Checkout;
    }
    /**
     * This component listens to the order status
     * and confirms the order when payment is successful.
     */
    interface ScOrderConfirmProvider {
        /**
          * Checkout status to listen and do payment related stuff.
         */
        "checkoutStatus": string;
        /**
          * Success url.
         */
        "successUrl": string;
    }
    interface ScOrderConfirmation {
        "order": Checkout;
    }
    interface ScOrderConfirmationCustomer {
        /**
          * The customer
         */
        "customer": Customer;
        /**
          * Error message.
         */
        "error": string;
        /**
          * The heading
         */
        "heading": string;
        /**
          * Is this loading?
         */
        "loading": boolean;
        /**
          * The Order
         */
        "order": Checkout;
    }
    interface ScOrderConfirmationDetails {
        "loading": boolean;
        "order": Order;
    }
    interface ScOrderConfirmationLineItems {
        "loading": boolean;
        "order": Checkout;
    }
    interface ScOrderConfirmationTotals {
        "order": Checkout;
    }
    interface ScOrderCouponForm {
        "buttonText": string;
        "collapsed": boolean;
        "label": string;
        "loading": boolean;
        "placeholder": string;
    }
    interface ScOrderDetail {
        "fallback": string;
        "label": string;
        "loading": boolean;
        "metaKey": string;
        "order": Checkout;
        "value": string;
    }
    interface ScOrderFulfillmentBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status": OrderFulFillmentStatus;
    }
    interface ScOrderManualInstructions {
        "manualPaymentInstructions": string;
        "manualPaymentTitle": string;
    }
    interface ScOrderPassword {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * The input's password confirmation attribute.
         */
        "confirmation": boolean;
        /**
          * The input's confirmation help text.
         */
        "confirmationHelp": string;
        /**
          * The input's confirmation label text.
         */
        "confirmationLabel": string;
        /**
          * The input's confirmation placeholder text.
         */
        "confirmationPlaceholder": string;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Does the email exist?
         */
        "emailExists": boolean;
        /**
          * Ensures strong password validation.
         */
        "enableValidation": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * The input's label.
         */
        "label": string;
        "loggedIn": boolean;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScOrderReturnBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status": ReturnRequestStatus;
    }
    interface ScOrderShipmentBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status": OrderShipmentStatus;
    }
    interface ScOrderShippingAddress {
        "cityPlaceholder": string;
        "countryPlaceholder": string;
        /**
          * Default country for address
         */
        "defaultCountry": string;
        /**
          * Show the   address
         */
        "full": boolean;
        /**
          * Label for the field.
         */
        "label": string;
        "line1Placeholder": string;
        "line2Placeholder": string;
        /**
          * Show the placeholder fields.
         */
        "namePlaceholder": string;
        /**
          * Placeholder values.
         */
        "placeholders": Partial<Address>;
        "postalCodePlaceholder": string;
        "reportValidity": () => Promise<boolean>;
        /**
          * Whether to require the name in the address
         */
        "requireName": boolean;
        /**
          * Is this required (defaults to false)
         */
        "required": boolean;
        /**
          * Show the name field.
         */
        "showName": boolean;
        "statePlaceholder": string;
    }
    interface ScOrderStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status": OrderStatus;
    }
    interface ScOrderSubmit {
        /**
          * Currency Code
         */
        "currencyCode": string;
        /**
          * Show a full-width button.
         */
        "full": boolean;
        /**
          * Icon to show.
         */
        "icon": string;
        /**
          * Is the order loading.
         */
        "loading": boolean;
        /**
          * The current order.
         */
        "order": Checkout;
        /**
          * Is the order paying.
         */
        "paying": boolean;
        /**
          * The selected processor.
         */
        "processor": ProcessorName;
        /**
          * Keys and secrets for processors.
         */
        "processors": Processor[];
        /**
          * Show the secure notice
         */
        "secureNotice": boolean;
        /**
          * Secure
         */
        "secureNoticeText": string;
        /**
          * Show the total.
         */
        "showTotal": boolean;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The button type.
         */
        "type": 'default' | 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text' | 'link';
    }
    interface ScOrderSummary {
        "busy": boolean;
        "collapsed": boolean;
        "collapsedOnDesktop": boolean;
        "collapsedOnMobile": boolean;
        "collapsible": boolean;
        "invoiceSummaryText": string;
        "order": Checkout;
        "orderSummaryText": string;
    }
    interface ScOrderTaxIdInput {
        /**
          * AU zone label
         */
        "auAbnLabel": string;
        /**
          * GST zone label
         */
        "caGstLabel": string;
        /**
          * EU zone label
         */
        "euVatLabel": string;
        /**
          * UK zone label
         */
        "gbVatLabel": string;
        /**
          * Help text
         */
        "helpText": string;
        /**
          * Other zones label
         */
        "otherLabel": string;
        "reportValidity": () => Promise<boolean>;
        /**
          * Force show the field.
         */
        "show": boolean;
        /**
          * Tax ID Types which will be shown Eg: '["eu_vat", "gb_vat"]'
         */
        "taxIdTypes": string | string[];
    }
    interface ScOrdersList {
        "allLink": string;
        "heading": string;
        "isCustomer": boolean;
        /**
          * Query to fetch orders
         */
        "query": {
    page: number;
    per_page: number;
  };
    }
    interface ScPagination {
        "page": number;
        "perPage": number;
        "total": number;
        "totalPages": number;
        "totalShowing": number;
    }
    interface ScPassword {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * The input's password confirmation attribute.
         */
        "confirmation": boolean;
        /**
          * The input's confirmation help text.
         */
        "confirmationHelp": string;
        /**
          * The input's confirmation label text.
         */
        "confirmationLabel": string;
        /**
          * The input's confirmation placeholder text.
         */
        "confirmationPlaceholder": string;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Ensures strong password validation.
         */
        "enableValidation": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * The name for the input.
         */
        "name": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Sets focus on the input.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScPasswordNag {
        /**
          * Ensures strong password validation.
         */
        "enableValidation": boolean;
        "open": boolean;
        /**
          * The success url.
         */
        "successUrl": string;
        /**
          * The type of alert.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface ScPayment {
        /**
          * Disabled processor types
         */
        "disabledProcessorTypes": string[];
        /**
          * Hide the test mode badge
         */
        "hideTestModeBadge": boolean;
        /**
          * The input's label.
         */
        "label": string;
        "secureNotice": string;
        "stripePaymentElement": boolean;
    }
    interface ScPaymentMethod {
        "externalLink": string;
        "externalLinkTooltipText": string;
        "full": boolean;
        "paymentMethod": PaymentMethod;
    }
    interface ScPaymentMethodChoice {
        /**
          * Should we show this in a card?
         */
        "card": boolean;
        /**
          * Is this a manual processor
         */
        "isManual": boolean;
        /**
          * The method id
         */
        "methodId": string;
        /**
          * The processor ID
         */
        "processorId": string;
    }
    interface ScPaymentMethodDetails {
        "editHandler": () => void;
        "paymentMethod": PaymentMethod;
    }
    interface ScPaymentMethodsList {
        /**
          * Whether default payment method can be detached
         */
        "canDetachDefaultPaymentMethod": boolean;
        /**
          * The heading
         */
        "heading": string;
        /**
          * Is this a customer
         */
        "isCustomer": boolean;
        /**
          * Query to fetch paymentMethods
         */
        "query": object;
    }
    interface ScPaymentSelected {
        "iconName": string;
        "label": string;
    }
    interface ScPaypalAddMethod {
        "currency": string;
        "customerId": string;
        "liveMode": boolean;
        "successUrl": string;
    }
    interface ScPaypalButtons {
        /**
          * Is this busy?
         */
        "busy": boolean;
        /**
          * Buttons to render
         */
        "buttons": string[];
        /**
          * Client id for the script.
         */
        "clientId": string;
        /**
          * Button color.
         */
        "color": 'gold' | 'blue' | 'silver' | 'black' | 'white';
        /**
          * Label for the button.
         */
        "label": 'paypal' | 'checkout' | 'buynow' | 'pay' | 'installment';
        /**
          * The merchant id for paypal.
         */
        "merchantId": string;
        /**
          * Merchant initiated billing enabled.
         */
        "merchantInitiated": boolean;
        /**
          * Test or live mode.
         */
        "mode": 'test' | 'live';
        /**
          * The order.
         */
        "order": Checkout;
    }
    interface ScPaystackAddMethod {
        "currency": string;
        "customerId": string;
        "liveMode": boolean;
        "successUrl": string;
    }
    interface ScPhoneInput {
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect": string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Adds a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * Hidden
         */
        "hidden": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * The input's maximum value.
         */
        "max": number | string;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength": number;
        /**
          * The input's minimum value.
         */
        "min": number | string;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength": number;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * A pattern to validate input against.
         */
        "pattern": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Enables spell checking on the input.
         */
        "spellcheck": boolean;
        "squared": boolean;
        "squaredBottom": boolean;
        "squaredLeft": boolean;
        "squaredRight": boolean;
        "squaredTop": boolean;
        /**
          * The input's step attribute.
         */
        "step": number;
        /**
          * Adds a password toggle button to password inputs.
         */
        "togglePassword": boolean;
        /**
          * Removes focus from the input.
         */
        "triggerBlur": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScPillOption {
        /**
          * Label
         */
        "isSelected": boolean;
        "isUnavailable": boolean;
    }
    interface ScPremiumTag {
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
    }
    /**
     * Internal dependencies.
     */
    interface ScPrice {
        /**
          * Is the product ad_hoc?
         */
        "adHoc": boolean;
        /**
          * The amount
         */
        "amount": number;
        /**
          * The currency.
         */
        "currency": string;
        /**
          * The recurring interval
         */
        "recurringInterval": 'week' | 'month' | 'year' | 'never';
        /**
          * The recurring interval count
         */
        "recurringIntervalCount": number;
        /**
          * The recurring period count
         */
        "recurringPeriodCount": number;
        /**
          * The sale text
         */
        "saleText": string;
        /**
          * The scratch amount
         */
        "scratchAmount": number;
        /**
          * The setup fee amount
         */
        "setupFeeAmount": number;
        /**
          * The setup fee name
         */
        "setupFeeName": string;
        /**
          * The trial duration days
         */
        "trialDurationDays": number;
    }
    interface ScPriceChoice {
        /**
          * Is this blank?
         */
        "blank": boolean;
        /**
          * Is this checked by default
         */
        "checked": boolean;
        /**
          * Label for the choice.
         */
        "description": string;
        /**
          * Errors from response
         */
        "error": ResponseError;
        /**
          * Is this an ad-hoc price choice
         */
        "isAdHoc": Boolean;
        /**
          * Label for the choice.
         */
        "label": string;
        /**
          * Is this loading
         */
        "loading": boolean;
        /**
          * Session
         */
        "order": Checkout;
        /**
          * Stores the price
         */
        "price": Price;
        /**
          * Id of the price.
         */
        "priceId": string;
        /**
          * Price entities
         */
        "prices": Prices;
        /**
          * Stores the price
         */
        "product": Product;
        /**
          * Product entity
         */
        "products": Products;
        /**
          * Default quantity
         */
        "quantity": number;
        /**
          * Show the radio/checkbox control
         */
        "showControl": boolean;
        /**
          * Show the label
         */
        "showLabel": boolean;
        /**
          * Show the price amount
         */
        "showPrice": boolean;
        /**
          * Choice Type
         */
        "type": 'checkbox' | 'radio';
    }
    interface ScPriceChoiceContainer {
        /**
          * Is this checked by default
         */
        "checked": boolean;
        /**
          * Label for the choice.
         */
        "description": string;
        /**
          * Label for the choice.
         */
        "label": string;
        /**
          * Is this loading
         */
        "loading": boolean;
        /**
          * Stores the price
         */
        "price": string | Price;
        "required": boolean;
        /**
          * Show the radio/checkbox control
         */
        "showControl": boolean;
        /**
          * Show the label
         */
        "showLabel": boolean;
        /**
          * Show the price amount
         */
        "showPrice": boolean;
        /**
          * Choice Type
         */
        "type": 'checkbox' | 'radio';
    }
    interface ScPriceChoices {
        /**
          * Number of columns
         */
        "columns": number;
        /**
          * Selector label
         */
        "label": string;
        /**
          * Required by default
         */
        "required": boolean;
    }
    interface ScPriceInput {
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Adds a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * 3 letter currency code for input
         */
        "currencyCode": string;
        /**
          * Disables the input.
         */
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's help text.
         */
        "help": string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * The input's maximum value.
         */
        "max": number;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength": number;
        /**
          * The input's minimum value.
         */
        "min": number;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength": number;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the input readonly.
         */
        "readonly": boolean;
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the input a required field.
         */
        "required": boolean;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        /**
          * Show the currency code with the input
         */
        "showCode": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Removes focus from the input.
         */
        "triggerBlur": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScPriceRange {
        /**
          * The array of price objects
         */
        "prices": Price[];
    }
    interface ScProductBuyButton {
        "addToCart": boolean;
        "checkoutLink": string;
        "formId": number;
        "mode": 'live' | 'test';
        "productId": string;
    }
    interface ScProductDonationAmountChoice {
        /**
          * The label for the field.
         */
        "label": string;
        /**
          * The product id for the fields.
         */
        "productId": string;
        /**
          * The value of the field.
         */
        "value": number;
    }
    interface ScProductDonationChoices {
        /**
          * The label for the field.
         */
        "label": string;
        /**
          * The product id for the fields.
         */
        "productId": string;
        "recurring": boolean;
    }
    interface ScProductDonationCustomAmount {
        /**
          * Selected Product Id for the donation.
         */
        "productId": string;
        /**
          * Custom Amount of the donation.
         */
        "value": number;
    }
    interface ScProductItem {
        "layoutConfig": LayoutConfig;
        "product": Product;
    }
    interface ScProductItemImage {
        "product": Product;
        "sizing": 'cover' | 'contain';
    }
    interface ScProductItemList {
        /**
          * Should we paginate?
         */
        "ajaxPagination": boolean;
        /**
          * Should allow collection filter
         */
        "collectionEnabled": boolean;
        /**
          * Show for a specific collection
         */
        "collectionId": string;
        /**
          * Show only featured products.
         */
        "featured": boolean;
        /**
          * Limit to a set of ids.
         */
        "ids": string[];
        "layoutConfig": LayoutConfig1;
        "limit": number;
        "page": number;
        /**
          * The page title
         */
        "pageTitle": string;
        /**
          * Pagination
         */
        "pagination": {
    total: number;
    total_pages: number;
  };
        "paginationAlignment": string;
        /**
          * Should we auto-scroll to the top when paginating via ajax
         */
        "paginationAutoScroll": boolean;
        /**
          * Should we paginate?
         */
        "paginationEnabled": boolean;
        "products"?: Product[];
        /**
          * Query to search for
         */
        "query": string;
        /**
          * Should allow search
         */
        "searchEnabled": boolean;
        /**
          * Sort
         */
        "sort": string;
        /**
          * Should allow search
         */
        "sortEnabled": boolean;
    }
    interface ScProductItemPrice {
        /**
          * Product metrics
         */
        "metrics": ProductMetrics;
        "prices": Price[];
        /**
          * Show price range?
         */
        "range": boolean;
    }
    interface ScProductItemTitle {
    }
    interface ScProductLineItem {
        /**
          * Product monetary amount
         */
        "amount": number;
        /**
          * Currency for the product
         */
        "currency": string;
        /**
          * Can we select the quantity
         */
        "editable": boolean;
        /**
          * Product line item fees.
         */
        "fees": Fee[];
        /**
          * Image attributes.
         */
        "image": ImageAttributes;
        /**
          * Recurring interval (i.e. monthly, once, etc.)
         */
        "interval": string;
        /**
          * The max allowed.
         */
        "max": number;
        /**
          * Product name
         */
        "name": string;
        /**
          * Price name
         */
        "priceName"?: string;
        /**
          * The purchasable status display
         */
        "purchasableStatusDisplay": string;
        /**
          * Quantity
         */
        "quantity": number;
        /**
          * Is the line item removable
         */
        "removable": boolean;
        /**
          * The line item scratch amount
         */
        "scratchAmount": number;
        /**
          * Is the setup fee not included in the free trial?
         */
        "setupFeeTrialEnabled": boolean;
        /**
          * The SKU.
         */
        "sku": string;
        /**
          * Trial duration days
         */
        "trialDurationDays": number;
        /**
          * Product variant label
         */
        "variantLabel": string;
    }
    interface ScProductPillsVariantOption {
        /**
          * Label
         */
        "label": string;
        /**
          * Which option number?
         */
        "optionNumber": 1 | 2 | 3;
        /**
          * The product id
         */
        "productId": string;
    }
    interface ScProductPrice {
        /**
          * The product's prices.
         */
        "prices": Price[];
        /**
          * The product id
         */
        "productId": string;
        /**
          * The sale text
         */
        "saleText": string;
    }
    interface ScProductPriceChoices {
        /**
          * The product price choice label
         */
        "label": string;
        /**
          * The product id
         */
        "productId": string;
        /**
          * Whether to show the price
         */
        "showPrice": boolean;
    }
    interface ScProductPriceModal {
        /**
          * Whether to add to cart
         */
        "addToCart": boolean;
        /**
          * The button text
         */
        "buttonText": string;
        /**
          * The product id
         */
        "productId": string;
    }
    interface ScProductQuantity {
        /**
          * Display server-side validation errors.
         */
        "errors": any;
        /**
          * Help text
         */
        "help": string;
        /**
          * Input label.
         */
        "label": string;
        /**
          * Name for the input. Used for validation errors.
         */
        "name": string;
        /**
          * The product id
         */
        "productId": string;
        /**
          * Whether the input is required.
         */
        "required": boolean;
        /**
          * Show the label.
         */
        "showLabel": boolean;
        /**
          * Size of the control
         */
        "size": 'small' | 'medium' | 'large';
    }
    interface ScProductSelectedPrice {
        /**
          * The product id.
         */
        "productId": string;
    }
    interface ScProductText {
        "productId": string;
        "text": 'name' | 'description';
    }
    interface ScProse {
    }
    interface ScProvider {
        "STENCIL_CONTEXT": { [key: string]: any };
    }
    interface ScProvisionalBanner {
        /**
          * Claim URL.
         */
        "claimUrl": string;
    }
    interface ScPurchaseDownloadsList {
        "allLink": string;
        "busy": boolean;
        "error": string;
        "heading": string;
        "loading": boolean;
        "purchases": Array<Purchase>;
        "requestNonce": string;
    }
    interface ScQuantitySelect {
        "clickEl"?: HTMLElement;
        "disabled": boolean;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        "max": number;
        "min": number;
        "quantity": number;
        "size": 'small' | 'medium' | 'large';
    }
    interface ScRadio {
        /**
          * Simulates a click on the radio.
         */
        "ceClick": () => Promise<void>;
        /**
          * Draws the radio in a checked state.
         */
        "checked": boolean;
        /**
          * Is the radio disabled
         */
        "disabled": boolean;
        /**
          * This will be true as a workaround in the block editor to focus on the content.
         */
        "edit": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid": boolean;
        /**
          * The radios name attribute
         */
        "name": string;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Is this required
         */
        "required": boolean;
        /**
          * The radios value
         */
        "value": string;
    }
    interface ScRadioGroup {
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The radio group label. Required for proper accessibility.
         */
        "label": string;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Is one of these items required.
         */
        "required": boolean;
        /**
          * The selected value of the control.
         */
        "value": string;
    }
    interface ScRecurringPriceChoiceContainer {
        /**
          * Label for the choice.
         */
        "label": string;
        /**
          * The prices to choose from.
         */
        "prices": Price[];
        /**
          * The product.
         */
        "product": Product;
        /**
          * The currently selected price
         */
        "selectedPrice": Price;
        /**
          * Should we show the price?
         */
        "showAmount": boolean;
        /**
          * Show the radio/checkbox control
         */
        "showControl": boolean;
        /**
          * Should we show the price details?
         */
        "showDetails": boolean;
    }
    interface ScRichText {
        /**
          * Disables the textarea.
         */
        "disabled": boolean;
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "help": string;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The max length.
         */
        "maxlength": number;
        /**
          * The textarea's name attribute.
         */
        "name": string;
        /**
          * The textarea's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the textarea readonly.
         */
        "readonly": boolean;
        /**
          * Makes the textarea a required field.
         */
        "required": boolean;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The textarea's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The textarea's value attribute.
         */
        "value": string;
    }
    interface ScSecureNotice {
    }
    interface ScSelect {
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The input's value attribute.
         */
        "choices": Array<ChoiceItem>;
        "closeOnSelect": boolean;
        "disabled": boolean;
        /**
          * Some help text for the input.
         */
        "help": string;
        "hoist": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        "loading": boolean;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * Is this open
         */
        "open": boolean;
        /**
          * Placeholder for no value
         */
        "placeholder": string;
        /**
          * The placement of the dropdown.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        "position": 'bottom-left' | 'bottom-right' | 'top-left' | 'top-right';
        "reportValidity": () => Promise<boolean>;
        "required": boolean;
        /**
          * Is search enabled?
         */
        "search": boolean;
        /**
          * Placeholder for search
         */
        "searchPlaceholder": string;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        "showParentLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        "squared": boolean;
        "squaredBottom": boolean;
        "squaredLeft": boolean;
        "squaredRight": boolean;
        "squaredTop": boolean;
        /**
          * Can we unselect items.
         */
        "unselect": boolean;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ScSessionProvider {
        /**
          * Finalize the order.
          * @returns
         */
        "finalize": () => Promise<Checkout | NodeJS.Timeout | Error>;
        /**
          * Should we persist the session.
         */
        "persist": boolean;
        /**
          * An array of prices to pre-fill in the form.
         */
        "prices": Array<PriceChoice>;
    }
    interface ScShippingChoices {
        /**
          * The shipping section label
         */
        "label": string;
        /**
          * Whether to show the shipping choice description
         */
        "showDescription": boolean;
    }
    interface ScSkeleton {
        /**
          * Animation effect
         */
        "effect": 'pulse' | 'sheen' | 'none';
    }
    interface ScSpacing {
    }
    interface ScSpinner {
    }
    interface ScStackedList {
    }
    interface ScStackedListRow {
        "href": string;
        "mobileSize": number;
        "target": string;
    }
    interface ScStripeAddMethod {
        "customerId": string;
        "liveMode": boolean;
        "successUrl": string;
    }
    interface ScStripeElement {
        /**
          * Confirm card payment
         */
        "confirmCardPayment": (secret: any) => Promise<any>;
        /**
          * Confirm card setup.
         */
        "confirmCardSetup": (secret: any) => Promise<any>;
        /**
          * Whether this field is disabled
         */
        "disabled": boolean;
        /**
          * The form state
         */
        "formState": FormState;
        /**
          * Inputs focus
         */
        "hasFocus": boolean;
        /**
          * The input's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * Mode for the payment
         */
        "mode": 'live' | 'test';
        /**
          * The checkout session object for finalizing intents
         */
        "order": Checkout;
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "secureText": string;
        /**
          * The selected processor id
         */
        "selectedProcessorId": ProcessorName;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
    }
    interface ScStripePaymentElement {
        "confirm": (type: any, args?: {}) => Promise<void>;
    }
    interface ScStripePaymentRequest {
        /**
          * Amount
         */
        "amount": number;
        /**
          * Country
         */
        "country": string;
        /**
          * Is this in debug mode.
         */
        "debug": boolean;
        "error": ResponseError | null;
        /**
          * Label
         */
        "label": string;
        /**
          * Prices
         */
        "prices": Prices;
        /**
          * Stripe publishable key
         */
        "publishableKey": string;
        /**
          * Your stripe connected account id.
         */
        "stripeAccountId": string;
        /**
          * Payment request theme
         */
        "theme": string;
    }
    interface ScSubscription {
        /**
          * Heading to display
         */
        "heading": string;
        /**
          * The subscription protocol
         */
        "protocol": SubscriptionProtocol;
        /**
          * Query to pass to the API
         */
        "query": object;
        /**
          * Whether to show the cancel button
         */
        "showCancel": boolean;
        /**
          * The subscription
         */
        "subscription": Subscription;
        /**
          * The subscription ID
         */
        "subscriptionId": string;
        /**
          * Update the payment method url
         */
        "updatePaymentMethodUrl": string;
    }
    interface ScSubscriptionAdHocConfirm {
        "heading": string;
        "price": Price;
    }
    interface ScSubscriptionCancel {
        "backUrl": string;
        "comment": string;
        "heading": string;
        "protocol": SubscriptionProtocol;
        "reason": CancellationReason;
        "subscription": Subscription;
        "successUrl": string;
    }
    interface ScSubscriptionDetails {
        "hideRenewalText": boolean;
        "pendingPrice": Price;
        "subscription": Subscription;
    }
    interface ScSubscriptionNextPayment {
        "subscription": Subscription;
        /**
          * Update the payment method url
         */
        "updatePaymentMethodUrl": string;
    }
    interface ScSubscriptionPayment {
        "backUrl": string;
        "customerIds": Array<string>;
        "paymentMethods": Array<PaymentMethod>;
        "subscription": Subscription;
        "subscriptionId": string;
        "successUrl": string;
    }
    interface ScSubscriptionPaymentMethod {
        /**
          * The heading
         */
        "heading": string;
        /**
          * The subscription
         */
        "subscription": Subscription;
    }
    interface ScSubscriptionReactivate {
        /**
          * Whether it is open
         */
        "open": boolean;
        /**
          * The subscription to reactivate
         */
        "subscription": Subscription;
    }
    interface ScSubscriptionStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Subscription status
         */
        "status": SubscriptionStatus;
        /**
          * The tag's status type.
         */
        "subscription": Subscription;
    }
    interface ScSubscriptionSwitch {
        "filterAbove": number;
        "heading": string;
        "productGroupId": ProductGroup;
        "productId": string;
        /**
          * Customer id to fetch subscriptions
         */
        "query": object;
        "subscription": Subscription;
        "successUrl": string;
    }
    interface ScSubscriptionVariationConfirm {
        "heading": string;
        "price": Price;
        "product": Product;
        "subscription": Subscription;
    }
    interface ScSubscriptionsList {
        "allLink": string;
        "cancelBehavior": 'period_end' | 'immediate';
        "heading": string;
        "isCustomer": boolean;
        /**
          * Customer id to fetch subscriptions
         */
        "query": {
    page: number;
    per_page: number;
  };
    }
    interface ScSummary {
        "busy": boolean;
        "closedText": string;
        "collapsed": boolean;
        "collapsedOnDesktop": boolean;
        "collapsedOnMobile": boolean;
        "collapsible": boolean;
        "loading": boolean;
        "openText": string;
    }
    interface ScSwitch {
        /**
          * Draws the switch in a checked state.
         */
        "checked": boolean;
        /**
          * Disables the switch.
         */
        "disabled": boolean;
        /**
          * This will be true as a workaround in the block editor to focus on the content.
         */
        "edit": boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid": boolean;
        /**
          * The switch's name attribute.
         */
        "name": string;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the switch a required field.
         */
        "required": boolean;
        "reversed": boolean;
        /**
          * The switch's value attribute.
         */
        "value": string;
    }
    interface ScTab {
        /**
          * Draws the tab in an active state.
         */
        "active": boolean;
        "count": string;
        /**
          * Draws the tab in a disabled state.
         */
        "disabled": boolean;
        "href": string;
        /**
          * The name of the tab panel the tab will control. The panel must be located in the same tab group.
         */
        "panel": string;
        /**
          * Removes focus from the tab.
         */
        "triggerBlur": () => Promise<void>;
        /**
          * Sets focus to the tab.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
    }
    interface ScTabGroup {
    }
    interface ScTabPanel {
        /**
          * When true, the tab panel will be shown.
         */
        "active": boolean;
        /**
          * The tab panel's name.
         */
        "name": string;
    }
    interface ScTable {
    }
    interface ScTableCell {
    }
    interface ScTableHead {
    }
    interface ScTableRow {
        "href": string;
    }
    interface ScTag {
        /**
          * Aria label
         */
        "ariaLabel": string;
        /**
          * Makes the tag clearable.
         */
        "clearable": boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'default';
    }
    interface ScTaxIdInput {
        /**
          * AU zone label
         */
        "auAbnLabel": string;
        /**
          * GST zone label
         */
        "caGstLabel": string;
        /**
          * The country code.
         */
        "country": string;
        /**
          * EU zone label
         */
        "euVatLabel": string;
        /**
          * UK zone label
         */
        "gbVatLabel": string;
        /**
          * Help text.
         */
        "help": string;
        /**
          * Is this loading?
         */
        "loading": boolean;
        /**
          * Tax ID Number
         */
        "number": string;
        /**
          * Other zones label
         */
        "otherLabel": string;
        "reportValidity": () => Promise<boolean>;
        /**
          * Whether tax input is required
         */
        "required": boolean;
        /**
          * Force show the field.
         */
        "show": boolean;
        /**
          * The status
         */
        "status": 'valid' | 'invalid' | 'unknown';
        /**
          * Tax ID Types which will be shown
         */
        "taxIdTypes": string[];
        /**
          * Type of tax id
         */
        "type": string;
    }
    interface ScText {
        "tag": 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p';
        "truncate": boolean;
    }
    interface ScTextarea {
        /**
          * The textarea's autocapitalize attribute.
         */
        "autocapitalize": 'off' | 'none' | 'on' | 'sentences' | 'words' | 'characters';
        /**
          * The textarea's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The textarea's autocorrect attribute.
         */
        "autocorrect": string;
        /**
          * The textarea's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Disables the textarea.
         */
        "disabled": boolean;
        /**
          * The input's enterkeyhint attribute. This can be used to customize the label or icon of the Enter key on virtual keyboards.
         */
        "enterkeyhint": 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * Draws a filled textarea.
         */
        "filled": boolean;
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "help": string;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, and `maxlength` using the browser's constraint validation API.
         */
        "invalid": boolean;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength": number;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength": number;
        /**
          * The textarea's name attribute.
         */
        "name": string;
        /**
          * The textarea's placeholder text.
         */
        "placeholder": string;
        /**
          * Makes the textarea readonly.
         */
        "readonly": boolean;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<boolean>;
        /**
          * Makes the textarea a required field.
         */
        "required": boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize": 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows": number;
        /**
          * Should we show the label
         */
        "showLabel": boolean;
        /**
          * The textarea's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Enables spell checking on the textarea.
         */
        "spellcheck": boolean;
        /**
          * Sets focus on the input.
         */
        "triggerFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The textarea's value attribute.
         */
        "value": string;
    }
    interface ScToggle {
        /**
          * Is this a borderless toggle?
         */
        "borderless": boolean;
        /**
          * Are these collapsible?
         */
        "collapsible": boolean;
        /**
          * Disables the details so it can't be toggled.
         */
        "disabled": boolean;
        /**
          * Indicates whether or not the details is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * Is this a shady
         */
        "shady": boolean;
        /**
          * Should we show a radio control?
         */
        "showControl": boolean;
        /**
          * Should we show the arrow icon?
         */
        "showIcon": boolean;
        /**
          * The summary to show in the details header. If you need to display HTML, use the `summary` slot instead.
         */
        "summary": string;
    }
    interface ScToggles {
        /**
          * Should this function as an accordion?
         */
        "accordion": boolean;
        /**
          * Are these collapsible?
         */
        "collapsible": boolean;
        /**
          * Theme for the toggles
         */
        "theme": 'default' | 'container';
    }
    interface ScTooltip {
        /**
          * Freeze open or closed.
         */
        "freeze": boolean;
        /**
          * Open or not
         */
        "open": boolean;
        /**
          * The tooltip's padding.
         */
        "padding": number;
        /**
          * Tooltip text
         */
        "text": string;
        /**
          * The tooltip's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text';
        /**
          * Tooltip fixed width
         */
        "width": string;
    }
    interface ScTotal {
        "order": Checkout;
        "total": 'total' | 'subtotal' | 'amount_due';
    }
    interface ScUpcomingInvoice {
        "adHocAmount": number;
        "discount": {
    promotion_code?: string;
    coupon?: string;
  };
        "heading": string;
        "payment_method": PaymentMethod;
        "priceId": string;
        "quantity": number;
        "quantityUpdatesEnabled": boolean;
        "subscriptionId": string;
        "successUrl": string;
        "variantId": string;
    }
    interface ScUpgradeRequired {
        /**
          * Whether to render upgrade modal by default
         */
        "open": boolean;
        /**
          * Is this required?
         */
        "required": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
    }
    interface ScUpsell {
    }
    interface ScUpsellCountdownTimer {
        /**
          * Whether to show the icon.
         */
        "showIcon": boolean;
    }
    interface ScUpsellNoThanksButton {
    }
    interface ScUpsellSubmitButton {
    }
    interface ScUpsellTotals {
    }
    interface ScVisuallyHidden {
    }
    interface ScWordpressPasswordEdit {
        /**
          * Ensures strong password validation.
         */
        "enableValidation": boolean;
        "heading": string;
        "successUrl": string;
        "user": WordPressUser;
    }
    interface ScWordpressUser {
        "heading": string;
        "user": WordPressUser;
    }
    interface ScWordpressUserEdit {
        "heading": string;
        "successUrl": string;
        "user": WordPressUser;
    }
}
export interface ScAddressCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScAddressElement;
}
export interface ScAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScAlertElement;
}
export interface ScButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScButtonElement;
}
export interface ScCancelDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCancelDialogElement;
}
export interface ScCancelDiscountCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCancelDiscountElement;
}
export interface ScCancelSurveyCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCancelSurveyElement;
}
export interface ScCartHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCartHeaderElement;
}
export interface ScCartSessionProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCartSessionProviderElement;
}
export interface ScCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCheckboxElement;
}
export interface ScCheckoutCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCheckoutElement;
}
export interface ScCheckoutStockAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCheckoutStockAlertElement;
}
export interface ScCheckoutTestCompleteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCheckoutTestCompleteElement;
}
export interface ScChoiceCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScChoiceElement;
}
export interface ScChoiceContainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScChoiceContainerElement;
}
export interface ScCompactAddressCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCompactAddressElement;
}
export interface ScConsumerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScConsumerElement;
}
export interface ScCouponFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCouponFormElement;
}
export interface ScCustomOrderPriceInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCustomOrderPriceInputElement;
}
export interface ScCustomerEmailCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCustomerEmailElement;
}
export interface ScCustomerFirstnameCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCustomerFirstnameElement;
}
export interface ScCustomerLastnameCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCustomerLastnameElement;
}
export interface ScCustomerNameCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCustomerNameElement;
}
export interface ScCustomerPhoneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScCustomerPhoneElement;
}
export interface ScDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScDialogElement;
}
export interface ScDonationChoicesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScDonationChoicesElement;
}
export interface ScDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScDrawerElement;
}
export interface ScDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScDropdownElement;
}
export interface ScErrorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScErrorElement;
}
export interface ScFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScFormElement;
}
export interface ScFormStateProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScFormStateProviderElement;
}
export interface ScIconCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScIconElement;
}
export interface ScInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScInputElement;
}
export interface ScLineItemsProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScLineItemsProviderElement;
}
export interface ScLoginProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScLoginProviderElement;
}
export interface ScMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScMenuElement;
}
export interface ScOrderConfirmProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScOrderConfirmProviderElement;
}
export interface ScOrderSummaryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScOrderSummaryElement;
}
export interface ScPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPaginationElement;
}
export interface ScPaypalButtonsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPaypalButtonsElement;
}
export interface ScPhoneInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPhoneInputElement;
}
export interface ScPriceChoiceCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPriceChoiceElement;
}
export interface ScPriceChoiceContainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPriceChoiceContainerElement;
}
export interface ScPriceChoicesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPriceChoicesElement;
}
export interface ScPriceInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScPriceInputElement;
}
export interface ScProductItemListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScProductItemListElement;
}
export interface ScProductLineItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScProductLineItemElement;
}
export interface ScProductSelectedPriceCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScProductSelectedPriceElement;
}
export interface ScProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScProviderElement;
}
export interface ScQuantitySelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScQuantitySelectElement;
}
export interface ScRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScRadioElement;
}
export interface ScRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScRadioGroupElement;
}
export interface ScRecurringPriceChoiceContainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScRecurringPriceChoiceContainerElement;
}
export interface ScRichTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScRichTextElement;
}
export interface ScSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScSelectElement;
}
export interface ScSessionProviderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScSessionProviderElement;
}
export interface ScStripeElementCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScStripeElementElement;
}
export interface ScStripePaymentElementCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScStripePaymentElementElement;
}
export interface ScStripePaymentRequestCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScStripePaymentRequestElement;
}
export interface ScSubscriptionCancelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScSubscriptionCancelElement;
}
export interface ScSubscriptionReactivateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScSubscriptionReactivateElement;
}
export interface ScSummaryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScSummaryElement;
}
export interface ScSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScSwitchElement;
}
export interface ScTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScTabElement;
}
export interface ScTabGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScTabGroupElement;
}
export interface ScTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScTagElement;
}
export interface ScTaxIdInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScTaxIdInputElement;
}
export interface ScTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScTextareaElement;
}
export interface ScToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScToggleElement;
}
declare global {
    interface HTMLScAddressElementEventMap {
        "scChangeAddress": Partial<Address>;
        "scInputAddress": Partial<Address>;
    }
    interface HTMLScAddressElement extends Components.ScAddress, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScAddressElementEventMap>(type: K, listener: (this: HTMLScAddressElement, ev: ScAddressCustomEvent<HTMLScAddressElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScAddressElementEventMap>(type: K, listener: (this: HTMLScAddressElement, ev: ScAddressCustomEvent<HTMLScAddressElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScAddressElement: {
        prototype: HTMLScAddressElement;
        new (): HTMLScAddressElement;
    };
    interface HTMLScAlertElementEventMap {
        "scHide": void;
        "scShow": void;
    }
    interface HTMLScAlertElement extends Components.ScAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScAlertElementEventMap>(type: K, listener: (this: HTMLScAlertElement, ev: ScAlertCustomEvent<HTMLScAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScAlertElementEventMap>(type: K, listener: (this: HTMLScAlertElement, ev: ScAlertCustomEvent<HTMLScAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScAlertElement: {
        prototype: HTMLScAlertElement;
        new (): HTMLScAlertElement;
    };
    interface HTMLScAvatarElement extends Components.ScAvatar, HTMLStencilElement {
    }
    var HTMLScAvatarElement: {
        prototype: HTMLScAvatarElement;
        new (): HTMLScAvatarElement;
    };
    interface HTMLScBadgeNoticeElement extends Components.ScBadgeNotice, HTMLStencilElement {
    }
    var HTMLScBadgeNoticeElement: {
        prototype: HTMLScBadgeNoticeElement;
        new (): HTMLScBadgeNoticeElement;
    };
    interface HTMLScBlockUiElement extends Components.ScBlockUi, HTMLStencilElement {
    }
    var HTMLScBlockUiElement: {
        prototype: HTMLScBlockUiElement;
        new (): HTMLScBlockUiElement;
    };
    interface HTMLScBreadcrumbElement extends Components.ScBreadcrumb, HTMLStencilElement {
    }
    var HTMLScBreadcrumbElement: {
        prototype: HTMLScBreadcrumbElement;
        new (): HTMLScBreadcrumbElement;
    };
    interface HTMLScBreadcrumbsElement extends Components.ScBreadcrumbs, HTMLStencilElement {
    }
    var HTMLScBreadcrumbsElement: {
        prototype: HTMLScBreadcrumbsElement;
        new (): HTMLScBreadcrumbsElement;
    };
    interface HTMLScButtonElementEventMap {
        "scBlur": void;
        "scFocus": void;
    }
    interface HTMLScButtonElement extends Components.ScButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScButtonElementEventMap>(type: K, listener: (this: HTMLScButtonElement, ev: ScButtonCustomEvent<HTMLScButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScButtonElementEventMap>(type: K, listener: (this: HTMLScButtonElement, ev: ScButtonCustomEvent<HTMLScButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScButtonElement: {
        prototype: HTMLScButtonElement;
        new (): HTMLScButtonElement;
    };
    interface HTMLScButtonGroupElement extends Components.ScButtonGroup, HTMLStencilElement {
    }
    var HTMLScButtonGroupElement: {
        prototype: HTMLScButtonGroupElement;
        new (): HTMLScButtonGroupElement;
    };
    interface HTMLScCancelDialogElementEventMap {
        "scRequestClose": 'close-button' | 'keyboard' | 'overlay';
        "scRefresh": void;
    }
    interface HTMLScCancelDialogElement extends Components.ScCancelDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCancelDialogElementEventMap>(type: K, listener: (this: HTMLScCancelDialogElement, ev: ScCancelDialogCustomEvent<HTMLScCancelDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCancelDialogElementEventMap>(type: K, listener: (this: HTMLScCancelDialogElement, ev: ScCancelDialogCustomEvent<HTMLScCancelDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCancelDialogElement: {
        prototype: HTMLScCancelDialogElement;
        new (): HTMLScCancelDialogElement;
    };
    interface HTMLScCancelDiscountElementEventMap {
        "scCancel": void;
        "scPreserved": void;
    }
    interface HTMLScCancelDiscountElement extends Components.ScCancelDiscount, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCancelDiscountElementEventMap>(type: K, listener: (this: HTMLScCancelDiscountElement, ev: ScCancelDiscountCustomEvent<HTMLScCancelDiscountElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCancelDiscountElementEventMap>(type: K, listener: (this: HTMLScCancelDiscountElement, ev: ScCancelDiscountCustomEvent<HTMLScCancelDiscountElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCancelDiscountElement: {
        prototype: HTMLScCancelDiscountElement;
        new (): HTMLScCancelDiscountElement;
    };
    interface HTMLScCancelSurveyElementEventMap {
        "scAbandon": void;
        "scSubmitReason": { reason: CancellationReason; comment: string };
    }
    interface HTMLScCancelSurveyElement extends Components.ScCancelSurvey, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCancelSurveyElementEventMap>(type: K, listener: (this: HTMLScCancelSurveyElement, ev: ScCancelSurveyCustomEvent<HTMLScCancelSurveyElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCancelSurveyElementEventMap>(type: K, listener: (this: HTMLScCancelSurveyElement, ev: ScCancelSurveyCustomEvent<HTMLScCancelSurveyElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCancelSurveyElement: {
        prototype: HTMLScCancelSurveyElement;
        new (): HTMLScCancelSurveyElement;
    };
    interface HTMLScCardElement extends Components.ScCard, HTMLStencilElement {
    }
    var HTMLScCardElement: {
        prototype: HTMLScCardElement;
        new (): HTMLScCardElement;
    };
    interface HTMLScCartElement extends Components.ScCart, HTMLStencilElement {
    }
    var HTMLScCartElement: {
        prototype: HTMLScCartElement;
        new (): HTMLScCartElement;
    };
    interface HTMLScCartButtonElement extends Components.ScCartButton, HTMLStencilElement {
    }
    var HTMLScCartButtonElement: {
        prototype: HTMLScCartButtonElement;
        new (): HTMLScCartButtonElement;
    };
    interface HTMLScCartFormElement extends Components.ScCartForm, HTMLStencilElement {
    }
    var HTMLScCartFormElement: {
        prototype: HTMLScCartFormElement;
        new (): HTMLScCartFormElement;
    };
    interface HTMLScCartFormSubmitElement extends Components.ScCartFormSubmit, HTMLStencilElement {
    }
    var HTMLScCartFormSubmitElement: {
        prototype: HTMLScCartFormSubmitElement;
        new (): HTMLScCartFormSubmitElement;
    };
    interface HTMLScCartHeaderElementEventMap {
        "scCloseCart": void;
    }
    interface HTMLScCartHeaderElement extends Components.ScCartHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCartHeaderElementEventMap>(type: K, listener: (this: HTMLScCartHeaderElement, ev: ScCartHeaderCustomEvent<HTMLScCartHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCartHeaderElementEventMap>(type: K, listener: (this: HTMLScCartHeaderElement, ev: ScCartHeaderCustomEvent<HTMLScCartHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCartHeaderElement: {
        prototype: HTMLScCartHeaderElement;
        new (): HTMLScCartHeaderElement;
    };
    interface HTMLScCartIconElement extends Components.ScCartIcon, HTMLStencilElement {
    }
    var HTMLScCartIconElement: {
        prototype: HTMLScCartIconElement;
        new (): HTMLScCartIconElement;
    };
    interface HTMLScCartLoaderElement extends Components.ScCartLoader, HTMLStencilElement {
    }
    var HTMLScCartLoaderElement: {
        prototype: HTMLScCartLoaderElement;
        new (): HTMLScCartLoaderElement;
    };
    interface HTMLScCartSessionProviderElementEventMap {
        "scSetState": 'loading' | 'busy' | 'navigating' | 'idle';
    }
    interface HTMLScCartSessionProviderElement extends Components.ScCartSessionProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCartSessionProviderElementEventMap>(type: K, listener: (this: HTMLScCartSessionProviderElement, ev: ScCartSessionProviderCustomEvent<HTMLScCartSessionProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCartSessionProviderElementEventMap>(type: K, listener: (this: HTMLScCartSessionProviderElement, ev: ScCartSessionProviderCustomEvent<HTMLScCartSessionProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCartSessionProviderElement: {
        prototype: HTMLScCartSessionProviderElement;
        new (): HTMLScCartSessionProviderElement;
    };
    interface HTMLScCartSubmitElement extends Components.ScCartSubmit, HTMLStencilElement {
    }
    var HTMLScCartSubmitElement: {
        prototype: HTMLScCartSubmitElement;
        new (): HTMLScCartSubmitElement;
    };
    interface HTMLScCcLogoElement extends Components.ScCcLogo, HTMLStencilElement {
    }
    var HTMLScCcLogoElement: {
        prototype: HTMLScCcLogoElement;
        new (): HTMLScCcLogoElement;
    };
    interface HTMLScChargesListElement extends Components.ScChargesList, HTMLStencilElement {
    }
    var HTMLScChargesListElement: {
        prototype: HTMLScChargesListElement;
        new (): HTMLScChargesListElement;
    };
    interface HTMLScCheckboxElementEventMap {
        "scBlur": void;
        "scChange": void;
        "scFocus": void;
    }
    interface HTMLScCheckboxElement extends Components.ScCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCheckboxElementEventMap>(type: K, listener: (this: HTMLScCheckboxElement, ev: ScCheckboxCustomEvent<HTMLScCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCheckboxElementEventMap>(type: K, listener: (this: HTMLScCheckboxElement, ev: ScCheckboxCustomEvent<HTMLScCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCheckboxElement: {
        prototype: HTMLScCheckboxElement;
        new (): HTMLScCheckboxElement;
    };
    interface HTMLScCheckoutElementEventMap {
        "scOrderUpdated": Checkout;
        "scOrderFinalized": Checkout;
        "scOrderError": ResponseError;
    }
    interface HTMLScCheckoutElement extends Components.ScCheckout, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCheckoutElementEventMap>(type: K, listener: (this: HTMLScCheckoutElement, ev: ScCheckoutCustomEvent<HTMLScCheckoutElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCheckoutElementEventMap>(type: K, listener: (this: HTMLScCheckoutElement, ev: ScCheckoutCustomEvent<HTMLScCheckoutElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCheckoutElement: {
        prototype: HTMLScCheckoutElement;
        new (): HTMLScCheckoutElement;
    };
    /**
     * This component listens for a confirmed event and redirects to the success url.
     */
    interface HTMLScCheckoutFormErrorsElement extends Components.ScCheckoutFormErrors, HTMLStencilElement {
    }
    var HTMLScCheckoutFormErrorsElement: {
        prototype: HTMLScCheckoutFormErrorsElement;
        new (): HTMLScCheckoutFormErrorsElement;
    };
    interface HTMLScCheckoutMolliePaymentElement extends Components.ScCheckoutMolliePayment, HTMLStencilElement {
    }
    var HTMLScCheckoutMolliePaymentElement: {
        prototype: HTMLScCheckoutMolliePaymentElement;
        new (): HTMLScCheckoutMolliePaymentElement;
    };
    interface HTMLScCheckoutPaystackPaymentProviderElement extends Components.ScCheckoutPaystackPaymentProvider, HTMLStencilElement {
    }
    var HTMLScCheckoutPaystackPaymentProviderElement: {
        prototype: HTMLScCheckoutPaystackPaymentProviderElement;
        new (): HTMLScCheckoutPaystackPaymentProviderElement;
    };
    interface HTMLScCheckoutProductPriceVariantSelectorElement extends Components.ScCheckoutProductPriceVariantSelector, HTMLStencilElement {
    }
    var HTMLScCheckoutProductPriceVariantSelectorElement: {
        prototype: HTMLScCheckoutProductPriceVariantSelectorElement;
        new (): HTMLScCheckoutProductPriceVariantSelectorElement;
    };
    interface HTMLScCheckoutStockAlertElementEventMap {
        "scUpdateLineItem": LineItemData;
    }
    /**
     * This component listens for stock requirements and displays a dialog to the user.
     */
    interface HTMLScCheckoutStockAlertElement extends Components.ScCheckoutStockAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCheckoutStockAlertElementEventMap>(type: K, listener: (this: HTMLScCheckoutStockAlertElement, ev: ScCheckoutStockAlertCustomEvent<HTMLScCheckoutStockAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCheckoutStockAlertElementEventMap>(type: K, listener: (this: HTMLScCheckoutStockAlertElement, ev: ScCheckoutStockAlertCustomEvent<HTMLScCheckoutStockAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCheckoutStockAlertElement: {
        prototype: HTMLScCheckoutStockAlertElement;
        new (): HTMLScCheckoutStockAlertElement;
    };
    interface HTMLScCheckoutTestCompleteElementEventMap {
        "scOrderPaid": Checkout;
        "scSetState": string;
    }
    /**
     * This component listens to the order status
     * and confirms the order when payment is successful.
     */
    interface HTMLScCheckoutTestCompleteElement extends Components.ScCheckoutTestComplete, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCheckoutTestCompleteElementEventMap>(type: K, listener: (this: HTMLScCheckoutTestCompleteElement, ev: ScCheckoutTestCompleteCustomEvent<HTMLScCheckoutTestCompleteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCheckoutTestCompleteElementEventMap>(type: K, listener: (this: HTMLScCheckoutTestCompleteElement, ev: ScCheckoutTestCompleteCustomEvent<HTMLScCheckoutTestCompleteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCheckoutTestCompleteElement: {
        prototype: HTMLScCheckoutTestCompleteElement;
        new (): HTMLScCheckoutTestCompleteElement;
    };
    interface HTMLScCheckoutUnsavedChangesWarningElement extends Components.ScCheckoutUnsavedChangesWarning, HTMLStencilElement {
    }
    var HTMLScCheckoutUnsavedChangesWarningElement: {
        prototype: HTMLScCheckoutUnsavedChangesWarningElement;
        new (): HTMLScCheckoutUnsavedChangesWarningElement;
    };
    interface HTMLScChoiceElementEventMap {
        "scBlur": void;
        "scChange": boolean;
        "scFocus": void;
    }
    interface HTMLScChoiceElement extends Components.ScChoice, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScChoiceElementEventMap>(type: K, listener: (this: HTMLScChoiceElement, ev: ScChoiceCustomEvent<HTMLScChoiceElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScChoiceElementEventMap>(type: K, listener: (this: HTMLScChoiceElement, ev: ScChoiceCustomEvent<HTMLScChoiceElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScChoiceElement: {
        prototype: HTMLScChoiceElement;
        new (): HTMLScChoiceElement;
    };
    interface HTMLScChoiceContainerElementEventMap {
        "scBlur": void;
        "scChange": boolean;
        "scFocus": void;
    }
    interface HTMLScChoiceContainerElement extends Components.ScChoiceContainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScChoiceContainerElementEventMap>(type: K, listener: (this: HTMLScChoiceContainerElement, ev: ScChoiceContainerCustomEvent<HTMLScChoiceContainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScChoiceContainerElementEventMap>(type: K, listener: (this: HTMLScChoiceContainerElement, ev: ScChoiceContainerCustomEvent<HTMLScChoiceContainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScChoiceContainerElement: {
        prototype: HTMLScChoiceContainerElement;
        new (): HTMLScChoiceContainerElement;
    };
    interface HTMLScChoicesElement extends Components.ScChoices, HTMLStencilElement {
    }
    var HTMLScChoicesElement: {
        prototype: HTMLScChoicesElement;
        new (): HTMLScChoicesElement;
    };
    interface HTMLScColumnElement extends Components.ScColumn, HTMLStencilElement {
    }
    var HTMLScColumnElement: {
        prototype: HTMLScColumnElement;
        new (): HTMLScColumnElement;
    };
    interface HTMLScColumnsElement extends Components.ScColumns, HTMLStencilElement {
    }
    var HTMLScColumnsElement: {
        prototype: HTMLScColumnsElement;
        new (): HTMLScColumnsElement;
    };
    interface HTMLScCompactAddressElementEventMap {
        "scChangeAddress": Partial<Address>;
        "scInputAddress": Partial<Address>;
    }
    interface HTMLScCompactAddressElement extends Components.ScCompactAddress, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCompactAddressElementEventMap>(type: K, listener: (this: HTMLScCompactAddressElement, ev: ScCompactAddressCustomEvent<HTMLScCompactAddressElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCompactAddressElementEventMap>(type: K, listener: (this: HTMLScCompactAddressElement, ev: ScCompactAddressCustomEvent<HTMLScCompactAddressElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCompactAddressElement: {
        prototype: HTMLScCompactAddressElement;
        new (): HTMLScCompactAddressElement;
    };
    interface HTMLScConditionalFormElement extends Components.ScConditionalForm, HTMLStencilElement {
    }
    var HTMLScConditionalFormElement: {
        prototype: HTMLScConditionalFormElement;
        new (): HTMLScConditionalFormElement;
    };
    interface HTMLScConsumerElementEventMap {
        "mountConsumer": any;
    }
    interface HTMLScConsumerElement extends Components.ScConsumer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScConsumerElementEventMap>(type: K, listener: (this: HTMLScConsumerElement, ev: ScConsumerCustomEvent<HTMLScConsumerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScConsumerElementEventMap>(type: K, listener: (this: HTMLScConsumerElement, ev: ScConsumerCustomEvent<HTMLScConsumerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScConsumerElement: {
        prototype: HTMLScConsumerElement;
        new (): HTMLScConsumerElement;
    };
    interface HTMLScCouponFormElementEventMap {
        "scApplyCoupon": string;
    }
    interface HTMLScCouponFormElement extends Components.ScCouponForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCouponFormElementEventMap>(type: K, listener: (this: HTMLScCouponFormElement, ev: ScCouponFormCustomEvent<HTMLScCouponFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCouponFormElementEventMap>(type: K, listener: (this: HTMLScCouponFormElement, ev: ScCouponFormCustomEvent<HTMLScCouponFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCouponFormElement: {
        prototype: HTMLScCouponFormElement;
        new (): HTMLScCouponFormElement;
    };
    interface HTMLScCustomOrderPriceInputElementEventMap {
        "scUpdateLineItem": LineItemData1;
    }
    interface HTMLScCustomOrderPriceInputElement extends Components.ScCustomOrderPriceInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCustomOrderPriceInputElementEventMap>(type: K, listener: (this: HTMLScCustomOrderPriceInputElement, ev: ScCustomOrderPriceInputCustomEvent<HTMLScCustomOrderPriceInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCustomOrderPriceInputElementEventMap>(type: K, listener: (this: HTMLScCustomOrderPriceInputElement, ev: ScCustomOrderPriceInputCustomEvent<HTMLScCustomOrderPriceInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCustomOrderPriceInputElement: {
        prototype: HTMLScCustomOrderPriceInputElement;
        new (): HTMLScCustomOrderPriceInputElement;
    };
    interface HTMLScCustomerDetailsElement extends Components.ScCustomerDetails, HTMLStencilElement {
    }
    var HTMLScCustomerDetailsElement: {
        prototype: HTMLScCustomerDetailsElement;
        new (): HTMLScCustomerDetailsElement;
    };
    interface HTMLScCustomerEditElement extends Components.ScCustomerEdit, HTMLStencilElement {
    }
    var HTMLScCustomerEditElement: {
        prototype: HTMLScCustomerEditElement;
        new (): HTMLScCustomerEditElement;
    };
    interface HTMLScCustomerEmailElementEventMap {
        "scChange": void;
        "scClear": void;
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
        "scUpdateOrderState": Checkout;
        "scUpdateAbandonedCart": boolean;
        "scLoginPrompt": void;
    }
    interface HTMLScCustomerEmailElement extends Components.ScCustomerEmail, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCustomerEmailElementEventMap>(type: K, listener: (this: HTMLScCustomerEmailElement, ev: ScCustomerEmailCustomEvent<HTMLScCustomerEmailElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCustomerEmailElementEventMap>(type: K, listener: (this: HTMLScCustomerEmailElement, ev: ScCustomerEmailCustomEvent<HTMLScCustomerEmailElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCustomerEmailElement: {
        prototype: HTMLScCustomerEmailElement;
        new (): HTMLScCustomerEmailElement;
    };
    interface HTMLScCustomerFirstnameElementEventMap {
        "scChange": void;
        "scUpdateOrderState": Partial<Checkout>;
        "scClear": void;
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
        "scUpdateCustomer": { email: string };
    }
    interface HTMLScCustomerFirstnameElement extends Components.ScCustomerFirstname, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCustomerFirstnameElementEventMap>(type: K, listener: (this: HTMLScCustomerFirstnameElement, ev: ScCustomerFirstnameCustomEvent<HTMLScCustomerFirstnameElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCustomerFirstnameElementEventMap>(type: K, listener: (this: HTMLScCustomerFirstnameElement, ev: ScCustomerFirstnameCustomEvent<HTMLScCustomerFirstnameElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCustomerFirstnameElement: {
        prototype: HTMLScCustomerFirstnameElement;
        new (): HTMLScCustomerFirstnameElement;
    };
    interface HTMLScCustomerLastnameElementEventMap {
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScCustomerLastnameElement extends Components.ScCustomerLastname, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCustomerLastnameElementEventMap>(type: K, listener: (this: HTMLScCustomerLastnameElement, ev: ScCustomerLastnameCustomEvent<HTMLScCustomerLastnameElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCustomerLastnameElementEventMap>(type: K, listener: (this: HTMLScCustomerLastnameElement, ev: ScCustomerLastnameCustomEvent<HTMLScCustomerLastnameElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCustomerLastnameElement: {
        prototype: HTMLScCustomerLastnameElement;
        new (): HTMLScCustomerLastnameElement;
    };
    interface HTMLScCustomerNameElementEventMap {
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScCustomerNameElement extends Components.ScCustomerName, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCustomerNameElementEventMap>(type: K, listener: (this: HTMLScCustomerNameElement, ev: ScCustomerNameCustomEvent<HTMLScCustomerNameElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCustomerNameElementEventMap>(type: K, listener: (this: HTMLScCustomerNameElement, ev: ScCustomerNameCustomEvent<HTMLScCustomerNameElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCustomerNameElement: {
        prototype: HTMLScCustomerNameElement;
        new (): HTMLScCustomerNameElement;
    };
    interface HTMLScCustomerPhoneElementEventMap {
        "scChange": void;
        "scClear": void;
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScCustomerPhoneElement extends Components.ScCustomerPhone, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScCustomerPhoneElementEventMap>(type: K, listener: (this: HTMLScCustomerPhoneElement, ev: ScCustomerPhoneCustomEvent<HTMLScCustomerPhoneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScCustomerPhoneElementEventMap>(type: K, listener: (this: HTMLScCustomerPhoneElement, ev: ScCustomerPhoneCustomEvent<HTMLScCustomerPhoneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScCustomerPhoneElement: {
        prototype: HTMLScCustomerPhoneElement;
        new (): HTMLScCustomerPhoneElement;
    };
    interface HTMLScDashboardCustomerDetailsElement extends Components.ScDashboardCustomerDetails, HTMLStencilElement {
    }
    var HTMLScDashboardCustomerDetailsElement: {
        prototype: HTMLScDashboardCustomerDetailsElement;
        new (): HTMLScDashboardCustomerDetailsElement;
    };
    interface HTMLScDashboardDownloadsListElement extends Components.ScDashboardDownloadsList, HTMLStencilElement {
    }
    var HTMLScDashboardDownloadsListElement: {
        prototype: HTMLScDashboardDownloadsListElement;
        new (): HTMLScDashboardDownloadsListElement;
    };
    interface HTMLScDashboardModuleElement extends Components.ScDashboardModule, HTMLStencilElement {
    }
    var HTMLScDashboardModuleElement: {
        prototype: HTMLScDashboardModuleElement;
        new (): HTMLScDashboardModuleElement;
    };
    interface HTMLScDialogElementEventMap {
        "scRequestClose": 'close-button' | 'keyboard' | 'overlay';
        "scShow": void;
        "scAfterShow": void;
        "scHide": void;
        "scAfterHide": void;
        "scInitialFocus": void;
    }
    interface HTMLScDialogElement extends Components.ScDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScDialogElementEventMap>(type: K, listener: (this: HTMLScDialogElement, ev: ScDialogCustomEvent<HTMLScDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScDialogElementEventMap>(type: K, listener: (this: HTMLScDialogElement, ev: ScDialogCustomEvent<HTMLScDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScDialogElement: {
        prototype: HTMLScDialogElement;
        new (): HTMLScDialogElement;
    };
    interface HTMLScDividerElement extends Components.ScDivider, HTMLStencilElement {
    }
    var HTMLScDividerElement: {
        prototype: HTMLScDividerElement;
        new (): HTMLScDividerElement;
    };
    interface HTMLScDonationChoicesElementEventMap {
        "scRemoveLineItem": LineItemData1;
        "scUpdateLineItem": LineItemData1;
        "scAddLineItem": LineItemData1;
    }
    interface HTMLScDonationChoicesElement extends Components.ScDonationChoices, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScDonationChoicesElementEventMap>(type: K, listener: (this: HTMLScDonationChoicesElement, ev: ScDonationChoicesCustomEvent<HTMLScDonationChoicesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScDonationChoicesElementEventMap>(type: K, listener: (this: HTMLScDonationChoicesElement, ev: ScDonationChoicesCustomEvent<HTMLScDonationChoicesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScDonationChoicesElement: {
        prototype: HTMLScDonationChoicesElement;
        new (): HTMLScDonationChoicesElement;
    };
    interface HTMLScDownloadsListElement extends Components.ScDownloadsList, HTMLStencilElement {
    }
    var HTMLScDownloadsListElement: {
        prototype: HTMLScDownloadsListElement;
        new (): HTMLScDownloadsListElement;
    };
    interface HTMLScDrawerElementEventMap {
        "scInitialFocus": void;
        "scRequestClose": 'close-button' | 'keyboard' | 'overlay' | 'method';
        "scShow": void;
        "scHide": void;
        "scAfterShow": void;
        "scAfterHide": void;
    }
    interface HTMLScDrawerElement extends Components.ScDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScDrawerElementEventMap>(type: K, listener: (this: HTMLScDrawerElement, ev: ScDrawerCustomEvent<HTMLScDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScDrawerElementEventMap>(type: K, listener: (this: HTMLScDrawerElement, ev: ScDrawerCustomEvent<HTMLScDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScDrawerElement: {
        prototype: HTMLScDrawerElement;
        new (): HTMLScDrawerElement;
    };
    interface HTMLScDropdownElementEventMap {
        "scShow": void;
        "scHide": void;
    }
    interface HTMLScDropdownElement extends Components.ScDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScDropdownElementEventMap>(type: K, listener: (this: HTMLScDropdownElement, ev: ScDropdownCustomEvent<HTMLScDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScDropdownElementEventMap>(type: K, listener: (this: HTMLScDropdownElement, ev: ScDropdownCustomEvent<HTMLScDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScDropdownElement: {
        prototype: HTMLScDropdownElement;
        new (): HTMLScDropdownElement;
    };
    interface HTMLScEmptyElement extends Components.ScEmpty, HTMLStencilElement {
    }
    var HTMLScEmptyElement: {
        prototype: HTMLScEmptyElement;
        new (): HTMLScEmptyElement;
    };
    interface HTMLScErrorElementEventMap {
        "scUpdateError": ResponseError;
    }
    interface HTMLScErrorElement extends Components.ScError, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScErrorElementEventMap>(type: K, listener: (this: HTMLScErrorElement, ev: ScErrorCustomEvent<HTMLScErrorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScErrorElementEventMap>(type: K, listener: (this: HTMLScErrorElement, ev: ScErrorCustomEvent<HTMLScErrorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScErrorElement: {
        prototype: HTMLScErrorElement;
        new (): HTMLScErrorElement;
    };
    interface HTMLScExpressPaymentElement extends Components.ScExpressPayment, HTMLStencilElement {
    }
    var HTMLScExpressPaymentElement: {
        prototype: HTMLScExpressPaymentElement;
        new (): HTMLScExpressPaymentElement;
    };
    interface HTMLScFeatureDemoBannerElement extends Components.ScFeatureDemoBanner, HTMLStencilElement {
    }
    var HTMLScFeatureDemoBannerElement: {
        prototype: HTMLScFeatureDemoBannerElement;
        new (): HTMLScFeatureDemoBannerElement;
    };
    interface HTMLScFlexElement extends Components.ScFlex, HTMLStencilElement {
    }
    var HTMLScFlexElement: {
        prototype: HTMLScFlexElement;
        new (): HTMLScFlexElement;
    };
    interface HTMLScFormElementEventMap {
        "scSubmit": void;
        "scFormSubmit": void;
        "scFormChange": Object;
    }
    interface HTMLScFormElement extends Components.ScForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScFormElementEventMap>(type: K, listener: (this: HTMLScFormElement, ev: ScFormCustomEvent<HTMLScFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScFormElementEventMap>(type: K, listener: (this: HTMLScFormElement, ev: ScFormCustomEvent<HTMLScFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScFormElement: {
        prototype: HTMLScFormElement;
        new (): HTMLScFormElement;
    };
    interface HTMLScFormComponentsValidatorElement extends Components.ScFormComponentsValidator, HTMLStencilElement {
    }
    var HTMLScFormComponentsValidatorElement: {
        prototype: HTMLScFormComponentsValidatorElement;
        new (): HTMLScFormComponentsValidatorElement;
    };
    interface HTMLScFormControlElement extends Components.ScFormControl, HTMLStencilElement {
    }
    var HTMLScFormControlElement: {
        prototype: HTMLScFormControlElement;
        new (): HTMLScFormControlElement;
    };
    /**
     * This component checks to make sure there is an error component
     * and adds one if it's missing.
     */
    interface HTMLScFormErrorProviderElement extends Components.ScFormErrorProvider, HTMLStencilElement {
    }
    var HTMLScFormErrorProviderElement: {
        prototype: HTMLScFormErrorProviderElement;
        new (): HTMLScFormErrorProviderElement;
    };
    interface HTMLScFormRowElement extends Components.ScFormRow, HTMLStencilElement {
    }
    var HTMLScFormRowElement: {
        prototype: HTMLScFormRowElement;
        new (): HTMLScFormRowElement;
    };
    interface HTMLScFormStateProviderElementEventMap {
        "scSetCheckoutFormState": FormState;
    }
    /**
     * This component listens for a confirmed event and redirects to the success url.
     */
    interface HTMLScFormStateProviderElement extends Components.ScFormStateProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScFormStateProviderElementEventMap>(type: K, listener: (this: HTMLScFormStateProviderElement, ev: ScFormStateProviderCustomEvent<HTMLScFormStateProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScFormStateProviderElementEventMap>(type: K, listener: (this: HTMLScFormStateProviderElement, ev: ScFormStateProviderCustomEvent<HTMLScFormStateProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScFormStateProviderElement: {
        prototype: HTMLScFormStateProviderElement;
        new (): HTMLScFormStateProviderElement;
    };
    interface HTMLScFormatBytesElement extends Components.ScFormatBytes, HTMLStencilElement {
    }
    var HTMLScFormatBytesElement: {
        prototype: HTMLScFormatBytesElement;
        new (): HTMLScFormatBytesElement;
    };
    interface HTMLScFormatIntervalElement extends Components.ScFormatInterval, HTMLStencilElement {
    }
    var HTMLScFormatIntervalElement: {
        prototype: HTMLScFormatIntervalElement;
        new (): HTMLScFormatIntervalElement;
    };
    interface HTMLScFormatNumberElement extends Components.ScFormatNumber, HTMLStencilElement {
    }
    var HTMLScFormatNumberElement: {
        prototype: HTMLScFormatNumberElement;
        new (): HTMLScFormatNumberElement;
    };
    interface HTMLScFulfillmentShippingStatusBadgeElement extends Components.ScFulfillmentShippingStatusBadge, HTMLStencilElement {
    }
    var HTMLScFulfillmentShippingStatusBadgeElement: {
        prototype: HTMLScFulfillmentShippingStatusBadgeElement;
        new (): HTMLScFulfillmentShippingStatusBadgeElement;
    };
    interface HTMLScFulfillmentsElement extends Components.ScFulfillments, HTMLStencilElement {
    }
    var HTMLScFulfillmentsElement: {
        prototype: HTMLScFulfillmentsElement;
        new (): HTMLScFulfillmentsElement;
    };
    interface HTMLScHeadingElement extends Components.ScHeading, HTMLStencilElement {
    }
    var HTMLScHeadingElement: {
        prototype: HTMLScHeadingElement;
        new (): HTMLScHeadingElement;
    };
    interface HTMLScIconElementEventMap {
        "scLoad": void;
    }
    interface HTMLScIconElement extends Components.ScIcon, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScIconElementEventMap>(type: K, listener: (this: HTMLScIconElement, ev: ScIconCustomEvent<HTMLScIconElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScIconElementEventMap>(type: K, listener: (this: HTMLScIconElement, ev: ScIconCustomEvent<HTMLScIconElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScIconElement: {
        prototype: HTMLScIconElement;
        new (): HTMLScIconElement;
    };
    interface HTMLScImageSliderElement extends Components.ScImageSlider, HTMLStencilElement {
    }
    var HTMLScImageSliderElement: {
        prototype: HTMLScImageSliderElement;
        new (): HTMLScImageSliderElement;
    };
    interface HTMLScInputElementEventMap {
        "scChange": void;
        "scClear": void;
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScInputElement extends Components.ScInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScInputElementEventMap>(type: K, listener: (this: HTMLScInputElement, ev: ScInputCustomEvent<HTMLScInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScInputElementEventMap>(type: K, listener: (this: HTMLScInputElement, ev: ScInputCustomEvent<HTMLScInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScInputElement: {
        prototype: HTMLScInputElement;
        new (): HTMLScInputElement;
    };
    interface HTMLScInvoiceDetailsElement extends Components.ScInvoiceDetails, HTMLStencilElement {
    }
    var HTMLScInvoiceDetailsElement: {
        prototype: HTMLScInvoiceDetailsElement;
        new (): HTMLScInvoiceDetailsElement;
    };
    interface HTMLScInvoiceMemoElement extends Components.ScInvoiceMemo, HTMLStencilElement {
    }
    var HTMLScInvoiceMemoElement: {
        prototype: HTMLScInvoiceMemoElement;
        new (): HTMLScInvoiceMemoElement;
    };
    interface HTMLScInvoiceStatusBadgeElement extends Components.ScInvoiceStatusBadge, HTMLStencilElement {
    }
    var HTMLScInvoiceStatusBadgeElement: {
        prototype: HTMLScInvoiceStatusBadgeElement;
        new (): HTMLScInvoiceStatusBadgeElement;
    };
    interface HTMLScInvoicesListElement extends Components.ScInvoicesList, HTMLStencilElement {
    }
    var HTMLScInvoicesListElement: {
        prototype: HTMLScInvoicesListElement;
        new (): HTMLScInvoicesListElement;
    };
    interface HTMLScLicenseElement extends Components.ScLicense, HTMLStencilElement {
    }
    var HTMLScLicenseElement: {
        prototype: HTMLScLicenseElement;
        new (): HTMLScLicenseElement;
    };
    interface HTMLScLicensesListElement extends Components.ScLicensesList, HTMLStencilElement {
    }
    var HTMLScLicensesListElement: {
        prototype: HTMLScLicensesListElement;
        new (): HTMLScLicensesListElement;
    };
    interface HTMLScLineItemElement extends Components.ScLineItem, HTMLStencilElement {
    }
    var HTMLScLineItemElement: {
        prototype: HTMLScLineItemElement;
        new (): HTMLScLineItemElement;
    };
    interface HTMLScLineItemBumpElement extends Components.ScLineItemBump, HTMLStencilElement {
    }
    var HTMLScLineItemBumpElement: {
        prototype: HTMLScLineItemBumpElement;
        new (): HTMLScLineItemBumpElement;
    };
    interface HTMLScLineItemInvoiceDueDateElement extends Components.ScLineItemInvoiceDueDate, HTMLStencilElement {
    }
    var HTMLScLineItemInvoiceDueDateElement: {
        prototype: HTMLScLineItemInvoiceDueDateElement;
        new (): HTMLScLineItemInvoiceDueDateElement;
    };
    interface HTMLScLineItemInvoiceNumberElement extends Components.ScLineItemInvoiceNumber, HTMLStencilElement {
    }
    var HTMLScLineItemInvoiceNumberElement: {
        prototype: HTMLScLineItemInvoiceNumberElement;
        new (): HTMLScLineItemInvoiceNumberElement;
    };
    interface HTMLScLineItemInvoiceReceiptDownloadElement extends Components.ScLineItemInvoiceReceiptDownload, HTMLStencilElement {
    }
    var HTMLScLineItemInvoiceReceiptDownloadElement: {
        prototype: HTMLScLineItemInvoiceReceiptDownloadElement;
        new (): HTMLScLineItemInvoiceReceiptDownloadElement;
    };
    interface HTMLScLineItemShippingElement extends Components.ScLineItemShipping, HTMLStencilElement {
    }
    var HTMLScLineItemShippingElement: {
        prototype: HTMLScLineItemShippingElement;
        new (): HTMLScLineItemShippingElement;
    };
    interface HTMLScLineItemTaxElement extends Components.ScLineItemTax, HTMLStencilElement {
    }
    var HTMLScLineItemTaxElement: {
        prototype: HTMLScLineItemTaxElement;
        new (): HTMLScLineItemTaxElement;
    };
    interface HTMLScLineItemTotalElement extends Components.ScLineItemTotal, HTMLStencilElement {
    }
    var HTMLScLineItemTotalElement: {
        prototype: HTMLScLineItemTotalElement;
        new (): HTMLScLineItemTotalElement;
    };
    interface HTMLScLineItemTrialElement extends Components.ScLineItemTrial, HTMLStencilElement {
    }
    var HTMLScLineItemTrialElement: {
        prototype: HTMLScLineItemTrialElement;
        new (): HTMLScLineItemTrialElement;
    };
    interface HTMLScLineItemsElement extends Components.ScLineItems, HTMLStencilElement {
    }
    var HTMLScLineItemsElement: {
        prototype: HTMLScLineItemsElement;
        new (): HTMLScLineItemsElement;
    };
    interface HTMLScLineItemsProviderElementEventMap {
        "scUpdateLineItems": Array<LineItemData1>;
    }
    interface HTMLScLineItemsProviderElement extends Components.ScLineItemsProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScLineItemsProviderElementEventMap>(type: K, listener: (this: HTMLScLineItemsProviderElement, ev: ScLineItemsProviderCustomEvent<HTMLScLineItemsProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScLineItemsProviderElementEventMap>(type: K, listener: (this: HTMLScLineItemsProviderElement, ev: ScLineItemsProviderCustomEvent<HTMLScLineItemsProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScLineItemsProviderElement: {
        prototype: HTMLScLineItemsProviderElement;
        new (): HTMLScLineItemsProviderElement;
    };
    interface HTMLScLoginFormElement extends Components.ScLoginForm, HTMLStencilElement {
    }
    var HTMLScLoginFormElement: {
        prototype: HTMLScLoginFormElement;
        new (): HTMLScLoginFormElement;
    };
    interface HTMLScLoginProviderElementEventMap {
        "scSetLoggedIn": boolean;
        "scSetCustomer": { email: string; name?: string };
    }
    interface HTMLScLoginProviderElement extends Components.ScLoginProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScLoginProviderElementEventMap>(type: K, listener: (this: HTMLScLoginProviderElement, ev: ScLoginProviderCustomEvent<HTMLScLoginProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScLoginProviderElementEventMap>(type: K, listener: (this: HTMLScLoginProviderElement, ev: ScLoginProviderCustomEvent<HTMLScLoginProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScLoginProviderElement: {
        prototype: HTMLScLoginProviderElement;
        new (): HTMLScLoginProviderElement;
    };
    interface HTMLScManualPaymentMethodElement extends Components.ScManualPaymentMethod, HTMLStencilElement {
    }
    var HTMLScManualPaymentMethodElement: {
        prototype: HTMLScManualPaymentMethodElement;
        new (): HTMLScManualPaymentMethodElement;
    };
    interface HTMLScMenuElementEventMap {
        "scSelect": { item: HTMLScMenuItemElement };
    }
    interface HTMLScMenuElement extends Components.ScMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScMenuElementEventMap>(type: K, listener: (this: HTMLScMenuElement, ev: ScMenuCustomEvent<HTMLScMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScMenuElementEventMap>(type: K, listener: (this: HTMLScMenuElement, ev: ScMenuCustomEvent<HTMLScMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScMenuElement: {
        prototype: HTMLScMenuElement;
        new (): HTMLScMenuElement;
    };
    interface HTMLScMenuDividerElement extends Components.ScMenuDivider, HTMLStencilElement {
    }
    var HTMLScMenuDividerElement: {
        prototype: HTMLScMenuDividerElement;
        new (): HTMLScMenuDividerElement;
    };
    interface HTMLScMenuItemElement extends Components.ScMenuItem, HTMLStencilElement {
    }
    var HTMLScMenuItemElement: {
        prototype: HTMLScMenuItemElement;
        new (): HTMLScMenuItemElement;
    };
    interface HTMLScMenuLabelElement extends Components.ScMenuLabel, HTMLStencilElement {
    }
    var HTMLScMenuLabelElement: {
        prototype: HTMLScMenuLabelElement;
        new (): HTMLScMenuLabelElement;
    };
    interface HTMLScMollieAddMethodElement extends Components.ScMollieAddMethod, HTMLStencilElement {
    }
    var HTMLScMollieAddMethodElement: {
        prototype: HTMLScMollieAddMethodElement;
        new (): HTMLScMollieAddMethodElement;
    };
    interface HTMLScOrderElement extends Components.ScOrder, HTMLStencilElement {
    }
    var HTMLScOrderElement: {
        prototype: HTMLScOrderElement;
        new (): HTMLScOrderElement;
    };
    interface HTMLScOrderBillingAddressElement extends Components.ScOrderBillingAddress, HTMLStencilElement {
    }
    var HTMLScOrderBillingAddressElement: {
        prototype: HTMLScOrderBillingAddressElement;
        new (): HTMLScOrderBillingAddressElement;
    };
    interface HTMLScOrderBumpElement extends Components.ScOrderBump, HTMLStencilElement {
    }
    var HTMLScOrderBumpElement: {
        prototype: HTMLScOrderBumpElement;
        new (): HTMLScOrderBumpElement;
    };
    interface HTMLScOrderBumpsElement extends Components.ScOrderBumps, HTMLStencilElement {
    }
    var HTMLScOrderBumpsElement: {
        prototype: HTMLScOrderBumpsElement;
        new (): HTMLScOrderBumpsElement;
    };
    interface HTMLScOrderConfirmComponentsValidatorElement extends Components.ScOrderConfirmComponentsValidator, HTMLStencilElement {
    }
    var HTMLScOrderConfirmComponentsValidatorElement: {
        prototype: HTMLScOrderConfirmComponentsValidatorElement;
        new (): HTMLScOrderConfirmComponentsValidatorElement;
    };
    interface HTMLScOrderConfirmProviderElementEventMap {
        "scOrderPaid": Checkout;
        "scSetState": string;
    }
    /**
     * This component listens to the order status
     * and confirms the order when payment is successful.
     */
    interface HTMLScOrderConfirmProviderElement extends Components.ScOrderConfirmProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScOrderConfirmProviderElementEventMap>(type: K, listener: (this: HTMLScOrderConfirmProviderElement, ev: ScOrderConfirmProviderCustomEvent<HTMLScOrderConfirmProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScOrderConfirmProviderElementEventMap>(type: K, listener: (this: HTMLScOrderConfirmProviderElement, ev: ScOrderConfirmProviderCustomEvent<HTMLScOrderConfirmProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScOrderConfirmProviderElement: {
        prototype: HTMLScOrderConfirmProviderElement;
        new (): HTMLScOrderConfirmProviderElement;
    };
    interface HTMLScOrderConfirmationElement extends Components.ScOrderConfirmation, HTMLStencilElement {
    }
    var HTMLScOrderConfirmationElement: {
        prototype: HTMLScOrderConfirmationElement;
        new (): HTMLScOrderConfirmationElement;
    };
    interface HTMLScOrderConfirmationCustomerElement extends Components.ScOrderConfirmationCustomer, HTMLStencilElement {
    }
    var HTMLScOrderConfirmationCustomerElement: {
        prototype: HTMLScOrderConfirmationCustomerElement;
        new (): HTMLScOrderConfirmationCustomerElement;
    };
    interface HTMLScOrderConfirmationDetailsElement extends Components.ScOrderConfirmationDetails, HTMLStencilElement {
    }
    var HTMLScOrderConfirmationDetailsElement: {
        prototype: HTMLScOrderConfirmationDetailsElement;
        new (): HTMLScOrderConfirmationDetailsElement;
    };
    interface HTMLScOrderConfirmationLineItemsElement extends Components.ScOrderConfirmationLineItems, HTMLStencilElement {
    }
    var HTMLScOrderConfirmationLineItemsElement: {
        prototype: HTMLScOrderConfirmationLineItemsElement;
        new (): HTMLScOrderConfirmationLineItemsElement;
    };
    interface HTMLScOrderConfirmationTotalsElement extends Components.ScOrderConfirmationTotals, HTMLStencilElement {
    }
    var HTMLScOrderConfirmationTotalsElement: {
        prototype: HTMLScOrderConfirmationTotalsElement;
        new (): HTMLScOrderConfirmationTotalsElement;
    };
    interface HTMLScOrderCouponFormElement extends Components.ScOrderCouponForm, HTMLStencilElement {
    }
    var HTMLScOrderCouponFormElement: {
        prototype: HTMLScOrderCouponFormElement;
        new (): HTMLScOrderCouponFormElement;
    };
    interface HTMLScOrderDetailElement extends Components.ScOrderDetail, HTMLStencilElement {
    }
    var HTMLScOrderDetailElement: {
        prototype: HTMLScOrderDetailElement;
        new (): HTMLScOrderDetailElement;
    };
    interface HTMLScOrderFulfillmentBadgeElement extends Components.ScOrderFulfillmentBadge, HTMLStencilElement {
    }
    var HTMLScOrderFulfillmentBadgeElement: {
        prototype: HTMLScOrderFulfillmentBadgeElement;
        new (): HTMLScOrderFulfillmentBadgeElement;
    };
    interface HTMLScOrderManualInstructionsElement extends Components.ScOrderManualInstructions, HTMLStencilElement {
    }
    var HTMLScOrderManualInstructionsElement: {
        prototype: HTMLScOrderManualInstructionsElement;
        new (): HTMLScOrderManualInstructionsElement;
    };
    interface HTMLScOrderPasswordElement extends Components.ScOrderPassword, HTMLStencilElement {
    }
    var HTMLScOrderPasswordElement: {
        prototype: HTMLScOrderPasswordElement;
        new (): HTMLScOrderPasswordElement;
    };
    interface HTMLScOrderReturnBadgeElement extends Components.ScOrderReturnBadge, HTMLStencilElement {
    }
    var HTMLScOrderReturnBadgeElement: {
        prototype: HTMLScOrderReturnBadgeElement;
        new (): HTMLScOrderReturnBadgeElement;
    };
    interface HTMLScOrderShipmentBadgeElement extends Components.ScOrderShipmentBadge, HTMLStencilElement {
    }
    var HTMLScOrderShipmentBadgeElement: {
        prototype: HTMLScOrderShipmentBadgeElement;
        new (): HTMLScOrderShipmentBadgeElement;
    };
    interface HTMLScOrderShippingAddressElement extends Components.ScOrderShippingAddress, HTMLStencilElement {
    }
    var HTMLScOrderShippingAddressElement: {
        prototype: HTMLScOrderShippingAddressElement;
        new (): HTMLScOrderShippingAddressElement;
    };
    interface HTMLScOrderStatusBadgeElement extends Components.ScOrderStatusBadge, HTMLStencilElement {
    }
    var HTMLScOrderStatusBadgeElement: {
        prototype: HTMLScOrderStatusBadgeElement;
        new (): HTMLScOrderStatusBadgeElement;
    };
    interface HTMLScOrderSubmitElement extends Components.ScOrderSubmit, HTMLStencilElement {
    }
    var HTMLScOrderSubmitElement: {
        prototype: HTMLScOrderSubmitElement;
        new (): HTMLScOrderSubmitElement;
    };
    interface HTMLScOrderSummaryElementEventMap {
        "scShow": void;
        "scHide": void;
    }
    interface HTMLScOrderSummaryElement extends Components.ScOrderSummary, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScOrderSummaryElementEventMap>(type: K, listener: (this: HTMLScOrderSummaryElement, ev: ScOrderSummaryCustomEvent<HTMLScOrderSummaryElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScOrderSummaryElementEventMap>(type: K, listener: (this: HTMLScOrderSummaryElement, ev: ScOrderSummaryCustomEvent<HTMLScOrderSummaryElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScOrderSummaryElement: {
        prototype: HTMLScOrderSummaryElement;
        new (): HTMLScOrderSummaryElement;
    };
    interface HTMLScOrderTaxIdInputElement extends Components.ScOrderTaxIdInput, HTMLStencilElement {
    }
    var HTMLScOrderTaxIdInputElement: {
        prototype: HTMLScOrderTaxIdInputElement;
        new (): HTMLScOrderTaxIdInputElement;
    };
    interface HTMLScOrdersListElement extends Components.ScOrdersList, HTMLStencilElement {
    }
    var HTMLScOrdersListElement: {
        prototype: HTMLScOrdersListElement;
        new (): HTMLScOrdersListElement;
    };
    interface HTMLScPaginationElementEventMap {
        "scPrevPage": void;
        "scNextPage": void;
    }
    interface HTMLScPaginationElement extends Components.ScPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPaginationElementEventMap>(type: K, listener: (this: HTMLScPaginationElement, ev: ScPaginationCustomEvent<HTMLScPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPaginationElementEventMap>(type: K, listener: (this: HTMLScPaginationElement, ev: ScPaginationCustomEvent<HTMLScPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPaginationElement: {
        prototype: HTMLScPaginationElement;
        new (): HTMLScPaginationElement;
    };
    interface HTMLScPasswordElement extends Components.ScPassword, HTMLStencilElement {
    }
    var HTMLScPasswordElement: {
        prototype: HTMLScPasswordElement;
        new (): HTMLScPasswordElement;
    };
    interface HTMLScPasswordNagElement extends Components.ScPasswordNag, HTMLStencilElement {
    }
    var HTMLScPasswordNagElement: {
        prototype: HTMLScPasswordNagElement;
        new (): HTMLScPasswordNagElement;
    };
    interface HTMLScPaymentElement extends Components.ScPayment, HTMLStencilElement {
    }
    var HTMLScPaymentElement: {
        prototype: HTMLScPaymentElement;
        new (): HTMLScPaymentElement;
    };
    interface HTMLScPaymentMethodElement extends Components.ScPaymentMethod, HTMLStencilElement {
    }
    var HTMLScPaymentMethodElement: {
        prototype: HTMLScPaymentMethodElement;
        new (): HTMLScPaymentMethodElement;
    };
    interface HTMLScPaymentMethodChoiceElement extends Components.ScPaymentMethodChoice, HTMLStencilElement {
    }
    var HTMLScPaymentMethodChoiceElement: {
        prototype: HTMLScPaymentMethodChoiceElement;
        new (): HTMLScPaymentMethodChoiceElement;
    };
    interface HTMLScPaymentMethodDetailsElement extends Components.ScPaymentMethodDetails, HTMLStencilElement {
    }
    var HTMLScPaymentMethodDetailsElement: {
        prototype: HTMLScPaymentMethodDetailsElement;
        new (): HTMLScPaymentMethodDetailsElement;
    };
    interface HTMLScPaymentMethodsListElement extends Components.ScPaymentMethodsList, HTMLStencilElement {
    }
    var HTMLScPaymentMethodsListElement: {
        prototype: HTMLScPaymentMethodsListElement;
        new (): HTMLScPaymentMethodsListElement;
    };
    interface HTMLScPaymentSelectedElement extends Components.ScPaymentSelected, HTMLStencilElement {
    }
    var HTMLScPaymentSelectedElement: {
        prototype: HTMLScPaymentSelectedElement;
        new (): HTMLScPaymentSelectedElement;
    };
    interface HTMLScPaypalAddMethodElement extends Components.ScPaypalAddMethod, HTMLStencilElement {
    }
    var HTMLScPaypalAddMethodElement: {
        prototype: HTMLScPaypalAddMethodElement;
        new (): HTMLScPaypalAddMethodElement;
    };
    interface HTMLScPaypalButtonsElementEventMap {
        "scSetState": string;
        "scPaid": void;
    }
    interface HTMLScPaypalButtonsElement extends Components.ScPaypalButtons, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPaypalButtonsElementEventMap>(type: K, listener: (this: HTMLScPaypalButtonsElement, ev: ScPaypalButtonsCustomEvent<HTMLScPaypalButtonsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPaypalButtonsElementEventMap>(type: K, listener: (this: HTMLScPaypalButtonsElement, ev: ScPaypalButtonsCustomEvent<HTMLScPaypalButtonsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPaypalButtonsElement: {
        prototype: HTMLScPaypalButtonsElement;
        new (): HTMLScPaypalButtonsElement;
    };
    interface HTMLScPaystackAddMethodElement extends Components.ScPaystackAddMethod, HTMLStencilElement {
    }
    var HTMLScPaystackAddMethodElement: {
        prototype: HTMLScPaystackAddMethodElement;
        new (): HTMLScPaystackAddMethodElement;
    };
    interface HTMLScPhoneInputElementEventMap {
        "scChange": void;
        "scClear": void;
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScPhoneInputElement extends Components.ScPhoneInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPhoneInputElementEventMap>(type: K, listener: (this: HTMLScPhoneInputElement, ev: ScPhoneInputCustomEvent<HTMLScPhoneInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPhoneInputElementEventMap>(type: K, listener: (this: HTMLScPhoneInputElement, ev: ScPhoneInputCustomEvent<HTMLScPhoneInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPhoneInputElement: {
        prototype: HTMLScPhoneInputElement;
        new (): HTMLScPhoneInputElement;
    };
    interface HTMLScPillOptionElement extends Components.ScPillOption, HTMLStencilElement {
    }
    var HTMLScPillOptionElement: {
        prototype: HTMLScPillOptionElement;
        new (): HTMLScPillOptionElement;
    };
    interface HTMLScPremiumTagElement extends Components.ScPremiumTag, HTMLStencilElement {
    }
    var HTMLScPremiumTagElement: {
        prototype: HTMLScPremiumTagElement;
        new (): HTMLScPremiumTagElement;
    };
    /**
     * Internal dependencies.
     */
    interface HTMLScPriceElement extends Components.ScPrice, HTMLStencilElement {
    }
    var HTMLScPriceElement: {
        prototype: HTMLScPriceElement;
        new (): HTMLScPriceElement;
    };
    interface HTMLScPriceChoiceElementEventMap {
        "scUpdateLineItem": LineItemData1;
        "scRemoveLineItem": LineItemData1;
        "scAddEntities": any;
    }
    interface HTMLScPriceChoiceElement extends Components.ScPriceChoice, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPriceChoiceElementEventMap>(type: K, listener: (this: HTMLScPriceChoiceElement, ev: ScPriceChoiceCustomEvent<HTMLScPriceChoiceElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPriceChoiceElementEventMap>(type: K, listener: (this: HTMLScPriceChoiceElement, ev: ScPriceChoiceCustomEvent<HTMLScPriceChoiceElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPriceChoiceElement: {
        prototype: HTMLScPriceChoiceElement;
        new (): HTMLScPriceChoiceElement;
    };
    interface HTMLScPriceChoiceContainerElementEventMap {
        "scChange": void;
    }
    interface HTMLScPriceChoiceContainerElement extends Components.ScPriceChoiceContainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPriceChoiceContainerElementEventMap>(type: K, listener: (this: HTMLScPriceChoiceContainerElement, ev: ScPriceChoiceContainerCustomEvent<HTMLScPriceChoiceContainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPriceChoiceContainerElementEventMap>(type: K, listener: (this: HTMLScPriceChoiceContainerElement, ev: ScPriceChoiceContainerCustomEvent<HTMLScPriceChoiceContainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPriceChoiceContainerElement: {
        prototype: HTMLScPriceChoiceContainerElement;
        new (): HTMLScPriceChoiceContainerElement;
    };
    interface HTMLScPriceChoicesElementEventMap {
        "scRemoveLineItem": LineItemData1;
        "scUpdateLineItem": LineItemData1;
    }
    interface HTMLScPriceChoicesElement extends Components.ScPriceChoices, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPriceChoicesElementEventMap>(type: K, listener: (this: HTMLScPriceChoicesElement, ev: ScPriceChoicesCustomEvent<HTMLScPriceChoicesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPriceChoicesElementEventMap>(type: K, listener: (this: HTMLScPriceChoicesElement, ev: ScPriceChoicesCustomEvent<HTMLScPriceChoicesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPriceChoicesElement: {
        prototype: HTMLScPriceChoicesElement;
        new (): HTMLScPriceChoicesElement;
    };
    interface HTMLScPriceInputElementEventMap {
        "scChange": void;
        "scInput": void;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScPriceInputElement extends Components.ScPriceInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScPriceInputElementEventMap>(type: K, listener: (this: HTMLScPriceInputElement, ev: ScPriceInputCustomEvent<HTMLScPriceInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScPriceInputElementEventMap>(type: K, listener: (this: HTMLScPriceInputElement, ev: ScPriceInputCustomEvent<HTMLScPriceInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScPriceInputElement: {
        prototype: HTMLScPriceInputElement;
        new (): HTMLScPriceInputElement;
    };
    interface HTMLScPriceRangeElement extends Components.ScPriceRange, HTMLStencilElement {
    }
    var HTMLScPriceRangeElement: {
        prototype: HTMLScPriceRangeElement;
        new (): HTMLScPriceRangeElement;
    };
    interface HTMLScProductBuyButtonElement extends Components.ScProductBuyButton, HTMLStencilElement {
    }
    var HTMLScProductBuyButtonElement: {
        prototype: HTMLScProductBuyButtonElement;
        new (): HTMLScProductBuyButtonElement;
    };
    interface HTMLScProductDonationAmountChoiceElement extends Components.ScProductDonationAmountChoice, HTMLStencilElement {
    }
    var HTMLScProductDonationAmountChoiceElement: {
        prototype: HTMLScProductDonationAmountChoiceElement;
        new (): HTMLScProductDonationAmountChoiceElement;
    };
    interface HTMLScProductDonationChoicesElement extends Components.ScProductDonationChoices, HTMLStencilElement {
    }
    var HTMLScProductDonationChoicesElement: {
        prototype: HTMLScProductDonationChoicesElement;
        new (): HTMLScProductDonationChoicesElement;
    };
    interface HTMLScProductDonationCustomAmountElement extends Components.ScProductDonationCustomAmount, HTMLStencilElement {
    }
    var HTMLScProductDonationCustomAmountElement: {
        prototype: HTMLScProductDonationCustomAmountElement;
        new (): HTMLScProductDonationCustomAmountElement;
    };
    interface HTMLScProductItemElement extends Components.ScProductItem, HTMLStencilElement {
    }
    var HTMLScProductItemElement: {
        prototype: HTMLScProductItemElement;
        new (): HTMLScProductItemElement;
    };
    interface HTMLScProductItemImageElement extends Components.ScProductItemImage, HTMLStencilElement {
    }
    var HTMLScProductItemImageElement: {
        prototype: HTMLScProductItemImageElement;
        new (): HTMLScProductItemImageElement;
    };
    interface HTMLScProductItemListElementEventMap {
        "scSearched": ProductsSearchedParams;
        "scProductsViewed": ProductsViewedParams;
    }
    interface HTMLScProductItemListElement extends Components.ScProductItemList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScProductItemListElementEventMap>(type: K, listener: (this: HTMLScProductItemListElement, ev: ScProductItemListCustomEvent<HTMLScProductItemListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScProductItemListElementEventMap>(type: K, listener: (this: HTMLScProductItemListElement, ev: ScProductItemListCustomEvent<HTMLScProductItemListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScProductItemListElement: {
        prototype: HTMLScProductItemListElement;
        new (): HTMLScProductItemListElement;
    };
    interface HTMLScProductItemPriceElement extends Components.ScProductItemPrice, HTMLStencilElement {
    }
    var HTMLScProductItemPriceElement: {
        prototype: HTMLScProductItemPriceElement;
        new (): HTMLScProductItemPriceElement;
    };
    interface HTMLScProductItemTitleElement extends Components.ScProductItemTitle, HTMLStencilElement {
    }
    var HTMLScProductItemTitleElement: {
        prototype: HTMLScProductItemTitleElement;
        new (): HTMLScProductItemTitleElement;
    };
    interface HTMLScProductLineItemElementEventMap {
        "scUpdateQuantity": number;
        "scRemove": void;
    }
    interface HTMLScProductLineItemElement extends Components.ScProductLineItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScProductLineItemElementEventMap>(type: K, listener: (this: HTMLScProductLineItemElement, ev: ScProductLineItemCustomEvent<HTMLScProductLineItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScProductLineItemElementEventMap>(type: K, listener: (this: HTMLScProductLineItemElement, ev: ScProductLineItemCustomEvent<HTMLScProductLineItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScProductLineItemElement: {
        prototype: HTMLScProductLineItemElement;
        new (): HTMLScProductLineItemElement;
    };
    interface HTMLScProductPillsVariantOptionElement extends Components.ScProductPillsVariantOption, HTMLStencilElement {
    }
    var HTMLScProductPillsVariantOptionElement: {
        prototype: HTMLScProductPillsVariantOptionElement;
        new (): HTMLScProductPillsVariantOptionElement;
    };
    interface HTMLScProductPriceElement extends Components.ScProductPrice, HTMLStencilElement {
    }
    var HTMLScProductPriceElement: {
        prototype: HTMLScProductPriceElement;
        new (): HTMLScProductPriceElement;
    };
    interface HTMLScProductPriceChoicesElement extends Components.ScProductPriceChoices, HTMLStencilElement {
    }
    var HTMLScProductPriceChoicesElement: {
        prototype: HTMLScProductPriceChoicesElement;
        new (): HTMLScProductPriceChoicesElement;
    };
    interface HTMLScProductPriceModalElement extends Components.ScProductPriceModal, HTMLStencilElement {
    }
    var HTMLScProductPriceModalElement: {
        prototype: HTMLScProductPriceModalElement;
        new (): HTMLScProductPriceModalElement;
    };
    interface HTMLScProductQuantityElement extends Components.ScProductQuantity, HTMLStencilElement {
    }
    var HTMLScProductQuantityElement: {
        prototype: HTMLScProductQuantityElement;
        new (): HTMLScProductQuantityElement;
    };
    interface HTMLScProductSelectedPriceElementEventMap {
        "scUpdateLineItem": LineItemData;
    }
    interface HTMLScProductSelectedPriceElement extends Components.ScProductSelectedPrice, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScProductSelectedPriceElementEventMap>(type: K, listener: (this: HTMLScProductSelectedPriceElement, ev: ScProductSelectedPriceCustomEvent<HTMLScProductSelectedPriceElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScProductSelectedPriceElementEventMap>(type: K, listener: (this: HTMLScProductSelectedPriceElement, ev: ScProductSelectedPriceCustomEvent<HTMLScProductSelectedPriceElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScProductSelectedPriceElement: {
        prototype: HTMLScProductSelectedPriceElement;
        new (): HTMLScProductSelectedPriceElement;
    };
    interface HTMLScProductTextElement extends Components.ScProductText, HTMLStencilElement {
    }
    var HTMLScProductTextElement: {
        prototype: HTMLScProductTextElement;
        new (): HTMLScProductTextElement;
    };
    interface HTMLScProseElement extends Components.ScProse, HTMLStencilElement {
    }
    var HTMLScProseElement: {
        prototype: HTMLScProseElement;
        new (): HTMLScProseElement;
    };
    interface HTMLScProviderElementEventMap {
        "mountConsumer": any;
    }
    interface HTMLScProviderElement extends Components.ScProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScProviderElementEventMap>(type: K, listener: (this: HTMLScProviderElement, ev: ScProviderCustomEvent<HTMLScProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScProviderElementEventMap>(type: K, listener: (this: HTMLScProviderElement, ev: ScProviderCustomEvent<HTMLScProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScProviderElement: {
        prototype: HTMLScProviderElement;
        new (): HTMLScProviderElement;
    };
    interface HTMLScProvisionalBannerElement extends Components.ScProvisionalBanner, HTMLStencilElement {
    }
    var HTMLScProvisionalBannerElement: {
        prototype: HTMLScProvisionalBannerElement;
        new (): HTMLScProvisionalBannerElement;
    };
    interface HTMLScPurchaseDownloadsListElement extends Components.ScPurchaseDownloadsList, HTMLStencilElement {
    }
    var HTMLScPurchaseDownloadsListElement: {
        prototype: HTMLScPurchaseDownloadsListElement;
        new (): HTMLScPurchaseDownloadsListElement;
    };
    interface HTMLScQuantitySelectElementEventMap {
        "scChange": number;
        "scInput": number;
        "scFocus": void;
        "scBlur": void;
    }
    interface HTMLScQuantitySelectElement extends Components.ScQuantitySelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScQuantitySelectElementEventMap>(type: K, listener: (this: HTMLScQuantitySelectElement, ev: ScQuantitySelectCustomEvent<HTMLScQuantitySelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScQuantitySelectElementEventMap>(type: K, listener: (this: HTMLScQuantitySelectElement, ev: ScQuantitySelectCustomEvent<HTMLScQuantitySelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScQuantitySelectElement: {
        prototype: HTMLScQuantitySelectElement;
        new (): HTMLScQuantitySelectElement;
    };
    interface HTMLScRadioElementEventMap {
        "scBlur": void;
        "scChange": void;
        "scFocus": void;
    }
    interface HTMLScRadioElement extends Components.ScRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScRadioElementEventMap>(type: K, listener: (this: HTMLScRadioElement, ev: ScRadioCustomEvent<HTMLScRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScRadioElementEventMap>(type: K, listener: (this: HTMLScRadioElement, ev: ScRadioCustomEvent<HTMLScRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScRadioElement: {
        prototype: HTMLScRadioElement;
        new (): HTMLScRadioElement;
    };
    interface HTMLScRadioGroupElementEventMap {
        "scChange": string;
    }
    interface HTMLScRadioGroupElement extends Components.ScRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScRadioGroupElementEventMap>(type: K, listener: (this: HTMLScRadioGroupElement, ev: ScRadioGroupCustomEvent<HTMLScRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScRadioGroupElementEventMap>(type: K, listener: (this: HTMLScRadioGroupElement, ev: ScRadioGroupCustomEvent<HTMLScRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScRadioGroupElement: {
        prototype: HTMLScRadioGroupElement;
        new (): HTMLScRadioGroupElement;
    };
    interface HTMLScRecurringPriceChoiceContainerElementEventMap {
        "scChange": string;
    }
    interface HTMLScRecurringPriceChoiceContainerElement extends Components.ScRecurringPriceChoiceContainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScRecurringPriceChoiceContainerElementEventMap>(type: K, listener: (this: HTMLScRecurringPriceChoiceContainerElement, ev: ScRecurringPriceChoiceContainerCustomEvent<HTMLScRecurringPriceChoiceContainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScRecurringPriceChoiceContainerElementEventMap>(type: K, listener: (this: HTMLScRecurringPriceChoiceContainerElement, ev: ScRecurringPriceChoiceContainerCustomEvent<HTMLScRecurringPriceChoiceContainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScRecurringPriceChoiceContainerElement: {
        prototype: HTMLScRecurringPriceChoiceContainerElement;
        new (): HTMLScRecurringPriceChoiceContainerElement;
    };
    interface HTMLScRichTextElementEventMap {
        "scChange": void;
        "scInput": void;
        "scBlur": void;
        "scFocus": void;
    }
    interface HTMLScRichTextElement extends Components.ScRichText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScRichTextElementEventMap>(type: K, listener: (this: HTMLScRichTextElement, ev: ScRichTextCustomEvent<HTMLScRichTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScRichTextElementEventMap>(type: K, listener: (this: HTMLScRichTextElement, ev: ScRichTextCustomEvent<HTMLScRichTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScRichTextElement: {
        prototype: HTMLScRichTextElement;
        new (): HTMLScRichTextElement;
    };
    interface HTMLScSecureNoticeElement extends Components.ScSecureNotice, HTMLStencilElement {
    }
    var HTMLScSecureNoticeElement: {
        prototype: HTMLScSecureNoticeElement;
        new (): HTMLScSecureNoticeElement;
    };
    interface HTMLScSelectElementEventMap {
        "scSearch": string;
        "scOpen": string;
        "scClose": string;
        "scBlur": void;
        "scFocus": void;
        "scChange": ChoiceItem;
        "scScrollEnd": void;
    }
    interface HTMLScSelectElement extends Components.ScSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScSelectElementEventMap>(type: K, listener: (this: HTMLScSelectElement, ev: ScSelectCustomEvent<HTMLScSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScSelectElementEventMap>(type: K, listener: (this: HTMLScSelectElement, ev: ScSelectCustomEvent<HTMLScSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScSelectElement: {
        prototype: HTMLScSelectElement;
        new (): HTMLScSelectElement;
    };
    interface HTMLScSessionProviderElementEventMap {
        "scUpdateOrderState": Checkout;
        "scUpdateDraftState": Checkout;
        "scPaid": void;
        "scSetState": FormStateSetter;
    }
    interface HTMLScSessionProviderElement extends Components.ScSessionProvider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScSessionProviderElementEventMap>(type: K, listener: (this: HTMLScSessionProviderElement, ev: ScSessionProviderCustomEvent<HTMLScSessionProviderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScSessionProviderElementEventMap>(type: K, listener: (this: HTMLScSessionProviderElement, ev: ScSessionProviderCustomEvent<HTMLScSessionProviderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScSessionProviderElement: {
        prototype: HTMLScSessionProviderElement;
        new (): HTMLScSessionProviderElement;
    };
    interface HTMLScShippingChoicesElement extends Components.ScShippingChoices, HTMLStencilElement {
    }
    var HTMLScShippingChoicesElement: {
        prototype: HTMLScShippingChoicesElement;
        new (): HTMLScShippingChoicesElement;
    };
    interface HTMLScSkeletonElement extends Components.ScSkeleton, HTMLStencilElement {
    }
    var HTMLScSkeletonElement: {
        prototype: HTMLScSkeletonElement;
        new (): HTMLScSkeletonElement;
    };
    interface HTMLScSpacingElement extends Components.ScSpacing, HTMLStencilElement {
    }
    var HTMLScSpacingElement: {
        prototype: HTMLScSpacingElement;
        new (): HTMLScSpacingElement;
    };
    interface HTMLScSpinnerElement extends Components.ScSpinner, HTMLStencilElement {
    }
    var HTMLScSpinnerElement: {
        prototype: HTMLScSpinnerElement;
        new (): HTMLScSpinnerElement;
    };
    interface HTMLScStackedListElement extends Components.ScStackedList, HTMLStencilElement {
    }
    var HTMLScStackedListElement: {
        prototype: HTMLScStackedListElement;
        new (): HTMLScStackedListElement;
    };
    interface HTMLScStackedListRowElement extends Components.ScStackedListRow, HTMLStencilElement {
    }
    var HTMLScStackedListRowElement: {
        prototype: HTMLScStackedListRowElement;
        new (): HTMLScStackedListRowElement;
    };
    interface HTMLScStripeAddMethodElement extends Components.ScStripeAddMethod, HTMLStencilElement {
    }
    var HTMLScStripeAddMethodElement: {
        prototype: HTMLScStripeAddMethodElement;
        new (): HTMLScStripeAddMethodElement;
    };
    interface HTMLScStripeElementElementEventMap {
        "scPaid": void;
        "scSetState": FormStateSetter;
        "scPaymentInfoAdded": PaymentInfoAddedParams;
    }
    interface HTMLScStripeElementElement extends Components.ScStripeElement, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScStripeElementElementEventMap>(type: K, listener: (this: HTMLScStripeElementElement, ev: ScStripeElementCustomEvent<HTMLScStripeElementElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScStripeElementElementEventMap>(type: K, listener: (this: HTMLScStripeElementElement, ev: ScStripeElementCustomEvent<HTMLScStripeElementElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScStripeElementElement: {
        prototype: HTMLScStripeElementElement;
        new (): HTMLScStripeElementElement;
    };
    interface HTMLScStripePaymentElementElementEventMap {
        "scPaid": void;
        "scSetState": FormStateSetter;
        "scPaymentInfoAdded": PaymentInfoAddedParams;
    }
    interface HTMLScStripePaymentElementElement extends Components.ScStripePaymentElement, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScStripePaymentElementElementEventMap>(type: K, listener: (this: HTMLScStripePaymentElementElement, ev: ScStripePaymentElementCustomEvent<HTMLScStripePaymentElementElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScStripePaymentElementElementEventMap>(type: K, listener: (this: HTMLScStripePaymentElementElement, ev: ScStripePaymentElementCustomEvent<HTMLScStripePaymentElementElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScStripePaymentElementElement: {
        prototype: HTMLScStripePaymentElementElement;
        new (): HTMLScStripePaymentElementElement;
    };
    interface HTMLScStripePaymentRequestElementEventMap {
        "scFormSubmit": any;
        "scPaid": void;
        "scPayError": any;
        "scSetState": string;
        "scPaymentRequestLoaded": boolean;
        "scUpdateOrderState": any;
    }
    interface HTMLScStripePaymentRequestElement extends Components.ScStripePaymentRequest, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScStripePaymentRequestElementEventMap>(type: K, listener: (this: HTMLScStripePaymentRequestElement, ev: ScStripePaymentRequestCustomEvent<HTMLScStripePaymentRequestElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScStripePaymentRequestElementEventMap>(type: K, listener: (this: HTMLScStripePaymentRequestElement, ev: ScStripePaymentRequestCustomEvent<HTMLScStripePaymentRequestElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScStripePaymentRequestElement: {
        prototype: HTMLScStripePaymentRequestElement;
        new (): HTMLScStripePaymentRequestElement;
    };
    interface HTMLScSubscriptionElement extends Components.ScSubscription, HTMLStencilElement {
    }
    var HTMLScSubscriptionElement: {
        prototype: HTMLScSubscriptionElement;
        new (): HTMLScSubscriptionElement;
    };
    interface HTMLScSubscriptionAdHocConfirmElement extends Components.ScSubscriptionAdHocConfirm, HTMLStencilElement {
    }
    var HTMLScSubscriptionAdHocConfirmElement: {
        prototype: HTMLScSubscriptionAdHocConfirmElement;
        new (): HTMLScSubscriptionAdHocConfirmElement;
    };
    interface HTMLScSubscriptionCancelElementEventMap {
        "scAbandon": void;
        "scCancelled": void;
    }
    interface HTMLScSubscriptionCancelElement extends Components.ScSubscriptionCancel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScSubscriptionCancelElementEventMap>(type: K, listener: (this: HTMLScSubscriptionCancelElement, ev: ScSubscriptionCancelCustomEvent<HTMLScSubscriptionCancelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScSubscriptionCancelElementEventMap>(type: K, listener: (this: HTMLScSubscriptionCancelElement, ev: ScSubscriptionCancelCustomEvent<HTMLScSubscriptionCancelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScSubscriptionCancelElement: {
        prototype: HTMLScSubscriptionCancelElement;
        new (): HTMLScSubscriptionCancelElement;
    };
    interface HTMLScSubscriptionDetailsElement extends Components.ScSubscriptionDetails, HTMLStencilElement {
    }
    var HTMLScSubscriptionDetailsElement: {
        prototype: HTMLScSubscriptionDetailsElement;
        new (): HTMLScSubscriptionDetailsElement;
    };
    interface HTMLScSubscriptionNextPaymentElement extends Components.ScSubscriptionNextPayment, HTMLStencilElement {
    }
    var HTMLScSubscriptionNextPaymentElement: {
        prototype: HTMLScSubscriptionNextPaymentElement;
        new (): HTMLScSubscriptionNextPaymentElement;
    };
    interface HTMLScSubscriptionPaymentElement extends Components.ScSubscriptionPayment, HTMLStencilElement {
    }
    var HTMLScSubscriptionPaymentElement: {
        prototype: HTMLScSubscriptionPaymentElement;
        new (): HTMLScSubscriptionPaymentElement;
    };
    interface HTMLScSubscriptionPaymentMethodElement extends Components.ScSubscriptionPaymentMethod, HTMLStencilElement {
    }
    var HTMLScSubscriptionPaymentMethodElement: {
        prototype: HTMLScSubscriptionPaymentMethodElement;
        new (): HTMLScSubscriptionPaymentMethodElement;
    };
    interface HTMLScSubscriptionReactivateElementEventMap {
        "scRequestClose": 'close-button' | 'keyboard' | 'overlay';
        "scRefresh": void;
    }
    interface HTMLScSubscriptionReactivateElement extends Components.ScSubscriptionReactivate, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScSubscriptionReactivateElementEventMap>(type: K, listener: (this: HTMLScSubscriptionReactivateElement, ev: ScSubscriptionReactivateCustomEvent<HTMLScSubscriptionReactivateElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScSubscriptionReactivateElementEventMap>(type: K, listener: (this: HTMLScSubscriptionReactivateElement, ev: ScSubscriptionReactivateCustomEvent<HTMLScSubscriptionReactivateElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScSubscriptionReactivateElement: {
        prototype: HTMLScSubscriptionReactivateElement;
        new (): HTMLScSubscriptionReactivateElement;
    };
    interface HTMLScSubscriptionStatusBadgeElement extends Components.ScSubscriptionStatusBadge, HTMLStencilElement {
    }
    var HTMLScSubscriptionStatusBadgeElement: {
        prototype: HTMLScSubscriptionStatusBadgeElement;
        new (): HTMLScSubscriptionStatusBadgeElement;
    };
    interface HTMLScSubscriptionSwitchElement extends Components.ScSubscriptionSwitch, HTMLStencilElement {
    }
    var HTMLScSubscriptionSwitchElement: {
        prototype: HTMLScSubscriptionSwitchElement;
        new (): HTMLScSubscriptionSwitchElement;
    };
    interface HTMLScSubscriptionVariationConfirmElement extends Components.ScSubscriptionVariationConfirm, HTMLStencilElement {
    }
    var HTMLScSubscriptionVariationConfirmElement: {
        prototype: HTMLScSubscriptionVariationConfirmElement;
        new (): HTMLScSubscriptionVariationConfirmElement;
    };
    interface HTMLScSubscriptionsListElement extends Components.ScSubscriptionsList, HTMLStencilElement {
    }
    var HTMLScSubscriptionsListElement: {
        prototype: HTMLScSubscriptionsListElement;
        new (): HTMLScSubscriptionsListElement;
    };
    interface HTMLScSummaryElementEventMap {
        "scShow": void;
        "scHide": void;
    }
    interface HTMLScSummaryElement extends Components.ScSummary, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScSummaryElementEventMap>(type: K, listener: (this: HTMLScSummaryElement, ev: ScSummaryCustomEvent<HTMLScSummaryElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScSummaryElementEventMap>(type: K, listener: (this: HTMLScSummaryElement, ev: ScSummaryCustomEvent<HTMLScSummaryElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScSummaryElement: {
        prototype: HTMLScSummaryElement;
        new (): HTMLScSummaryElement;
    };
    interface HTMLScSwitchElementEventMap {
        "scBlur": void;
        "scChange": void;
        "scFocus": void;
    }
    interface HTMLScSwitchElement extends Components.ScSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScSwitchElementEventMap>(type: K, listener: (this: HTMLScSwitchElement, ev: ScSwitchCustomEvent<HTMLScSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScSwitchElementEventMap>(type: K, listener: (this: HTMLScSwitchElement, ev: ScSwitchCustomEvent<HTMLScSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScSwitchElement: {
        prototype: HTMLScSwitchElement;
        new (): HTMLScSwitchElement;
    };
    interface HTMLScTabElementEventMap {
        "scClose": void;
    }
    interface HTMLScTabElement extends Components.ScTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScTabElementEventMap>(type: K, listener: (this: HTMLScTabElement, ev: ScTabCustomEvent<HTMLScTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScTabElementEventMap>(type: K, listener: (this: HTMLScTabElement, ev: ScTabCustomEvent<HTMLScTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScTabElement: {
        prototype: HTMLScTabElement;
        new (): HTMLScTabElement;
    };
    interface HTMLScTabGroupElementEventMap {
        "scTabHide": string;
        "scTabShow": string;
    }
    interface HTMLScTabGroupElement extends Components.ScTabGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScTabGroupElementEventMap>(type: K, listener: (this: HTMLScTabGroupElement, ev: ScTabGroupCustomEvent<HTMLScTabGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScTabGroupElementEventMap>(type: K, listener: (this: HTMLScTabGroupElement, ev: ScTabGroupCustomEvent<HTMLScTabGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScTabGroupElement: {
        prototype: HTMLScTabGroupElement;
        new (): HTMLScTabGroupElement;
    };
    interface HTMLScTabPanelElement extends Components.ScTabPanel, HTMLStencilElement {
    }
    var HTMLScTabPanelElement: {
        prototype: HTMLScTabPanelElement;
        new (): HTMLScTabPanelElement;
    };
    interface HTMLScTableElement extends Components.ScTable, HTMLStencilElement {
    }
    var HTMLScTableElement: {
        prototype: HTMLScTableElement;
        new (): HTMLScTableElement;
    };
    interface HTMLScTableCellElement extends Components.ScTableCell, HTMLStencilElement {
    }
    var HTMLScTableCellElement: {
        prototype: HTMLScTableCellElement;
        new (): HTMLScTableCellElement;
    };
    interface HTMLScTableHeadElement extends Components.ScTableHead, HTMLStencilElement {
    }
    var HTMLScTableHeadElement: {
        prototype: HTMLScTableHeadElement;
        new (): HTMLScTableHeadElement;
    };
    interface HTMLScTableRowElement extends Components.ScTableRow, HTMLStencilElement {
    }
    var HTMLScTableRowElement: {
        prototype: HTMLScTableRowElement;
        new (): HTMLScTableRowElement;
    };
    interface HTMLScTagElementEventMap {
        "scClear": ScTag;
    }
    interface HTMLScTagElement extends Components.ScTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScTagElementEventMap>(type: K, listener: (this: HTMLScTagElement, ev: ScTagCustomEvent<HTMLScTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScTagElementEventMap>(type: K, listener: (this: HTMLScTagElement, ev: ScTagCustomEvent<HTMLScTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScTagElement: {
        prototype: HTMLScTagElement;
        new (): HTMLScTagElement;
    };
    interface HTMLScTaxIdInputElementEventMap {
        "scChange": { number: string; number_type: string };
        "scInput": Partial<{ number: string; number_type: string }>;
        "scInputType": string;
        "scSetState": string;
    }
    interface HTMLScTaxIdInputElement extends Components.ScTaxIdInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScTaxIdInputElementEventMap>(type: K, listener: (this: HTMLScTaxIdInputElement, ev: ScTaxIdInputCustomEvent<HTMLScTaxIdInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScTaxIdInputElementEventMap>(type: K, listener: (this: HTMLScTaxIdInputElement, ev: ScTaxIdInputCustomEvent<HTMLScTaxIdInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScTaxIdInputElement: {
        prototype: HTMLScTaxIdInputElement;
        new (): HTMLScTaxIdInputElement;
    };
    interface HTMLScTextElement extends Components.ScText, HTMLStencilElement {
    }
    var HTMLScTextElement: {
        prototype: HTMLScTextElement;
        new (): HTMLScTextElement;
    };
    interface HTMLScTextareaElementEventMap {
        "scChange": void;
        "scInput": void;
        "scBlur": void;
        "scFocus": void;
    }
    interface HTMLScTextareaElement extends Components.ScTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScTextareaElementEventMap>(type: K, listener: (this: HTMLScTextareaElement, ev: ScTextareaCustomEvent<HTMLScTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScTextareaElementEventMap>(type: K, listener: (this: HTMLScTextareaElement, ev: ScTextareaCustomEvent<HTMLScTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScTextareaElement: {
        prototype: HTMLScTextareaElement;
        new (): HTMLScTextareaElement;
    };
    interface HTMLScToggleElementEventMap {
        "scShow": void;
        "scHide": void;
    }
    interface HTMLScToggleElement extends Components.ScToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScToggleElementEventMap>(type: K, listener: (this: HTMLScToggleElement, ev: ScToggleCustomEvent<HTMLScToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScToggleElementEventMap>(type: K, listener: (this: HTMLScToggleElement, ev: ScToggleCustomEvent<HTMLScToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScToggleElement: {
        prototype: HTMLScToggleElement;
        new (): HTMLScToggleElement;
    };
    interface HTMLScTogglesElement extends Components.ScToggles, HTMLStencilElement {
    }
    var HTMLScTogglesElement: {
        prototype: HTMLScTogglesElement;
        new (): HTMLScTogglesElement;
    };
    interface HTMLScTooltipElement extends Components.ScTooltip, HTMLStencilElement {
    }
    var HTMLScTooltipElement: {
        prototype: HTMLScTooltipElement;
        new (): HTMLScTooltipElement;
    };
    interface HTMLScTotalElement extends Components.ScTotal, HTMLStencilElement {
    }
    var HTMLScTotalElement: {
        prototype: HTMLScTotalElement;
        new (): HTMLScTotalElement;
    };
    interface HTMLScUpcomingInvoiceElement extends Components.ScUpcomingInvoice, HTMLStencilElement {
    }
    var HTMLScUpcomingInvoiceElement: {
        prototype: HTMLScUpcomingInvoiceElement;
        new (): HTMLScUpcomingInvoiceElement;
    };
    interface HTMLScUpgradeRequiredElement extends Components.ScUpgradeRequired, HTMLStencilElement {
    }
    var HTMLScUpgradeRequiredElement: {
        prototype: HTMLScUpgradeRequiredElement;
        new (): HTMLScUpgradeRequiredElement;
    };
    interface HTMLScUpsellElement extends Components.ScUpsell, HTMLStencilElement {
    }
    var HTMLScUpsellElement: {
        prototype: HTMLScUpsellElement;
        new (): HTMLScUpsellElement;
    };
    interface HTMLScUpsellCountdownTimerElement extends Components.ScUpsellCountdownTimer, HTMLStencilElement {
    }
    var HTMLScUpsellCountdownTimerElement: {
        prototype: HTMLScUpsellCountdownTimerElement;
        new (): HTMLScUpsellCountdownTimerElement;
    };
    interface HTMLScUpsellNoThanksButtonElement extends Components.ScUpsellNoThanksButton, HTMLStencilElement {
    }
    var HTMLScUpsellNoThanksButtonElement: {
        prototype: HTMLScUpsellNoThanksButtonElement;
        new (): HTMLScUpsellNoThanksButtonElement;
    };
    interface HTMLScUpsellSubmitButtonElement extends Components.ScUpsellSubmitButton, HTMLStencilElement {
    }
    var HTMLScUpsellSubmitButtonElement: {
        prototype: HTMLScUpsellSubmitButtonElement;
        new (): HTMLScUpsellSubmitButtonElement;
    };
    interface HTMLScUpsellTotalsElement extends Components.ScUpsellTotals, HTMLStencilElement {
    }
    var HTMLScUpsellTotalsElement: {
        prototype: HTMLScUpsellTotalsElement;
        new (): HTMLScUpsellTotalsElement;
    };
    interface HTMLScVisuallyHiddenElement extends Components.ScVisuallyHidden, HTMLStencilElement {
    }
    var HTMLScVisuallyHiddenElement: {
        prototype: HTMLScVisuallyHiddenElement;
        new (): HTMLScVisuallyHiddenElement;
    };
    interface HTMLScWordpressPasswordEditElement extends Components.ScWordpressPasswordEdit, HTMLStencilElement {
    }
    var HTMLScWordpressPasswordEditElement: {
        prototype: HTMLScWordpressPasswordEditElement;
        new (): HTMLScWordpressPasswordEditElement;
    };
    interface HTMLScWordpressUserElement extends Components.ScWordpressUser, HTMLStencilElement {
    }
    var HTMLScWordpressUserElement: {
        prototype: HTMLScWordpressUserElement;
        new (): HTMLScWordpressUserElement;
    };
    interface HTMLScWordpressUserEditElement extends Components.ScWordpressUserEdit, HTMLStencilElement {
    }
    var HTMLScWordpressUserEditElement: {
        prototype: HTMLScWordpressUserEditElement;
        new (): HTMLScWordpressUserEditElement;
    };
    interface HTMLElementTagNameMap {
        "sc-address": HTMLScAddressElement;
        "sc-alert": HTMLScAlertElement;
        "sc-avatar": HTMLScAvatarElement;
        "sc-badge-notice": HTMLScBadgeNoticeElement;
        "sc-block-ui": HTMLScBlockUiElement;
        "sc-breadcrumb": HTMLScBreadcrumbElement;
        "sc-breadcrumbs": HTMLScBreadcrumbsElement;
        "sc-button": HTMLScButtonElement;
        "sc-button-group": HTMLScButtonGroupElement;
        "sc-cancel-dialog": HTMLScCancelDialogElement;
        "sc-cancel-discount": HTMLScCancelDiscountElement;
        "sc-cancel-survey": HTMLScCancelSurveyElement;
        "sc-card": HTMLScCardElement;
        "sc-cart": HTMLScCartElement;
        "sc-cart-button": HTMLScCartButtonElement;
        "sc-cart-form": HTMLScCartFormElement;
        "sc-cart-form-submit": HTMLScCartFormSubmitElement;
        "sc-cart-header": HTMLScCartHeaderElement;
        "sc-cart-icon": HTMLScCartIconElement;
        "sc-cart-loader": HTMLScCartLoaderElement;
        "sc-cart-session-provider": HTMLScCartSessionProviderElement;
        "sc-cart-submit": HTMLScCartSubmitElement;
        "sc-cc-logo": HTMLScCcLogoElement;
        "sc-charges-list": HTMLScChargesListElement;
        "sc-checkbox": HTMLScCheckboxElement;
        "sc-checkout": HTMLScCheckoutElement;
        "sc-checkout-form-errors": HTMLScCheckoutFormErrorsElement;
        "sc-checkout-mollie-payment": HTMLScCheckoutMolliePaymentElement;
        "sc-checkout-paystack-payment-provider": HTMLScCheckoutPaystackPaymentProviderElement;
        "sc-checkout-product-price-variant-selector": HTMLScCheckoutProductPriceVariantSelectorElement;
        "sc-checkout-stock-alert": HTMLScCheckoutStockAlertElement;
        "sc-checkout-test-complete": HTMLScCheckoutTestCompleteElement;
        "sc-checkout-unsaved-changes-warning": HTMLScCheckoutUnsavedChangesWarningElement;
        "sc-choice": HTMLScChoiceElement;
        "sc-choice-container": HTMLScChoiceContainerElement;
        "sc-choices": HTMLScChoicesElement;
        "sc-column": HTMLScColumnElement;
        "sc-columns": HTMLScColumnsElement;
        "sc-compact-address": HTMLScCompactAddressElement;
        "sc-conditional-form": HTMLScConditionalFormElement;
        "sc-consumer": HTMLScConsumerElement;
        "sc-coupon-form": HTMLScCouponFormElement;
        "sc-custom-order-price-input": HTMLScCustomOrderPriceInputElement;
        "sc-customer-details": HTMLScCustomerDetailsElement;
        "sc-customer-edit": HTMLScCustomerEditElement;
        "sc-customer-email": HTMLScCustomerEmailElement;
        "sc-customer-firstname": HTMLScCustomerFirstnameElement;
        "sc-customer-lastname": HTMLScCustomerLastnameElement;
        "sc-customer-name": HTMLScCustomerNameElement;
        "sc-customer-phone": HTMLScCustomerPhoneElement;
        "sc-dashboard-customer-details": HTMLScDashboardCustomerDetailsElement;
        "sc-dashboard-downloads-list": HTMLScDashboardDownloadsListElement;
        "sc-dashboard-module": HTMLScDashboardModuleElement;
        "sc-dialog": HTMLScDialogElement;
        "sc-divider": HTMLScDividerElement;
        "sc-donation-choices": HTMLScDonationChoicesElement;
        "sc-downloads-list": HTMLScDownloadsListElement;
        "sc-drawer": HTMLScDrawerElement;
        "sc-dropdown": HTMLScDropdownElement;
        "sc-empty": HTMLScEmptyElement;
        "sc-error": HTMLScErrorElement;
        "sc-express-payment": HTMLScExpressPaymentElement;
        "sc-feature-demo-banner": HTMLScFeatureDemoBannerElement;
        "sc-flex": HTMLScFlexElement;
        "sc-form": HTMLScFormElement;
        "sc-form-components-validator": HTMLScFormComponentsValidatorElement;
        "sc-form-control": HTMLScFormControlElement;
        "sc-form-error-provider": HTMLScFormErrorProviderElement;
        "sc-form-row": HTMLScFormRowElement;
        "sc-form-state-provider": HTMLScFormStateProviderElement;
        "sc-format-bytes": HTMLScFormatBytesElement;
        "sc-format-interval": HTMLScFormatIntervalElement;
        "sc-format-number": HTMLScFormatNumberElement;
        "sc-fulfillment-shipping-status-badge": HTMLScFulfillmentShippingStatusBadgeElement;
        "sc-fulfillments": HTMLScFulfillmentsElement;
        "sc-heading": HTMLScHeadingElement;
        "sc-icon": HTMLScIconElement;
        "sc-image-slider": HTMLScImageSliderElement;
        "sc-input": HTMLScInputElement;
        "sc-invoice-details": HTMLScInvoiceDetailsElement;
        "sc-invoice-memo": HTMLScInvoiceMemoElement;
        "sc-invoice-status-badge": HTMLScInvoiceStatusBadgeElement;
        "sc-invoices-list": HTMLScInvoicesListElement;
        "sc-license": HTMLScLicenseElement;
        "sc-licenses-list": HTMLScLicensesListElement;
        "sc-line-item": HTMLScLineItemElement;
        "sc-line-item-bump": HTMLScLineItemBumpElement;
        "sc-line-item-invoice-due-date": HTMLScLineItemInvoiceDueDateElement;
        "sc-line-item-invoice-number": HTMLScLineItemInvoiceNumberElement;
        "sc-line-item-invoice-receipt-download": HTMLScLineItemInvoiceReceiptDownloadElement;
        "sc-line-item-shipping": HTMLScLineItemShippingElement;
        "sc-line-item-tax": HTMLScLineItemTaxElement;
        "sc-line-item-total": HTMLScLineItemTotalElement;
        "sc-line-item-trial": HTMLScLineItemTrialElement;
        "sc-line-items": HTMLScLineItemsElement;
        "sc-line-items-provider": HTMLScLineItemsProviderElement;
        "sc-login-form": HTMLScLoginFormElement;
        "sc-login-provider": HTMLScLoginProviderElement;
        "sc-manual-payment-method": HTMLScManualPaymentMethodElement;
        "sc-menu": HTMLScMenuElement;
        "sc-menu-divider": HTMLScMenuDividerElement;
        "sc-menu-item": HTMLScMenuItemElement;
        "sc-menu-label": HTMLScMenuLabelElement;
        "sc-mollie-add-method": HTMLScMollieAddMethodElement;
        "sc-order": HTMLScOrderElement;
        "sc-order-billing-address": HTMLScOrderBillingAddressElement;
        "sc-order-bump": HTMLScOrderBumpElement;
        "sc-order-bumps": HTMLScOrderBumpsElement;
        "sc-order-confirm-components-validator": HTMLScOrderConfirmComponentsValidatorElement;
        "sc-order-confirm-provider": HTMLScOrderConfirmProviderElement;
        "sc-order-confirmation": HTMLScOrderConfirmationElement;
        "sc-order-confirmation-customer": HTMLScOrderConfirmationCustomerElement;
        "sc-order-confirmation-details": HTMLScOrderConfirmationDetailsElement;
        "sc-order-confirmation-line-items": HTMLScOrderConfirmationLineItemsElement;
        "sc-order-confirmation-totals": HTMLScOrderConfirmationTotalsElement;
        "sc-order-coupon-form": HTMLScOrderCouponFormElement;
        "sc-order-detail": HTMLScOrderDetailElement;
        "sc-order-fulfillment-badge": HTMLScOrderFulfillmentBadgeElement;
        "sc-order-manual-instructions": HTMLScOrderManualInstructionsElement;
        "sc-order-password": HTMLScOrderPasswordElement;
        "sc-order-return-badge": HTMLScOrderReturnBadgeElement;
        "sc-order-shipment-badge": HTMLScOrderShipmentBadgeElement;
        "sc-order-shipping-address": HTMLScOrderShippingAddressElement;
        "sc-order-status-badge": HTMLScOrderStatusBadgeElement;
        "sc-order-submit": HTMLScOrderSubmitElement;
        "sc-order-summary": HTMLScOrderSummaryElement;
        "sc-order-tax-id-input": HTMLScOrderTaxIdInputElement;
        "sc-orders-list": HTMLScOrdersListElement;
        "sc-pagination": HTMLScPaginationElement;
        "sc-password": HTMLScPasswordElement;
        "sc-password-nag": HTMLScPasswordNagElement;
        "sc-payment": HTMLScPaymentElement;
        "sc-payment-method": HTMLScPaymentMethodElement;
        "sc-payment-method-choice": HTMLScPaymentMethodChoiceElement;
        "sc-payment-method-details": HTMLScPaymentMethodDetailsElement;
        "sc-payment-methods-list": HTMLScPaymentMethodsListElement;
        "sc-payment-selected": HTMLScPaymentSelectedElement;
        "sc-paypal-add-method": HTMLScPaypalAddMethodElement;
        "sc-paypal-buttons": HTMLScPaypalButtonsElement;
        "sc-paystack-add-method": HTMLScPaystackAddMethodElement;
        "sc-phone-input": HTMLScPhoneInputElement;
        "sc-pill-option": HTMLScPillOptionElement;
        "sc-premium-tag": HTMLScPremiumTagElement;
        "sc-price": HTMLScPriceElement;
        "sc-price-choice": HTMLScPriceChoiceElement;
        "sc-price-choice-container": HTMLScPriceChoiceContainerElement;
        "sc-price-choices": HTMLScPriceChoicesElement;
        "sc-price-input": HTMLScPriceInputElement;
        "sc-price-range": HTMLScPriceRangeElement;
        "sc-product-buy-button": HTMLScProductBuyButtonElement;
        "sc-product-donation-amount-choice": HTMLScProductDonationAmountChoiceElement;
        "sc-product-donation-choices": HTMLScProductDonationChoicesElement;
        "sc-product-donation-custom-amount": HTMLScProductDonationCustomAmountElement;
        "sc-product-item": HTMLScProductItemElement;
        "sc-product-item-image": HTMLScProductItemImageElement;
        "sc-product-item-list": HTMLScProductItemListElement;
        "sc-product-item-price": HTMLScProductItemPriceElement;
        "sc-product-item-title": HTMLScProductItemTitleElement;
        "sc-product-line-item": HTMLScProductLineItemElement;
        "sc-product-pills-variant-option": HTMLScProductPillsVariantOptionElement;
        "sc-product-price": HTMLScProductPriceElement;
        "sc-product-price-choices": HTMLScProductPriceChoicesElement;
        "sc-product-price-modal": HTMLScProductPriceModalElement;
        "sc-product-quantity": HTMLScProductQuantityElement;
        "sc-product-selected-price": HTMLScProductSelectedPriceElement;
        "sc-product-text": HTMLScProductTextElement;
        "sc-prose": HTMLScProseElement;
        "sc-provider": HTMLScProviderElement;
        "sc-provisional-banner": HTMLScProvisionalBannerElement;
        "sc-purchase-downloads-list": HTMLScPurchaseDownloadsListElement;
        "sc-quantity-select": HTMLScQuantitySelectElement;
        "sc-radio": HTMLScRadioElement;
        "sc-radio-group": HTMLScRadioGroupElement;
        "sc-recurring-price-choice-container": HTMLScRecurringPriceChoiceContainerElement;
        "sc-rich-text": HTMLScRichTextElement;
        "sc-secure-notice": HTMLScSecureNoticeElement;
        "sc-select": HTMLScSelectElement;
        "sc-session-provider": HTMLScSessionProviderElement;
        "sc-shipping-choices": HTMLScShippingChoicesElement;
        "sc-skeleton": HTMLScSkeletonElement;
        "sc-spacing": HTMLScSpacingElement;
        "sc-spinner": HTMLScSpinnerElement;
        "sc-stacked-list": HTMLScStackedListElement;
        "sc-stacked-list-row": HTMLScStackedListRowElement;
        "sc-stripe-add-method": HTMLScStripeAddMethodElement;
        "sc-stripe-element": HTMLScStripeElementElement;
        "sc-stripe-payment-element": HTMLScStripePaymentElementElement;
        "sc-stripe-payment-request": HTMLScStripePaymentRequestElement;
        "sc-subscription": HTMLScSubscriptionElement;
        "sc-subscription-ad-hoc-confirm": HTMLScSubscriptionAdHocConfirmElement;
        "sc-subscription-cancel": HTMLScSubscriptionCancelElement;
        "sc-subscription-details": HTMLScSubscriptionDetailsElement;
        "sc-subscription-next-payment": HTMLScSubscriptionNextPaymentElement;
        "sc-subscription-payment": HTMLScSubscriptionPaymentElement;
        "sc-subscription-payment-method": HTMLScSubscriptionPaymentMethodElement;
        "sc-subscription-reactivate": HTMLScSubscriptionReactivateElement;
        "sc-subscription-status-badge": HTMLScSubscriptionStatusBadgeElement;
        "sc-subscription-switch": HTMLScSubscriptionSwitchElement;
        "sc-subscription-variation-confirm": HTMLScSubscriptionVariationConfirmElement;
        "sc-subscriptions-list": HTMLScSubscriptionsListElement;
        "sc-summary": HTMLScSummaryElement;
        "sc-switch": HTMLScSwitchElement;
        "sc-tab": HTMLScTabElement;
        "sc-tab-group": HTMLScTabGroupElement;
        "sc-tab-panel": HTMLScTabPanelElement;
        "sc-table": HTMLScTableElement;
        "sc-table-cell": HTMLScTableCellElement;
        "sc-table-head": HTMLScTableHeadElement;
        "sc-table-row": HTMLScTableRowElement;
        "sc-tag": HTMLScTagElement;
        "sc-tax-id-input": HTMLScTaxIdInputElement;
        "sc-text": HTMLScTextElement;
        "sc-textarea": HTMLScTextareaElement;
        "sc-toggle": HTMLScToggleElement;
        "sc-toggles": HTMLScTogglesElement;
        "sc-tooltip": HTMLScTooltipElement;
        "sc-total": HTMLScTotalElement;
        "sc-upcoming-invoice": HTMLScUpcomingInvoiceElement;
        "sc-upgrade-required": HTMLScUpgradeRequiredElement;
        "sc-upsell": HTMLScUpsellElement;
        "sc-upsell-countdown-timer": HTMLScUpsellCountdownTimerElement;
        "sc-upsell-no-thanks-button": HTMLScUpsellNoThanksButtonElement;
        "sc-upsell-submit-button": HTMLScUpsellSubmitButtonElement;
        "sc-upsell-totals": HTMLScUpsellTotalsElement;
        "sc-visually-hidden": HTMLScVisuallyHiddenElement;
        "sc-wordpress-password-edit": HTMLScWordpressPasswordEditElement;
        "sc-wordpress-user": HTMLScWordpressUserElement;
        "sc-wordpress-user-edit": HTMLScWordpressUserEditElement;
    }
}
declare namespace LocalJSX {
    interface ScAddress {
        /**
          * The address.
         */
        "address"?: Partial<Address>;
        /**
          * Is this disabled?
         */
        "disabled"?: boolean;
        /**
          * The label for the field.
         */
        "label"?: string;
        /**
          * Is this loading?
         */
        "loading"?: boolean;
        "names"?: Partial<Address>;
        /**
          * Address change event.
         */
        "onScChangeAddress"?: (event: ScAddressCustomEvent<Partial<Address>>) => void;
        /**
          * Address change event.
         */
        "onScInputAddress"?: (event: ScAddressCustomEvent<Partial<Address>>) => void;
        "placeholders"?: Partial<Address>;
        /**
          * Is the name required
         */
        "requireName"?: boolean;
        /**
          * Is this required?
         */
        "required"?: boolean;
        /**
          * Should we show name field?
         */
        "showLine2"?: boolean;
        /**
          * Should we show name field?
         */
        "showName"?: boolean;
    }
    interface ScAlert {
        /**
          * Makes the alert closable.
         */
        "closable"?: boolean;
        /**
          * The length of time, in milliseconds, the alert will show before closing itself. If the user interacts with the alert before it closes (e.g. moves the mouse over it), the timer will restart. Defaults to `Infinity`.
         */
        "duration"?: number;
        /**
          * No icon
         */
        "noIcon"?: boolean;
        /**
          * When alert is hidden
         */
        "onScHide"?: (event: ScAlertCustomEvent<void>) => void;
        /**
          * When alert is shown
         */
        "onScShow"?: (event: ScAlertCustomEvent<void>) => void;
        /**
          * Indicates whether or not the alert is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * Scroll margin
         */
        "scrollMargin"?: string;
        /**
          * Scroll into view.
         */
        "scrollOnOpen"?: boolean;
        /**
          * The title.
         */
        "title"?: string;
        /**
          * The type of alert.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface ScAvatar {
        /**
          * The image source to use for the avatar.
         */
        "image"?: string;
        /**
          * Initials to use as a fallback when no image is available (1-2 characters max recommended).
         */
        "initials"?: string;
        /**
          * A label to use to describe the avatar to assistive devices.
         */
        "label"?: string;
        /**
          * Indicates how the browser should load the image.
         */
        "loading"?: 'eager' | 'lazy';
        /**
          * The shape of the avatar.
         */
        "shape"?: 'circle' | 'square' | 'rounded';
    }
    interface ScBadgeNotice {
        "label"?: string;
        "size"?: 'small' | 'medium' | 'large';
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'default';
    }
    interface ScBlockUi {
        "spinner"?: boolean;
        "transparent"?: boolean;
        "zIndex"?: number;
    }
    interface ScBreadcrumb {
        /**
          * Optional URL to direct the user to when the breadcrumb item is activated. When set, a link will be rendered internally. When unset, a button will be rendered instead.
         */
        "href"?: string;
        /**
          * The `rel` attribute to use on the link. Only used when `href` is set.
         */
        "rel"?: string;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
    }
    interface ScBreadcrumbs {
        /**
          * The label to use for the breadcrumb control. This will not be shown, but it will be announced by screen readers and other assistive devices.
         */
        "label"?: string;
    }
    interface ScButton {
        /**
          * Tells the browser to autofocus.
         */
        "autofocus"?: boolean;
        /**
          * Draws the button in a busy state.
         */
        "busy"?: boolean;
        /**
          * Draws the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Draws a circle button.
         */
        "circle"?: boolean;
        /**
          * Disables the button.
         */
        "disabled"?: boolean;
        /**
          * Tells the browser to download the linked file as this filename. Only used when `href` is set.
         */
        "download"?: string;
        /**
          * Draws the button full-width.
         */
        "full"?: boolean;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`.
         */
        "href"?: string;
        /**
          * Draws the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * An optional name for the button. Ignored when `href` is set.
         */
        "name"?: string;
        /**
          * Emitted when the button loses focus.
         */
        "onScBlur"?: (event: ScButtonCustomEvent<void>) => void;
        /**
          * Emitted when the button gains focus.
         */
        "onScFocus"?: (event: ScButtonCustomEvent<void>) => void;
        /**
          * Draws an outlined button.
         */
        "outline"?: boolean;
        /**
          * Draws a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Indicates if activating the button should submit the form. Ignored when `href` is set.
         */
        "submit"?: boolean;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
        /**
          * The button's type.
         */
        "type"?: 'default' | 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text' | 'link';
        /**
          * An optional value for the button. Ignored when `href` is set.
         */
        "value"?: string;
    }
    interface ScButtonGroup {
        "label"?: string;
        "separate"?: boolean;
    }
    interface ScCancelDialog {
        "onScRefresh"?: (event: ScCancelDialogCustomEvent<void>) => void;
        "onScRequestClose"?: (event: ScCancelDialogCustomEvent<'close-button' | 'keyboard' | 'overlay'>) => void;
        "open"?: boolean;
        "protocol"?: SubscriptionProtocol;
        "subscription"?: Subscription;
    }
    interface ScCancelDiscount {
        "comment"?: string;
        "onScCancel"?: (event: ScCancelDiscountCustomEvent<void>) => void;
        "onScPreserved"?: (event: ScCancelDiscountCustomEvent<void>) => void;
        "protocol"?: SubscriptionProtocol;
        "reason"?: CancellationReason;
        "subscription"?: Subscription;
    }
    interface ScCancelSurvey {
        "onScAbandon"?: (event: ScCancelSurveyCustomEvent<void>) => void;
        "onScSubmitReason"?: (event: ScCancelSurveyCustomEvent<{ reason: CancellationReason; comment: string }>) => void;
        "protocol"?: SubscriptionProtocol;
        "reasons"?: CancellationReason[];
    }
    interface ScCard {
        /**
          * Is this card borderless.
         */
        "borderless"?: boolean;
        /**
          * A link for the card.
         */
        "href"?: string;
        /**
          * Is this card loading.
         */
        "loading"?: boolean;
        /**
          * Eliminate the divider
         */
        "noDivider"?: boolean;
        /**
          * Remove padding
         */
        "noPadding"?: boolean;
    }
    interface ScCart {
        /**
          * Should we force show the cart, even if there's a form on the page?
         */
        "alwaysShow"?: boolean;
        /**
          * The template for the cart to inject when opened.
         */
        "cartTemplate"?: string;
        "checkoutLink"?: string;
        /**
          * The checkout url for the button.
         */
        "checkoutUrl"?: string;
        /**
          * Whether the floating button should be visible
         */
        "floatingIconEnabled"?: boolean;
        /**
          * The form id to use for the cart.
         */
        "formId"?: string;
        /**
          * The header for the popout.
         */
        "header"?: string;
        /**
          * Are we in test or live mode.
         */
        "mode"?: 'test' | 'live';
    }
    interface ScCartButton {
        /**
          * Whether the cart icon is always shown when the cart is empty
         */
        "cartMenuAlwaysShown"?: boolean;
        /**
          * The form id to use for the cart.
         */
        "formId"?: string;
        /**
          * Are we in test or live mode.
         */
        "mode"?: 'test' | 'live';
        /**
          * Whether the cart count will be shown or not when the cart is empty
         */
        "showEmptyCount"?: boolean;
    }
    interface ScCartForm {
        /**
          * The form id to use for the cart.
         */
        "formId"?: string;
        /**
          * Are we in test or live mode.
         */
        "mode"?: 'test' | 'live';
        /**
          * The price id to add.
         */
        "priceId"?: string;
        /**
          * The quantity
         */
        "quantity"?: number;
        /**
          * The variant id to add.
         */
        "variantId"?: string;
    }
    interface ScCartFormSubmit {
        /**
          * Show a full-width button.
         */
        "full"?: boolean;
        /**
          * Icon to show.
         */
        "icon"?: string;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The button type.
         */
        "type"?: 'default' | 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text' | 'link';
    }
    interface ScCartHeader {
        "onScCloseCart"?: (event: ScCartHeaderCustomEvent<void>) => void;
    }
    interface ScCartIcon {
        /**
          * The icon to show.
         */
        "icon"?: string;
    }
    interface ScCartLoader {
        /**
          * The cart template to inject when opened.
         */
        "template"?: string;
    }
    interface ScCartSessionProvider {
        /**
          * Set the state
         */
        "onScSetState"?: (event: ScCartSessionProviderCustomEvent<'loading' | 'busy' | 'navigating' | 'idle'>) => void;
    }
    interface ScCartSubmit {
        /**
          * Is the cart busy
         */
        "busy"?: boolean;
    }
    interface ScCcLogo {
        "brand"?: string;
    }
    interface ScChargesList {
        "allLink"?: string;
        "heading"?: string;
        /**
          * Query to fetch charges
         */
        "query"?: {
    page: number;
    per_page: number;
  };
        "showPagination"?: boolean;
    }
    interface ScCheckbox {
        /**
          * Draws the checkbox in a checked state.
         */
        "checked"?: boolean;
        /**
          * Disables the checkbox.
         */
        "disabled"?: boolean;
        /**
          * Makes this edit and not editable.
         */
        "edit"?: boolean;
        /**
          * Draws the checkbox in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid"?: boolean;
        /**
          * The checkbox's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScCheckboxCustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onScChange"?: (event: ScCheckboxCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScCheckboxCustomEvent<void>) => void;
        /**
          * Makes the checkbox a required field.
         */
        "required"?: boolean;
        /**
          * The checkbox's value attribute.
         */
        "value"?: string;
    }
    interface ScCheckout {
        /**
          * Is abandoned checkout enabled.
         */
        "abandonedCheckoutEnabled"?: boolean;
        /**
          * Alignment
         */
        "alignment"?: 'center' | 'wide' | 'full';
        /**
          * Currency to use for this checkout.
         */
        "currencyCode"?: string;
        /**
          * Stores the current customer
         */
        "customer"?: Customer;
        /**
          * Should we disable components validation
         */
        "disableComponentsValidation"?: boolean;
        /**
          * Can we edit line items?
         */
        "editLineItems"?: boolean;
        /**
          * The checkout form id
         */
        "formId"?: number;
        /**
          * Manual payment methods enabled for this form.
         */
        "manualPaymentMethods"?: ManualPaymentMethod[];
        /**
          * Are we in test or live mode.
         */
        "mode"?: 'test' | 'live';
        /**
          * When the form was modified.
         */
        "modified"?: string;
        /**
          * Checkout has an error.
         */
        "onScOrderError"?: (event: ScCheckoutCustomEvent<ResponseError>) => void;
        /**
          * Checkout has been finalized.
         */
        "onScOrderFinalized"?: (event: ScCheckoutCustomEvent<Checkout>) => void;
        /**
          * Checkout has been updated.
         */
        "onScOrderUpdated"?: (event: ScCheckoutCustomEvent<Checkout>) => void;
        /**
          * Whether to persist the session in the browser between visits.
         */
        "persistSession"?: boolean;
        /**
          * An array of prices to pre-fill in the form.
         */
        "prices"?: Array<PriceChoice>;
        /**
          * Processors enabled for this form.
         */
        "processors"?: Processor[];
        /**
          * A product to pre-fill the form.
         */
        "product"?: Product;
        /**
          * Can we remove line items?
         */
        "removeLineItems"?: boolean;
        /**
          * Use the Stripe payment element.
         */
        "stripePaymentElement"?: boolean;
        /**
          * Where to go on success
         */
        "successUrl"?: string;
        /**
          * The account tax protocol
         */
        "taxProtocol"?: TaxProtocol;
    }
    /**
     * This component listens for a confirmed event and redirects to the success url.
     */
    interface ScCheckoutFormErrors {
    }
    interface ScCheckoutMolliePayment {
        "method"?: string;
        "processorId"?: string;
    }
    interface ScCheckoutPaystackPaymentProvider {
    }
    interface ScCheckoutProductPriceVariantSelector {
        /**
          * The label for the price.
         */
        "label"?: string;
        /**
          * The product.
         */
        "product"?: Product;
        /**
          * The title for price and variant selections
         */
        "selectorTitle"?: string;
    }
    /**
     * This component listens for stock requirements and displays a dialog to the user.
     */
    interface ScCheckoutStockAlert {
        /**
          * Toggle line item event
         */
        "onScUpdateLineItem"?: (event: ScCheckoutStockAlertCustomEvent<LineItemData>) => void;
    }
    /**
     * This component listens to the order status
     * and confirms the order when payment is successful.
     */
    interface ScCheckoutTestComplete {
        /**
          * Checkout status to listen and do payment related stuff.
         */
        "checkoutStatus"?: string;
        /**
          * The order is paid event.
         */
        "onScOrderPaid"?: (event: ScCheckoutTestCompleteCustomEvent<Checkout>) => void;
        "onScSetState"?: (event: ScCheckoutTestCompleteCustomEvent<string>) => void;
        /**
          * Success url.
         */
        "successUrl"?: string;
    }
    interface ScCheckoutUnsavedChangesWarning {
        "state"?: FormState;
    }
    interface ScChoice {
        /**
          * Draws the choice in a checked state.
         */
        "checked"?: boolean;
        /**
          * Is the choice disabled
         */
        "disabled"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid"?: boolean;
        /**
          * The choice name attribute
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScChoiceCustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onScChange"?: (event: ScChoiceCustomEvent<boolean>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScChoiceCustomEvent<void>) => void;
        /**
          * Is this required
         */
        "required"?: boolean;
        /**
          * Show the radio/checkbox control
         */
        "showControl"?: boolean;
        /**
          * Show the label
         */
        "showLabel"?: boolean;
        /**
          * Show the price
         */
        "showPrice"?: boolean;
        /**
          * The size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The choice name attribute
         */
        "type"?: 'radio' | 'checkbox';
        /**
          * The choice value
         */
        "value"?: string;
    }
    interface ScChoiceContainer {
        /**
          * Draws the choice in a checked state.
         */
        "checked"?: boolean;
        /**
          * Is the choice disabled
         */
        "disabled"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid"?: boolean;
        /**
          * The choice name attribute
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScChoiceContainerCustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onScChange"?: (event: ScChoiceContainerCustomEvent<boolean>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScChoiceContainerCustomEvent<void>) => void;
        /**
          * Is this required
         */
        "required"?: boolean;
        /**
          * Role of radio/checkbox control
         */
        "role"?: string;
        /**
          * Show the radio/checkbox control
         */
        "showControl"?: boolean;
        /**
          * The size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The choice name attribute
         */
        "type"?: 'radio' | 'checkbox';
        /**
          * The choice value
         */
        "value"?: string;
    }
    interface ScChoices {
        "autoWidth"?: boolean;
        /**
          * Number of columns on desktop
         */
        "columns"?: number;
        /**
          * Validation error message.
         */
        "errorMessage"?: string;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * Hides the fieldset and legend that surrounds the group. The label will still be read by screen readers.
         */
        "hideLabel"?: boolean;
        /**
          * The group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * Required
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * Input size
         */
        "size"?: 'small' | 'medium' | 'large';
    }
    interface ScColumn {
    }
    interface ScColumns {
        /**
          * Is this full vertical height
         */
        "isFullHeight"?: boolean;
        /**
          * Is this reverse ordered on mobile
         */
        "isReversedOnMobile"?: boolean;
        /**
          * Is this stacked on mobile
         */
        "isStackedOnMobile"?: boolean;
        /**
          * The vertical alignment of the columns.
         */
        "verticalAlignment"?: string;
    }
    interface ScCompactAddress {
        /**
          * The address.
         */
        "address"?: Partial<Address>;
        /**
          * Label for the address
         */
        "label"?: string;
        /**
          * Is this loading
         */
        "loading"?: boolean;
        "names"?: Partial<Address>;
        /**
          * Address change event.
         */
        "onScChangeAddress"?: (event: ScCompactAddressCustomEvent<Partial<Address>>) => void;
        /**
          * Address input event.
         */
        "onScInputAddress"?: (event: ScCompactAddressCustomEvent<Partial<Address>>) => void;
        /**
          * Placeholders
         */
        "placeholders"?: Partial<Address>;
        /**
          * Is this required?
         */
        "required"?: boolean;
    }
    interface ScConditionalForm {
        /**
          * Selector label
         */
        "rule_groups"?: RuleGroup[];
    }
    interface ScConsumer {
        "onMountConsumer"?: (event: ScConsumerCustomEvent<any>) => void;
        "renderer"?: any;
    }
    interface ScCouponForm {
        /**
          * Is the form calculating
         */
        "busy"?: boolean;
        /**
          * The text for apply button
         */
        "buttonText"?: string;
        "collapsed"?: boolean;
        /**
          * Currency
         */
        "currency"?: string;
        /**
          * The discount
         */
        "discount"?: DiscountResponse;
        /**
          * The discount amount
         */
        "discountAmount"?: number;
        /**
          * Is the form editable
         */
        "editable"?: boolean;
        /**
          * The error message
         */
        "error"?: string;
        /**
          * Force the form to show
         */
        "forceOpen"?: boolean;
        /**
          * The label for the coupon form
         */
        "label"?: string;
        /**
          * Is the form loading
         */
        "loading"?: boolean;
        /**
          * When the coupon is applied
         */
        "onScApplyCoupon"?: (event: ScCouponFormCustomEvent<string>) => void;
        /**
          * Is it open
         */
        "open"?: boolean;
        /**
          * The placeholder for the input
         */
        "placeholder"?: string;
        /**
          * Has recurring
         */
        "showInterval"?: boolean;
    }
    interface ScCustomOrderPriceInput {
        /**
          * Is this busy
         */
        "busy"?: boolean;
        /**
          * Help text.
         */
        "help"?: string;
        /**
          * Label for the field.
         */
        "label"?: string;
        /**
          * Label for the choice.
         */
        "lineItems"?: LineItem[];
        /**
          * Is this loading
         */
        "loading"?: boolean;
        /**
          * Toggle line item event
         */
        "onScUpdateLineItem"?: (event: ScCustomOrderPriceInputCustomEvent<LineItemData1>) => void;
        /**
          * Input placeholder.
         */
        "placeholder"?: string;
        /**
          * Stores the price
         */
        "price"?: Price;
        /**
          * Id of the price.
         */
        "priceId"?: string;
        /**
          * Is this required?
         */
        "required"?: boolean;
        /**
          * Show the currency code?
         */
        "showCode"?: boolean;
    }
    interface ScCustomerDetails {
        "customer"?: Customer;
        "editLink"?: string;
        "error"?: string;
        "heading"?: string;
        "loading"?: boolean;
    }
    interface ScCustomerEdit {
        "customer"?: Customer;
        "heading"?: string;
        "successUrl"?: string;
    }
    interface ScCustomerEmail {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScCustomerEmailCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScCustomerEmailCustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onScClear"?: (event: ScCustomerEmailCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScCustomerEmailCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScCustomerEmailCustomEvent<void>) => void;
        /**
          * Prompt for login.
         */
        "onScLoginPrompt"?: (event: ScCustomerEmailCustomEvent<void>) => void;
        /**
          * Update the abandoned cart.
         */
        "onScUpdateAbandonedCart"?: (event: ScCustomerEmailCustomEvent<boolean>) => void;
        /**
          * Update the order state.
         */
        "onScUpdateOrderState"?: (event: ScCustomerEmailCustomEvent<Checkout>) => void;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * A message for tracking confirmation.
         */
        "trackingConfirmationMessage"?: string;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScCustomerFirstname {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * Is the user logged in.
         */
        "loggedIn"?: boolean;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScCustomerFirstnameCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScCustomerFirstnameCustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onScClear"?: (event: ScCustomerFirstnameCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScCustomerFirstnameCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScCustomerFirstnameCustomEvent<void>) => void;
        "onScUpdateCustomer"?: (event: ScCustomerFirstnameCustomEvent<{ email: string }>) => void;
        "onScUpdateOrderState"?: (event: ScCustomerFirstnameCustomEvent<Partial<Checkout>>) => void;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScCustomerLastname {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * Is the user logged in.
         */
        "loggedIn"?: boolean;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScCustomerLastnameCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScCustomerLastnameCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScCustomerLastnameCustomEvent<void>) => void;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: any;
    }
    interface ScCustomerName {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScCustomerNameCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScCustomerNameCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScCustomerNameCustomEvent<void>) => void;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: any;
    }
    interface ScCustomerPhone {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Error focus
         */
        "error"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScCustomerPhoneCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScCustomerPhoneCustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onScClear"?: (event: ScCustomerPhoneCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScCustomerPhoneCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScCustomerPhoneCustomEvent<void>) => void;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScDashboardCustomerDetails {
        "customerId"?: string;
        "heading"?: string;
    }
    interface ScDashboardDownloadsList {
        "allLink"?: string;
        "heading"?: string;
        "isCustomer"?: boolean;
        /**
          * Customer id to fetch subscriptions
         */
        "query"?: any;
        "requestNonce"?: string;
    }
    interface ScDashboardModule {
        "error"?: string;
        "heading"?: string;
        "loading"?: boolean;
    }
    interface ScDialog {
        /**
          * The dialog's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label"?: string;
        /**
          * Disables the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the dialog.
         */
        "noHeader"?: boolean;
        "onScAfterHide"?: (event: ScDialogCustomEvent<void>) => void;
        "onScAfterShow"?: (event: ScDialogCustomEvent<void>) => void;
        "onScHide"?: (event: ScDialogCustomEvent<void>) => void;
        "onScInitialFocus"?: (event: ScDialogCustomEvent<void>) => void;
        /**
          * Request close event
         */
        "onScRequestClose"?: (event: ScDialogCustomEvent<'close-button' | 'keyboard' | 'overlay'>) => void;
        "onScShow"?: (event: ScDialogCustomEvent<void>) => void;
        /**
          * Indicates whether or not the dialog is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
    }
    interface ScDivider {
    }
    interface ScDonationChoices {
        "busy"?: boolean;
        /**
          * Currency code for the donation.
         */
        "currencyCode"?: string;
        /**
          * The default amount to load the page with.
         */
        "defaultAmount"?: string;
        /**
          * The label for the field.
         */
        "label"?: string;
        /**
          * Order line items.
         */
        "lineItems"?: LineItem[];
        /**
          * Is this loading
         */
        "loading"?: boolean;
        /**
          * Toggle line item event
         */
        "onScAddLineItem"?: (event: ScDonationChoicesCustomEvent<LineItemData1>) => void;
        /**
          * Toggle line item event
         */
        "onScRemoveLineItem"?: (event: ScDonationChoicesCustomEvent<LineItemData1>) => void;
        /**
          * Toggle line item event
         */
        "onScUpdateLineItem"?: (event: ScDonationChoicesCustomEvent<LineItemData1>) => void;
        /**
          * The price id for the fields.
         */
        "priceId"?: string;
        "removeInvalid"?: boolean;
    }
    interface ScDownloadsList {
        "customerId"?: string;
        "downloads"?: Download[];
        "heading"?: string;
    }
    interface ScDrawer {
        /**
          * By default, the drawer slides out of its containing block (usually the viewport). To make the drawer slide out of its parent element, set this prop and add `position: relative` to the parent.
         */
        "contained"?: boolean;
        /**
          * The drawer's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label"?: string;
        /**
          * Removes the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the drawer.
         */
        "noHeader"?: boolean;
        "onScAfterHide"?: (event: ScDrawerCustomEvent<void>) => void;
        "onScAfterShow"?: (event: ScDrawerCustomEvent<void>) => void;
        "onScHide"?: (event: ScDrawerCustomEvent<void>) => void;
        "onScInitialFocus"?: (event: ScDrawerCustomEvent<void>) => void;
        "onScRequestClose"?: (event: ScDrawerCustomEvent<'close-button' | 'keyboard' | 'overlay' | 'method'>) => void;
        "onScShow"?: (event: ScDrawerCustomEvent<void>) => void;
        /**
          * Indicates whether or not the drawer is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The direction from which the drawer will open.
         */
        "placement"?: 'top' | 'end' | 'bottom' | 'start';
        /**
          * Sticky drawer header
         */
        "stickyHeader"?: boolean;
    }
    interface ScDropdown {
        "clickEl"?: HTMLElement;
        /**
          * Determines whether the dropdown should hide when a menu item is selected
         */
        "closeOnSelect"?: boolean;
        /**
          * Is this disabled.
         */
        "disabled"?: boolean;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance"?: number;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist"?: boolean;
        /**
          * Emitted when the dropdown closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onScHide"?: (event: ScDropdownCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onScShow"?: (event: ScDropdownCustomEvent<void>) => void;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The placement of the dropdown.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The placement of the dropdown panel
         */
        "position"?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding"?: number;
    }
    interface ScEmpty {
        "icon"?: string;
    }
    interface ScError {
        /**
          * Error to display.
         */
        "error"?: ResponseError | null;
        /**
          * Set the state.
         */
        "onScUpdateError"?: (event: ScErrorCustomEvent<ResponseError>) => void;
    }
    interface ScExpressPayment {
        "debug"?: boolean;
        "dividerText"?: string;
        "hasPaymentOptions"?: boolean;
        "processor"?: ProcessorName;
    }
    interface ScFeatureDemoBanner {
        "buttonText"?: string;
        "url"?: string;
    }
    interface ScFlex {
        "alignItems"?: string;
        "columnGap"?: string;
        "flexDirection"?: string;
        "flexWrap"?: string;
        "justifyContent"?: string;
        "stack"?: string;
    }
    interface ScForm {
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate"?: boolean;
        /**
          * Emitted when the form is submitted. This event will not be emitted if any form control inside of it is in an invalid state, unless the form has the `novalidate` attribute. Note that there is never a need to prevent this event, since it doen't send a GET or POST request like native forms. To "prevent" submission, use a conditional around the XHR request you use to submit the form's data with.
         */
        "onScFormChange"?: (event: ScFormCustomEvent<Object>) => void;
        /**
          * Backwards compat.
         */
        "onScFormSubmit"?: (event: ScFormCustomEvent<void>) => void;
        /**
          * Emitted when the form is submitted. This event will not be emitted if any form control inside of it is in an invalid state, unless the form has the `novalidate` attribute. Note that there is never a need to prevent this event, since it doen't send a GET or POST request like native forms. To "prevent" submission, use a conditional around the XHR request you use to submit the form's data with.
         */
        "onScSubmit"?: (event: ScFormCustomEvent<void>) => void;
    }
    interface ScFormComponentsValidator {
        /**
          * Disable validation?
         */
        "disabled"?: boolean;
        /**
          * The tax protocol
         */
        "taxProtocol"?: TaxProtocol;
    }
    interface ScFormControl {
        /**
          * Help text
         */
        "help"?: string;
        /**
          * Help id
         */
        "helpId"?: string;
        /**
          * Input id.
         */
        "inputId"?: string;
        /**
          * Input label.
         */
        "label"?: string;
        /**
          * Input label id.
         */
        "labelId"?: string;
        /**
          * Name for the input. Used for validation errors.
         */
        "name"?: string;
        /**
          * Whether the input is required.
         */
        "required"?: boolean;
        /**
          * Show the label.
         */
        "showLabel"?: boolean;
        /**
          * Size of the label
         */
        "size"?: 'small' | 'medium' | 'large';
    }
    /**
     * This component checks to make sure there is an error component
     * and adds one if it's missing.
     */
    interface ScFormErrorProvider {
    }
    interface ScFormRow {
    }
    /**
     * This component listens for a confirmed event and redirects to the success url.
     */
    interface ScFormStateProvider {
        /**
          * Set the state.
         */
        "onScSetCheckoutFormState"?: (event: ScFormStateProviderCustomEvent<FormState>) => void;
    }
    interface ScFormatBytes {
        /**
          * Determines how to display the result, e.g. "100 bytes", "100 b", or "100b".
         */
        "display"?: 'long' | 'short' | 'narrow';
        /**
          * The locale to use when formatting the number.
         */
        "locale"?: string;
        /**
          * The unit to display.
         */
        "unit"?: 'byte' | 'bit';
        /**
          * The number to format in bytes.
         */
        "value"?: number;
    }
    interface ScFormatInterval {
        "every"?: string;
        "fallback"?: string;
        "interval"?: string;
        /**
          * The number to format.
         */
        "value"?: number;
    }
    interface ScFormatNumber {
        /**
          * The currency to use when formatting. Must be an ISO 4217 currency code such as `USD` or `EUR`.
         */
        "currency"?: string;
        /**
          * How to display the currency.
         */
        "currencyDisplay"?: 'symbol' | 'narrowSymbol' | 'code' | 'name';
        /**
          * The locale to use when formatting the number.
         */
        "locale"?: string;
        /**
          * The maximum number of fraction digits to use. Possible values are 0 - 20.
         */
        "maximumFractionDigits"?: number;
        /**
          * The maximum number of significant digits to use,. Possible values are 1 - 21.
         */
        "maximumSignificantDigits"?: number;
        /**
          * The minimum number of fraction digits to use. Possible values are 0 - 20.
         */
        "minimumFractionDigits"?: number;
        /**
          * The minimum number of integer digits to use. Possible values are 1 - 21.
         */
        "minimumIntegerDigits"?: number;
        /**
          * The minimum number of significant digits to use. Possible values are 1 - 21.
         */
        "minimumSignificantDigits"?: number;
        /**
          * Should we convert
         */
        "noConvert"?: boolean;
        /**
          * Turns off grouping separators.
         */
        "noGrouping"?: boolean;
        /**
          * The formatting style to use.
         */
        "type"?: 'currency' | 'decimal' | 'percent' | 'unit';
        /**
          * The unit to use when formatting.
         */
        "unit"?: string;
        /**
          * The number to format.
         */
        "value"?: number;
    }
    interface ScFulfillmentShippingStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status"?: FulfillmentStatus;
    }
    interface ScFulfillments {
        "heading"?: string;
        "orderId"?: string;
    }
    interface ScHeading {
        "size"?: 'small' | 'medium' | 'large';
    }
    interface ScIcon {
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label"?: string;
        /**
          * The name of a registered custom icon library.
         */
        "library"?: string;
        /**
          * The name of the icon to draw.
         */
        "name"?: string;
        /**
          * Emitted when the icon has loaded.
         */
        "onScLoad"?: (event: ScIconCustomEvent<void>) => void;
        /**
          * An external URL of an SVG file.
         */
        "src"?: string;
    }
    interface ScImageSlider {
        "autoHeight"?: boolean;
        "hasThumbnails"?: boolean;
        /**
          * Accept a string or an array of objects
         */
        "images"?: string | { src: string; alt: string; srcset; width: number; height: number; sizes: string; title: string }[];
        "thumbnails"?: string | { src: string; alt: string; srcset; width: number; height: number; sizes: string; title: string }[];
        "thumbnailsPerPage"?: number;
    }
    interface ScInput {
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect"?: string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Adds a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * Hidden
         */
        "hidden"?: boolean;
        /**
          * The input's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * The input's maximum value.
         */
        "max"?: number | string;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength"?: number;
        /**
          * The input's minimum value.
         */
        "min"?: number | string;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength"?: number;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScInputCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScInputCustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onScClear"?: (event: ScInputCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScInputCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScInputCustomEvent<void>) => void;
        /**
          * A pattern to validate input against.
         */
        "pattern"?: string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Enables spell checking on the input.
         */
        "spellcheck"?: boolean;
        "squared"?: boolean;
        "squaredBottom"?: boolean;
        "squaredLeft"?: boolean;
        "squaredRight"?: boolean;
        "squaredTop"?: boolean;
        /**
          * The input's step attribute.
         */
        "step"?: number;
        /**
          * Adds a password toggle button to password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The input's type.
         */
        "type"?: 'email' | 'number' | 'password' | 'search' | 'tel' | 'text' | 'url' | 'hidden';
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScInvoiceDetails {
    }
    interface ScInvoiceMemo {
        /**
          * Memo Label
         */
        "text"?: string;
    }
    interface ScInvoiceStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status"?: InvoiceStatus;
    }
    interface ScInvoicesList {
        "allLink"?: string;
        "heading"?: string;
        "isCustomer"?: boolean;
        /**
          * Query to fetch invoices
         */
        "query"?: {
    page: number;
    per_page: number;
  };
    }
    interface ScLicense {
        /**
          * The license id
         */
        "licenseId"?: string;
    }
    interface ScLicensesList {
        /**
          * View all link
         */
        "allLink"?: string;
        /**
          * The heading of the licenses
         */
        "heading"?: string;
        /**
          * Whether the current user is customer
         */
        "isCustomer"?: boolean;
        "licenses"?: License[];
        /**
          * Query to fetch licenses
         */
        "query"?: {
    page: number;
    per_page: number;
  };
    }
    interface ScLineItem {
        /**
          * Currency symbol
         */
        "currency"?: string;
        /**
          * Price of the item
         */
        "price"?: string;
    }
    interface ScLineItemBump {
        "label"?: string;
        "loading"?: boolean;
    }
    interface ScLineItemInvoiceDueDate {
    }
    interface ScLineItemInvoiceNumber {
    }
    interface ScLineItemInvoiceReceiptDownload {
        "checkout"?: Checkout;
    }
    interface ScLineItemShipping {
        /**
          * Label
         */
        "label"?: string;
    }
    interface ScLineItemTax {
        "loading"?: boolean;
        "order"?: Checkout;
    }
    interface ScLineItemTotal {
        "checkout"?: Checkout;
        "size"?: 'large' | 'medium';
        "total"?: 'total' | 'subtotal';
    }
    interface ScLineItemTrial {
        /**
          * The label for the trial item
         */
        "label"?: string;
    }
    interface ScLineItems {
        /**
          * Is the line item editable?
         */
        "editable"?: boolean;
        /**
          * Is the line item removable?
         */
        "removable"?: boolean;
    }
    interface ScLineItemsProvider {
        /**
          * Update line items event
         */
        "onScUpdateLineItems"?: (event: ScLineItemsProviderCustomEvent<Array<LineItemData1>>) => void;
        /**
          * Order Object
         */
        "order"?: Checkout;
    }
    interface ScLoginForm {
    }
    interface ScLoginProvider {
        /**
          * Is the user logged in.
         */
        "loggedIn"?: boolean;
        "onScSetCustomer"?: (event: ScLoginProviderCustomEvent<{ email: string; name?: string }>) => void;
        "onScSetLoggedIn"?: (event: ScLoginProviderCustomEvent<boolean>) => void;
        "order"?: Checkout;
    }
    interface ScManualPaymentMethod {
        "paymentMethod"?: ManualPaymentMethod;
        "showDescription"?: boolean;
    }
    interface ScMenu {
        "ariaLabel"?: string;
        "onScSelect"?: (event: ScMenuCustomEvent<{ item: HTMLScMenuItemElement }>) => void;
    }
    interface ScMenuDivider {
    }
    interface ScMenuItem {
        /**
          * Draws the item in a checked state.
         */
        "checked"?: boolean;
        /**
          * Draws the menu item in a disabled state.
         */
        "disabled"?: boolean;
        /**
          * Optional link to follow.
         */
        "href"?: string;
        /**
          * The target of the link.
         */
        "target"?: string;
        /**
          * A unique value to store in the menu item. This can be used as a way to identify menu items when selected.
         */
        "value"?: string;
    }
    interface ScMenuLabel {
    }
    interface ScMollieAddMethod {
        "country"?: string;
        "currency"?: string;
        "customerId"?: string;
        "liveMode"?: boolean;
        "processorId"?: string;
        "successUrl"?: string;
    }
    interface ScOrder {
        "customerIds"?: string[];
        "heading"?: string;
        "orderId"?: string;
    }
    interface ScOrderBillingAddress {
        /**
          * City placeholder
         */
        "cityPlaceholder"?: string;
        /**
          * Country placeholder
         */
        "countryPlaceholder"?: string;
        /**
          * Default country for address
         */
        "defaultCountry"?: string;
        /**
          * Label for the field
         */
        "label"?: string;
        /**
          * Address placeholder
         */
        "line1Placeholder"?: string;
        /**
          * Address Line 2 placeholder
         */
        "line2Placeholder"?: string;
        /**
          * Name placeholder
         */
        "namePlaceholder"?: string;
        /**
          * Postal Code placeholder
         */
        "postalCodePlaceholder"?: string;
        /**
          * Show the name field
         */
        "showName"?: boolean;
        /**
          * State placeholder
         */
        "statePlaceholder"?: string;
        /**
          * Toggle label
         */
        "toggleLabel"?: string;
    }
    interface ScOrderBump {
        /**
          * The bump
         */
        "bump"?: Bump;
        /**
          * Should we show the controls
         */
        "showControl"?: boolean;
    }
    interface ScOrderBumps {
        "help"?: string;
        "label"?: string;
        "showControl"?: boolean;
    }
    interface ScOrderConfirmComponentsValidator {
        /**
          * The checkout
         */
        "checkout"?: Checkout;
    }
    /**
     * This component listens to the order status
     * and confirms the order when payment is successful.
     */
    interface ScOrderConfirmProvider {
        /**
          * Checkout status to listen and do payment related stuff.
         */
        "checkoutStatus"?: string;
        /**
          * The order is paid event.
         */
        "onScOrderPaid"?: (event: ScOrderConfirmProviderCustomEvent<Checkout>) => void;
        "onScSetState"?: (event: ScOrderConfirmProviderCustomEvent<string>) => void;
        /**
          * Success url.
         */
        "successUrl"?: string;
    }
    interface ScOrderConfirmation {
        "order"?: Checkout;
    }
    interface ScOrderConfirmationCustomer {
        /**
          * The customer
         */
        "customer"?: Customer;
        /**
          * Error message.
         */
        "error"?: string;
        /**
          * The heading
         */
        "heading"?: string;
        /**
          * Is this loading?
         */
        "loading"?: boolean;
        /**
          * The Order
         */
        "order"?: Checkout;
    }
    interface ScOrderConfirmationDetails {
        "loading"?: boolean;
        "order"?: Order;
    }
    interface ScOrderConfirmationLineItems {
        "loading"?: boolean;
        "order"?: Checkout;
    }
    interface ScOrderConfirmationTotals {
        "order"?: Checkout;
    }
    interface ScOrderCouponForm {
        "buttonText"?: string;
        "collapsed"?: boolean;
        "label"?: string;
        "loading"?: boolean;
        "placeholder"?: string;
    }
    interface ScOrderDetail {
        "fallback"?: string;
        "label"?: string;
        "loading"?: boolean;
        "metaKey"?: string;
        "order"?: Checkout;
        "value"?: string;
    }
    interface ScOrderFulfillmentBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status"?: OrderFulFillmentStatus;
    }
    interface ScOrderManualInstructions {
        "manualPaymentInstructions"?: string;
        "manualPaymentTitle"?: string;
    }
    interface ScOrderPassword {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * The input's password confirmation attribute.
         */
        "confirmation"?: boolean;
        /**
          * The input's confirmation help text.
         */
        "confirmationHelp"?: string;
        /**
          * The input's confirmation label text.
         */
        "confirmationLabel"?: string;
        /**
          * The input's confirmation placeholder text.
         */
        "confirmationPlaceholder"?: string;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Does the email exist?
         */
        "emailExists"?: boolean;
        /**
          * Ensures strong password validation.
         */
        "enableValidation"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * The input's label.
         */
        "label"?: string;
        "loggedIn"?: boolean;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScOrderReturnBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status"?: ReturnRequestStatus;
    }
    interface ScOrderShipmentBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status"?: OrderShipmentStatus;
    }
    interface ScOrderShippingAddress {
        "cityPlaceholder"?: string;
        "countryPlaceholder"?: string;
        /**
          * Default country for address
         */
        "defaultCountry"?: string;
        /**
          * Show the   address
         */
        "full"?: boolean;
        /**
          * Label for the field.
         */
        "label"?: string;
        "line1Placeholder"?: string;
        "line2Placeholder"?: string;
        /**
          * Show the placeholder fields.
         */
        "namePlaceholder"?: string;
        /**
          * Placeholder values.
         */
        "placeholders"?: Partial<Address>;
        "postalCodePlaceholder"?: string;
        /**
          * Whether to require the name in the address
         */
        "requireName"?: boolean;
        /**
          * Is this required (defaults to false)
         */
        "required"?: boolean;
        /**
          * Show the name field.
         */
        "showName"?: boolean;
        "statePlaceholder"?: string;
    }
    interface ScOrderStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's statux type.
         */
        "status"?: OrderStatus;
    }
    interface ScOrderSubmit {
        /**
          * Currency Code
         */
        "currencyCode"?: string;
        /**
          * Show a full-width button.
         */
        "full"?: boolean;
        /**
          * Icon to show.
         */
        "icon"?: string;
        /**
          * Is the order loading.
         */
        "loading"?: boolean;
        /**
          * The current order.
         */
        "order"?: Checkout;
        /**
          * Is the order paying.
         */
        "paying"?: boolean;
        /**
          * The selected processor.
         */
        "processor"?: ProcessorName;
        /**
          * Keys and secrets for processors.
         */
        "processors"?: Processor[];
        /**
          * Show the secure notice
         */
        "secureNotice"?: boolean;
        /**
          * Secure
         */
        "secureNoticeText"?: string;
        /**
          * Show the total.
         */
        "showTotal"?: boolean;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The button type.
         */
        "type"?: 'default' | 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text' | 'link';
    }
    interface ScOrderSummary {
        "busy"?: boolean;
        "collapsed"?: boolean;
        "collapsedOnDesktop"?: boolean;
        "collapsedOnMobile"?: boolean;
        "collapsible"?: boolean;
        "invoiceSummaryText"?: string;
        /**
          * Show the toggle
         */
        "onScHide"?: (event: ScOrderSummaryCustomEvent<void>) => void;
        /**
          * Show the toggle
         */
        "onScShow"?: (event: ScOrderSummaryCustomEvent<void>) => void;
        "order"?: Checkout;
        "orderSummaryText"?: string;
    }
    interface ScOrderTaxIdInput {
        /**
          * AU zone label
         */
        "auAbnLabel"?: string;
        /**
          * GST zone label
         */
        "caGstLabel"?: string;
        /**
          * EU zone label
         */
        "euVatLabel"?: string;
        /**
          * UK zone label
         */
        "gbVatLabel"?: string;
        /**
          * Help text
         */
        "helpText"?: string;
        /**
          * Other zones label
         */
        "otherLabel"?: string;
        /**
          * Force show the field.
         */
        "show"?: boolean;
        /**
          * Tax ID Types which will be shown Eg: '["eu_vat", "gb_vat"]'
         */
        "taxIdTypes"?: string | string[];
    }
    interface ScOrdersList {
        "allLink"?: string;
        "heading"?: string;
        "isCustomer"?: boolean;
        /**
          * Query to fetch orders
         */
        "query"?: {
    page: number;
    per_page: number;
  };
    }
    interface ScPagination {
        "onScNextPage"?: (event: ScPaginationCustomEvent<void>) => void;
        "onScPrevPage"?: (event: ScPaginationCustomEvent<void>) => void;
        "page"?: number;
        "perPage"?: number;
        "total"?: number;
        "totalPages"?: number;
        "totalShowing"?: number;
    }
    interface ScPassword {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * The input's password confirmation attribute.
         */
        "confirmation"?: boolean;
        /**
          * The input's confirmation help text.
         */
        "confirmationHelp"?: string;
        /**
          * The input's confirmation label text.
         */
        "confirmationLabel"?: string;
        /**
          * The input's confirmation placeholder text.
         */
        "confirmationPlaceholder"?: string;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Ensures strong password validation.
         */
        "enableValidation"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * The name for the input.
         */
        "name"?: string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScPasswordNag {
        /**
          * Ensures strong password validation.
         */
        "enableValidation"?: boolean;
        "open"?: boolean;
        /**
          * The success url.
         */
        "successUrl"?: string;
        /**
          * The type of alert.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface ScPayment {
        /**
          * Disabled processor types
         */
        "disabledProcessorTypes"?: string[];
        /**
          * Hide the test mode badge
         */
        "hideTestModeBadge"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        "secureNotice"?: string;
        "stripePaymentElement"?: boolean;
    }
    interface ScPaymentMethod {
        "externalLink"?: string;
        "externalLinkTooltipText"?: string;
        "full"?: boolean;
        "paymentMethod"?: PaymentMethod;
    }
    interface ScPaymentMethodChoice {
        /**
          * Should we show this in a card?
         */
        "card"?: boolean;
        /**
          * Is this a manual processor
         */
        "isManual"?: boolean;
        /**
          * The method id
         */
        "methodId"?: string;
        /**
          * The processor ID
         */
        "processorId"?: string;
    }
    interface ScPaymentMethodDetails {
        "editHandler"?: () => void;
        "paymentMethod"?: PaymentMethod;
    }
    interface ScPaymentMethodsList {
        /**
          * Whether default payment method can be detached
         */
        "canDetachDefaultPaymentMethod"?: boolean;
        /**
          * The heading
         */
        "heading"?: string;
        /**
          * Is this a customer
         */
        "isCustomer"?: boolean;
        /**
          * Query to fetch paymentMethods
         */
        "query"?: object;
    }
    interface ScPaymentSelected {
        "iconName"?: string;
        "label"?: string;
    }
    interface ScPaypalAddMethod {
        "currency"?: string;
        "customerId"?: string;
        "liveMode"?: boolean;
        "successUrl"?: string;
    }
    interface ScPaypalButtons {
        /**
          * Is this busy?
         */
        "busy"?: boolean;
        /**
          * Buttons to render
         */
        "buttons"?: string[];
        /**
          * Client id for the script.
         */
        "clientId"?: string;
        /**
          * Button color.
         */
        "color"?: 'gold' | 'blue' | 'silver' | 'black' | 'white';
        /**
          * Label for the button.
         */
        "label"?: 'paypal' | 'checkout' | 'buynow' | 'pay' | 'installment';
        /**
          * The merchant id for paypal.
         */
        "merchantId"?: string;
        /**
          * Merchant initiated billing enabled.
         */
        "merchantInitiated"?: boolean;
        /**
          * Test or live mode.
         */
        "mode"?: 'test' | 'live';
        "onScPaid"?: (event: ScPaypalButtonsCustomEvent<void>) => void;
        /**
          * Set the state machine
         */
        "onScSetState"?: (event: ScPaypalButtonsCustomEvent<string>) => void;
        /**
          * The order.
         */
        "order"?: Checkout;
    }
    interface ScPaystackAddMethod {
        "currency"?: string;
        "customerId"?: string;
        "liveMode"?: boolean;
        "successUrl"?: string;
    }
    interface ScPhoneInput {
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect"?: string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Adds a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * Hidden
         */
        "hidden"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * The input's maximum value.
         */
        "max"?: number | string;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength"?: number;
        /**
          * The input's minimum value.
         */
        "min"?: number | string;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength"?: number;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScPhoneInputCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScPhoneInputCustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onScClear"?: (event: ScPhoneInputCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScPhoneInputCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScPhoneInputCustomEvent<void>) => void;
        /**
          * A pattern to validate input against.
         */
        "pattern"?: string;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Enables spell checking on the input.
         */
        "spellcheck"?: boolean;
        "squared"?: boolean;
        "squaredBottom"?: boolean;
        "squaredLeft"?: boolean;
        "squaredRight"?: boolean;
        "squaredTop"?: boolean;
        /**
          * The input's step attribute.
         */
        "step"?: number;
        /**
          * Adds a password toggle button to password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScPillOption {
        /**
          * Label
         */
        "isSelected"?: boolean;
        "isUnavailable"?: boolean;
    }
    interface ScPremiumTag {
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
    }
    /**
     * Internal dependencies.
     */
    interface ScPrice {
        /**
          * Is the product ad_hoc?
         */
        "adHoc"?: boolean;
        /**
          * The amount
         */
        "amount"?: number;
        /**
          * The currency.
         */
        "currency"?: string;
        /**
          * The recurring interval
         */
        "recurringInterval"?: 'week' | 'month' | 'year' | 'never';
        /**
          * The recurring interval count
         */
        "recurringIntervalCount"?: number;
        /**
          * The recurring period count
         */
        "recurringPeriodCount"?: number;
        /**
          * The sale text
         */
        "saleText"?: string;
        /**
          * The scratch amount
         */
        "scratchAmount"?: number;
        /**
          * The setup fee amount
         */
        "setupFeeAmount"?: number;
        /**
          * The setup fee name
         */
        "setupFeeName"?: string;
        /**
          * The trial duration days
         */
        "trialDurationDays"?: number;
    }
    interface ScPriceChoice {
        /**
          * Is this blank?
         */
        "blank"?: boolean;
        /**
          * Is this checked by default
         */
        "checked"?: boolean;
        /**
          * Label for the choice.
         */
        "description"?: string;
        /**
          * Errors from response
         */
        "error"?: ResponseError;
        /**
          * Is this an ad-hoc price choice
         */
        "isAdHoc"?: Boolean;
        /**
          * Label for the choice.
         */
        "label"?: string;
        /**
          * Is this loading
         */
        "loading"?: boolean;
        /**
          * Add entities
         */
        "onScAddEntities"?: (event: ScPriceChoiceCustomEvent<any>) => void;
        /**
          * Toggle line item event
         */
        "onScRemoveLineItem"?: (event: ScPriceChoiceCustomEvent<LineItemData1>) => void;
        /**
          * Toggle line item event
         */
        "onScUpdateLineItem"?: (event: ScPriceChoiceCustomEvent<LineItemData1>) => void;
        /**
          * Session
         */
        "order"?: Checkout;
        /**
          * Stores the price
         */
        "price"?: Price;
        /**
          * Id of the price.
         */
        "priceId"?: string;
        /**
          * Price entities
         */
        "prices"?: Prices;
        /**
          * Stores the price
         */
        "product"?: Product;
        /**
          * Product entity
         */
        "products"?: Products;
        /**
          * Default quantity
         */
        "quantity"?: number;
        /**
          * Show the radio/checkbox control
         */
        "showControl"?: boolean;
        /**
          * Show the label
         */
        "showLabel"?: boolean;
        /**
          * Show the price amount
         */
        "showPrice"?: boolean;
        /**
          * Choice Type
         */
        "type"?: 'checkbox' | 'radio';
    }
    interface ScPriceChoiceContainer {
        /**
          * Is this checked by default
         */
        "checked"?: boolean;
        /**
          * Label for the choice.
         */
        "description"?: string;
        /**
          * Label for the choice.
         */
        "label"?: string;
        /**
          * Is this loading
         */
        "loading"?: boolean;
        "onScChange"?: (event: ScPriceChoiceContainerCustomEvent<void>) => void;
        /**
          * Stores the price
         */
        "price"?: string | Price;
        "required"?: boolean;
        /**
          * Show the radio/checkbox control
         */
        "showControl"?: boolean;
        /**
          * Show the label
         */
        "showLabel"?: boolean;
        /**
          * Show the price amount
         */
        "showPrice"?: boolean;
        /**
          * Choice Type
         */
        "type"?: 'checkbox' | 'radio';
    }
    interface ScPriceChoices {
        /**
          * Number of columns
         */
        "columns"?: number;
        /**
          * Selector label
         */
        "label"?: string;
        /**
          * Toggle line item event
         */
        "onScRemoveLineItem"?: (event: ScPriceChoicesCustomEvent<LineItemData1>) => void;
        /**
          * Toggle line item event
         */
        "onScUpdateLineItem"?: (event: ScPriceChoicesCustomEvent<LineItemData1>) => void;
        /**
          * Required by default
         */
        "required"?: boolean;
    }
    interface ScPriceInput {
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Adds a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * 3 letter currency code for input
         */
        "currencyCode"?: string;
        /**
          * Disables the input.
         */
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's help text.
         */
        "help"?: string;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * The input's maximum value.
         */
        "max"?: number;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength"?: number;
        /**
          * The input's minimum value.
         */
        "min"?: number;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength"?: number;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScPriceInputCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScPriceInputCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScPriceInputCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScInput"?: (event: ScPriceInputCustomEvent<void>) => void;
        /**
          * Draws a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the input a required field.
         */
        "required"?: boolean;
        /**
          * Show the currency code with the input
         */
        "showCode"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScPriceRange {
        /**
          * The array of price objects
         */
        "prices"?: Price[];
    }
    interface ScProductBuyButton {
        "addToCart"?: boolean;
        "checkoutLink"?: string;
        "formId"?: number;
        "mode"?: 'live' | 'test';
        "productId"?: string;
    }
    interface ScProductDonationAmountChoice {
        /**
          * The label for the field.
         */
        "label"?: string;
        /**
          * The product id for the fields.
         */
        "productId"?: string;
        /**
          * The value of the field.
         */
        "value"?: number;
    }
    interface ScProductDonationChoices {
        /**
          * The label for the field.
         */
        "label"?: string;
        /**
          * The product id for the fields.
         */
        "productId"?: string;
        "recurring"?: boolean;
    }
    interface ScProductDonationCustomAmount {
        /**
          * Selected Product Id for the donation.
         */
        "productId"?: string;
        /**
          * Custom Amount of the donation.
         */
        "value"?: number;
    }
    interface ScProductItem {
        "layoutConfig"?: LayoutConfig;
        "product"?: Product;
    }
    interface ScProductItemImage {
        "product"?: Product;
        "sizing"?: 'cover' | 'contain';
    }
    interface ScProductItemList {
        /**
          * Should we paginate?
         */
        "ajaxPagination"?: boolean;
        /**
          * Should allow collection filter
         */
        "collectionEnabled"?: boolean;
        /**
          * Show for a specific collection
         */
        "collectionId"?: string;
        /**
          * Show only featured products.
         */
        "featured"?: boolean;
        /**
          * Limit to a set of ids.
         */
        "ids"?: string[];
        "layoutConfig"?: LayoutConfig1;
        "limit"?: number;
        /**
          * Products viewed
         */
        "onScProductsViewed"?: (event: ScProductItemListCustomEvent<ProductsViewedParams>) => void;
        /**
          * Product was searched
         */
        "onScSearched"?: (event: ScProductItemListCustomEvent<ProductsSearchedParams>) => void;
        "page"?: number;
        /**
          * The page title
         */
        "pageTitle"?: string;
        /**
          * Pagination
         */
        "pagination"?: {
    total: number;
    total_pages: number;
  };
        "paginationAlignment"?: string;
        /**
          * Should we auto-scroll to the top when paginating via ajax
         */
        "paginationAutoScroll"?: boolean;
        /**
          * Should we paginate?
         */
        "paginationEnabled"?: boolean;
        "products"?: Product[];
        /**
          * Query to search for
         */
        "query"?: string;
        /**
          * Should allow search
         */
        "searchEnabled"?: boolean;
        /**
          * Sort
         */
        "sort"?: string;
        /**
          * Should allow search
         */
        "sortEnabled"?: boolean;
    }
    interface ScProductItemPrice {
        /**
          * Product metrics
         */
        "metrics"?: ProductMetrics;
        "prices"?: Price[];
        /**
          * Show price range?
         */
        "range"?: boolean;
    }
    interface ScProductItemTitle {
    }
    interface ScProductLineItem {
        /**
          * Product monetary amount
         */
        "amount"?: number;
        /**
          * Currency for the product
         */
        "currency"?: string;
        /**
          * Can we select the quantity
         */
        "editable"?: boolean;
        /**
          * Product line item fees.
         */
        "fees"?: Fee[];
        /**
          * Image attributes.
         */
        "image"?: ImageAttributes;
        /**
          * Recurring interval (i.e. monthly, once, etc.)
         */
        "interval"?: string;
        /**
          * The max allowed.
         */
        "max"?: number;
        /**
          * Product name
         */
        "name"?: string;
        /**
          * Emitted when the quantity changes.
         */
        "onScRemove"?: (event: ScProductLineItemCustomEvent<void>) => void;
        /**
          * Emitted when the quantity changes.
         */
        "onScUpdateQuantity"?: (event: ScProductLineItemCustomEvent<number>) => void;
        /**
          * Price name
         */
        "priceName"?: string;
        /**
          * The purchasable status display
         */
        "purchasableStatusDisplay"?: string;
        /**
          * Quantity
         */
        "quantity"?: number;
        /**
          * Is the line item removable
         */
        "removable"?: boolean;
        /**
          * The line item scratch amount
         */
        "scratchAmount"?: number;
        /**
          * Is the setup fee not included in the free trial?
         */
        "setupFeeTrialEnabled"?: boolean;
        /**
          * The SKU.
         */
        "sku"?: string;
        /**
          * Trial duration days
         */
        "trialDurationDays"?: number;
        /**
          * Product variant label
         */
        "variantLabel"?: string;
    }
    interface ScProductPillsVariantOption {
        /**
          * Label
         */
        "label"?: string;
        /**
          * Which option number?
         */
        "optionNumber"?: 1 | 2 | 3;
        /**
          * The product id
         */
        "productId"?: string;
    }
    interface ScProductPrice {
        /**
          * The product's prices.
         */
        "prices"?: Price[];
        /**
          * The product id
         */
        "productId"?: string;
        /**
          * The sale text
         */
        "saleText"?: string;
    }
    interface ScProductPriceChoices {
        /**
          * The product price choice label
         */
        "label"?: string;
        /**
          * The product id
         */
        "productId"?: string;
        /**
          * Whether to show the price
         */
        "showPrice"?: boolean;
    }
    interface ScProductPriceModal {
        /**
          * Whether to add to cart
         */
        "addToCart"?: boolean;
        /**
          * The button text
         */
        "buttonText"?: string;
        /**
          * The product id
         */
        "productId"?: string;
    }
    interface ScProductQuantity {
        /**
          * Display server-side validation errors.
         */
        "errors"?: any;
        /**
          * Help text
         */
        "help"?: string;
        /**
          * Input label.
         */
        "label"?: string;
        /**
          * Name for the input. Used for validation errors.
         */
        "name"?: string;
        /**
          * The product id
         */
        "productId"?: string;
        /**
          * Whether the input is required.
         */
        "required"?: boolean;
        /**
          * Show the label.
         */
        "showLabel"?: boolean;
        /**
          * Size of the control
         */
        "size"?: 'small' | 'medium' | 'large';
    }
    interface ScProductSelectedPrice {
        /**
          * Toggle line item event
         */
        "onScUpdateLineItem"?: (event: ScProductSelectedPriceCustomEvent<LineItemData>) => void;
        /**
          * The product id.
         */
        "productId"?: string;
    }
    interface ScProductText {
        "productId"?: string;
        "text"?: 'name' | 'description';
    }
    interface ScProse {
    }
    interface ScProvider {
        "STENCIL_CONTEXT"?: { [key: string]: any };
        "onMountConsumer"?: (event: ScProviderCustomEvent<any>) => void;
    }
    interface ScProvisionalBanner {
        /**
          * Claim URL.
         */
        "claimUrl"?: string;
    }
    interface ScPurchaseDownloadsList {
        "allLink"?: string;
        "busy"?: boolean;
        "error"?: string;
        "heading"?: string;
        "loading"?: boolean;
        "purchases"?: Array<Purchase>;
        "requestNonce"?: string;
    }
    interface ScQuantitySelect {
        "clickEl"?: HTMLElement;
        "disabled"?: boolean;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        "max"?: number;
        "min"?: number;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScQuantitySelectCustomEvent<void>) => void;
        "onScChange"?: (event: ScQuantitySelectCustomEvent<number>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScQuantitySelectCustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onScInput"?: (event: ScQuantitySelectCustomEvent<number>) => void;
        "quantity"?: number;
        "size"?: 'small' | 'medium' | 'large';
    }
    interface ScRadio {
        /**
          * Draws the radio in a checked state.
         */
        "checked"?: boolean;
        /**
          * Is the radio disabled
         */
        "disabled"?: boolean;
        /**
          * This will be true as a workaround in the block editor to focus on the content.
         */
        "edit"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid"?: boolean;
        /**
          * The radios name attribute
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScRadioCustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onScChange"?: (event: ScRadioCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScRadioCustomEvent<void>) => void;
        /**
          * Is this required
         */
        "required"?: boolean;
        /**
          * The radios value
         */
        "value"?: string;
    }
    interface ScRadioGroup {
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The radio group label. Required for proper accessibility.
         */
        "label"?: string;
        "onScChange"?: (event: ScRadioGroupCustomEvent<string>) => void;
        /**
          * Is one of these items required.
         */
        "required"?: boolean;
        /**
          * The selected value of the control.
         */
        "value"?: string;
    }
    interface ScRecurringPriceChoiceContainer {
        /**
          * Label for the choice.
         */
        "label"?: string;
        /**
          * Change event.
         */
        "onScChange"?: (event: ScRecurringPriceChoiceContainerCustomEvent<string>) => void;
        /**
          * The prices to choose from.
         */
        "prices"?: Price[];
        /**
          * The product.
         */
        "product"?: Product;
        /**
          * The currently selected price
         */
        "selectedPrice"?: Price;
        /**
          * Should we show the price?
         */
        "showAmount"?: boolean;
        /**
          * Show the radio/checkbox control
         */
        "showControl"?: boolean;
        /**
          * Should we show the price details?
         */
        "showDetails"?: boolean;
    }
    interface ScRichText {
        /**
          * Disables the textarea.
         */
        "disabled"?: boolean;
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "help"?: string;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The max length.
         */
        "maxlength"?: number;
        /**
          * The textarea's name attribute.
         */
        "name"?: string;
        "onScBlur"?: (event: ScRichTextCustomEvent<void>) => void;
        "onScChange"?: (event: ScRichTextCustomEvent<void>) => void;
        "onScFocus"?: (event: ScRichTextCustomEvent<void>) => void;
        "onScInput"?: (event: ScRichTextCustomEvent<void>) => void;
        /**
          * The textarea's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the textarea readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the textarea a required field.
         */
        "required"?: boolean;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The textarea's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The textarea's value attribute.
         */
        "value"?: string;
    }
    interface ScSecureNotice {
    }
    interface ScSelect {
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The input's value attribute.
         */
        "choices"?: Array<ChoiceItem>;
        "closeOnSelect"?: boolean;
        "disabled"?: boolean;
        /**
          * Some help text for the input.
         */
        "help"?: string;
        "hoist"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, `maxlength`, and `pattern` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        "loading"?: boolean;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScSelectCustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onScChange"?: (event: ScSelectCustomEvent<ChoiceItem>) => void;
        /**
          * Emitted whent the components search query changes
         */
        "onScClose"?: (event: ScSelectCustomEvent<string>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScSelectCustomEvent<void>) => void;
        /**
          * Emitted whent the components search query changes
         */
        "onScOpen"?: (event: ScSelectCustomEvent<string>) => void;
        /**
          * Emitted when the list scrolls to the end.
         */
        "onScScrollEnd"?: (event: ScSelectCustomEvent<void>) => void;
        /**
          * Emitted whent the components search query changes
         */
        "onScSearch"?: (event: ScSelectCustomEvent<string>) => void;
        /**
          * Is this open
         */
        "open"?: boolean;
        /**
          * Placeholder for no value
         */
        "placeholder"?: string;
        /**
          * The placement of the dropdown.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        "position"?: 'bottom-left' | 'bottom-right' | 'top-left' | 'top-right';
        "required"?: boolean;
        /**
          * Is search enabled?
         */
        "search"?: boolean;
        /**
          * Placeholder for search
         */
        "searchPlaceholder"?: string;
        "showParentLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        "squared"?: boolean;
        "squaredBottom"?: boolean;
        "squaredLeft"?: boolean;
        "squaredRight"?: boolean;
        "squaredTop"?: boolean;
        /**
          * Can we unselect items.
         */
        "unselect"?: boolean;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ScSessionProvider {
        "onScPaid"?: (event: ScSessionProviderCustomEvent<void>) => void;
        /**
          * Set the state
         */
        "onScSetState"?: (event: ScSessionProviderCustomEvent<FormStateSetter>) => void;
        /**
          * Update line items event
         */
        "onScUpdateDraftState"?: (event: ScSessionProviderCustomEvent<Checkout>) => void;
        /**
          * Update line items event
         */
        "onScUpdateOrderState"?: (event: ScSessionProviderCustomEvent<Checkout>) => void;
        /**
          * Should we persist the session.
         */
        "persist"?: boolean;
        /**
          * An array of prices to pre-fill in the form.
         */
        "prices"?: Array<PriceChoice>;
    }
    interface ScShippingChoices {
        /**
          * The shipping section label
         */
        "label"?: string;
        /**
          * Whether to show the shipping choice description
         */
        "showDescription"?: boolean;
    }
    interface ScSkeleton {
        /**
          * Animation effect
         */
        "effect"?: 'pulse' | 'sheen' | 'none';
    }
    interface ScSpacing {
    }
    interface ScSpinner {
    }
    interface ScStackedList {
    }
    interface ScStackedListRow {
        "href"?: string;
        "mobileSize"?: number;
        "target"?: string;
    }
    interface ScStripeAddMethod {
        "customerId"?: string;
        "liveMode"?: boolean;
        "successUrl"?: string;
    }
    interface ScStripeElement {
        /**
          * Whether this field is disabled
         */
        "disabled"?: boolean;
        /**
          * The form state
         */
        "formState"?: FormState;
        /**
          * Inputs focus
         */
        "hasFocus"?: boolean;
        /**
          * The input's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * Mode for the payment
         */
        "mode"?: 'live' | 'test';
        /**
          * The order/invoice was paid for
         */
        "onScPaid"?: (event: ScStripeElementCustomEvent<void>) => void;
        /**
          * Payment information was added
         */
        "onScPaymentInfoAdded"?: (event: ScStripeElementCustomEvent<PaymentInfoAddedParams>) => void;
        /**
          * Set the state
         */
        "onScSetState"?: (event: ScStripeElementCustomEvent<FormStateSetter>) => void;
        /**
          * The checkout session object for finalizing intents
         */
        "order"?: Checkout;
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "secureText"?: string;
        /**
          * The selected processor id
         */
        "selectedProcessorId"?: ProcessorName;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
    }
    interface ScStripePaymentElement {
        /**
          * The order/invoice was paid for.
         */
        "onScPaid"?: (event: ScStripePaymentElementCustomEvent<void>) => void;
        /**
          * Payment information was added
         */
        "onScPaymentInfoAdded"?: (event: ScStripePaymentElementCustomEvent<PaymentInfoAddedParams>) => void;
        /**
          * Set the state
         */
        "onScSetState"?: (event: ScStripePaymentElementCustomEvent<FormStateSetter>) => void;
    }
    interface ScStripePaymentRequest {
        /**
          * Amount
         */
        "amount"?: number;
        /**
          * Country
         */
        "country"?: string;
        /**
          * Is this in debug mode.
         */
        "debug"?: boolean;
        "error"?: ResponseError | null;
        /**
          * Label
         */
        "label"?: string;
        "onScFormSubmit"?: (event: ScStripePaymentRequestCustomEvent<any>) => void;
        "onScPaid"?: (event: ScStripePaymentRequestCustomEvent<void>) => void;
        "onScPayError"?: (event: ScStripePaymentRequestCustomEvent<any>) => void;
        "onScPaymentRequestLoaded"?: (event: ScStripePaymentRequestCustomEvent<boolean>) => void;
        "onScSetState"?: (event: ScStripePaymentRequestCustomEvent<string>) => void;
        "onScUpdateOrderState"?: (event: ScStripePaymentRequestCustomEvent<any>) => void;
        /**
          * Prices
         */
        "prices"?: Prices;
        /**
          * Stripe publishable key
         */
        "publishableKey"?: string;
        /**
          * Your stripe connected account id.
         */
        "stripeAccountId"?: string;
        /**
          * Payment request theme
         */
        "theme"?: string;
    }
    interface ScSubscription {
        /**
          * Heading to display
         */
        "heading"?: string;
        /**
          * The subscription protocol
         */
        "protocol"?: SubscriptionProtocol;
        /**
          * Query to pass to the API
         */
        "query"?: object;
        /**
          * Whether to show the cancel button
         */
        "showCancel"?: boolean;
        /**
          * The subscription
         */
        "subscription"?: Subscription;
        /**
          * The subscription ID
         */
        "subscriptionId"?: string;
        /**
          * Update the payment method url
         */
        "updatePaymentMethodUrl"?: string;
    }
    interface ScSubscriptionAdHocConfirm {
        "heading"?: string;
        "price"?: Price;
    }
    interface ScSubscriptionCancel {
        "backUrl"?: string;
        "comment"?: string;
        "heading"?: string;
        "onScAbandon"?: (event: ScSubscriptionCancelCustomEvent<void>) => void;
        "onScCancelled"?: (event: ScSubscriptionCancelCustomEvent<void>) => void;
        "protocol"?: SubscriptionProtocol;
        "reason"?: CancellationReason;
        "subscription"?: Subscription;
        "successUrl"?: string;
    }
    interface ScSubscriptionDetails {
        "hideRenewalText"?: boolean;
        "pendingPrice"?: Price;
        "subscription"?: Subscription;
    }
    interface ScSubscriptionNextPayment {
        "subscription"?: Subscription;
        /**
          * Update the payment method url
         */
        "updatePaymentMethodUrl"?: string;
    }
    interface ScSubscriptionPayment {
        "backUrl"?: string;
        "customerIds"?: Array<string>;
        "paymentMethods"?: Array<PaymentMethod>;
        "subscription"?: Subscription;
        "subscriptionId"?: string;
        "successUrl"?: string;
    }
    interface ScSubscriptionPaymentMethod {
        /**
          * The heading
         */
        "heading"?: string;
        /**
          * The subscription
         */
        "subscription"?: Subscription;
    }
    interface ScSubscriptionReactivate {
        /**
          * Refresh subscriptions
         */
        "onScRefresh"?: (event: ScSubscriptionReactivateCustomEvent<void>) => void;
        /**
          * Reactivate modal closed
         */
        "onScRequestClose"?: (event: ScSubscriptionReactivateCustomEvent<'close-button' | 'keyboard' | 'overlay'>) => void;
        /**
          * Whether it is open
         */
        "open"?: boolean;
        /**
          * The subscription to reactivate
         */
        "subscription"?: Subscription;
    }
    interface ScSubscriptionStatusBadge {
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Subscription status
         */
        "status"?: SubscriptionStatus;
        /**
          * The tag's status type.
         */
        "subscription"?: Subscription;
    }
    interface ScSubscriptionSwitch {
        "filterAbove"?: number;
        "heading"?: string;
        "productGroupId"?: ProductGroup;
        "productId"?: string;
        /**
          * Customer id to fetch subscriptions
         */
        "query"?: object;
        "subscription"?: Subscription;
        "successUrl"?: string;
    }
    interface ScSubscriptionVariationConfirm {
        "heading"?: string;
        "price"?: Price;
        "product"?: Product;
        "subscription"?: Subscription;
    }
    interface ScSubscriptionsList {
        "allLink"?: string;
        "cancelBehavior"?: 'period_end' | 'immediate';
        "heading"?: string;
        "isCustomer"?: boolean;
        /**
          * Customer id to fetch subscriptions
         */
        "query"?: {
    page: number;
    per_page: number;
  };
    }
    interface ScSummary {
        "busy"?: boolean;
        "closedText"?: string;
        "collapsed"?: boolean;
        "collapsedOnDesktop"?: boolean;
        "collapsedOnMobile"?: boolean;
        "collapsible"?: boolean;
        "loading"?: boolean;
        /**
          * Show the toggle
         */
        "onScHide"?: (event: ScSummaryCustomEvent<void>) => void;
        /**
          * Show the toggle
         */
        "onScShow"?: (event: ScSummaryCustomEvent<void>) => void;
        "openText"?: string;
    }
    interface ScSwitch {
        /**
          * Draws the switch in a checked state.
         */
        "checked"?: boolean;
        /**
          * Disables the switch.
         */
        "disabled"?: boolean;
        /**
          * This will be true as a workaround in the block editor to focus on the content.
         */
        "edit"?: boolean;
        /**
          * This will be true when the control is in an invalid state. Validity is determined by the `required` prop.
         */
        "invalid"?: boolean;
        /**
          * The switch's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onScBlur"?: (event: ScSwitchCustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onScChange"?: (event: ScSwitchCustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onScFocus"?: (event: ScSwitchCustomEvent<void>) => void;
        /**
          * Makes the switch a required field.
         */
        "required"?: boolean;
        "reversed"?: boolean;
        /**
          * The switch's value attribute.
         */
        "value"?: string;
    }
    interface ScTab {
        /**
          * Draws the tab in an active state.
         */
        "active"?: boolean;
        "count"?: string;
        /**
          * Draws the tab in a disabled state.
         */
        "disabled"?: boolean;
        "href"?: string;
        /**
          * Close event
         */
        "onScClose"?: (event: ScTabCustomEvent<void>) => void;
        /**
          * The name of the tab panel the tab will control. The panel must be located in the same tab group.
         */
        "panel"?: string;
    }
    interface ScTabGroup {
        "onScTabHide"?: (event: ScTabGroupCustomEvent<string>) => void;
        "onScTabShow"?: (event: ScTabGroupCustomEvent<string>) => void;
    }
    interface ScTabPanel {
        /**
          * When true, the tab panel will be shown.
         */
        "active"?: boolean;
        /**
          * The tab panel's name.
         */
        "name"?: string;
    }
    interface ScTable {
    }
    interface ScTableCell {
    }
    interface ScTableHead {
    }
    interface ScTableRow {
        "href"?: string;
    }
    interface ScTag {
        /**
          * Aria label
         */
        "ariaLabel"?: string;
        /**
          * Makes the tag clearable.
         */
        "clearable"?: boolean;
        "onScClear"?: (event: ScTagCustomEvent<ScTag>) => void;
        /**
          * Draws a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'default';
    }
    interface ScTaxIdInput {
        /**
          * AU zone label
         */
        "auAbnLabel"?: string;
        /**
          * GST zone label
         */
        "caGstLabel"?: string;
        /**
          * The country code.
         */
        "country"?: string;
        /**
          * EU zone label
         */
        "euVatLabel"?: string;
        /**
          * UK zone label
         */
        "gbVatLabel"?: string;
        /**
          * Help text.
         */
        "help"?: string;
        /**
          * Is this loading?
         */
        "loading"?: boolean;
        /**
          * Tax ID Number
         */
        "number"?: string;
        /**
          * Make a request to update the order.
         */
        "onScChange"?: (event: ScTaxIdInputCustomEvent<{ number: string; number_type: string }>) => void;
        /**
          * Make a request to update the order.
         */
        "onScInput"?: (event: ScTaxIdInputCustomEvent<Partial<{ number: string; number_type: string }>>) => void;
        /**
          * Change the Type
         */
        "onScInputType"?: (event: ScTaxIdInputCustomEvent<string>) => void;
        /**
          * Set the checkout state.
         */
        "onScSetState"?: (event: ScTaxIdInputCustomEvent<string>) => void;
        /**
          * Other zones label
         */
        "otherLabel"?: string;
        /**
          * Whether tax input is required
         */
        "required"?: boolean;
        /**
          * Force show the field.
         */
        "show"?: boolean;
        /**
          * The status
         */
        "status"?: 'valid' | 'invalid' | 'unknown';
        /**
          * Tax ID Types which will be shown
         */
        "taxIdTypes"?: string[];
        /**
          * Type of tax id
         */
        "type"?: string;
    }
    interface ScText {
        "tag"?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p';
        "truncate"?: boolean;
    }
    interface ScTextarea {
        /**
          * The textarea's autocapitalize attribute.
         */
        "autocapitalize"?: 'off' | 'none' | 'on' | 'sentences' | 'words' | 'characters';
        /**
          * The textarea's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The textarea's autocorrect attribute.
         */
        "autocorrect"?: string;
        /**
          * The textarea's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Disables the textarea.
         */
        "disabled"?: boolean;
        /**
          * The input's enterkeyhint attribute. This can be used to customize the label or icon of the Enter key on virtual keyboards.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * Draws a filled textarea.
         */
        "filled"?: boolean;
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "help"?: string;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * This will be true when the control is in an invalid state. Validity is determined by props such as `type`, `required`, `minlength`, and `maxlength` using the browser's constraint validation API.
         */
        "invalid"?: boolean;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength"?: number;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength"?: number;
        /**
          * The textarea's name attribute.
         */
        "name"?: string;
        "onScBlur"?: (event: ScTextareaCustomEvent<void>) => void;
        "onScChange"?: (event: ScTextareaCustomEvent<void>) => void;
        "onScFocus"?: (event: ScTextareaCustomEvent<void>) => void;
        "onScInput"?: (event: ScTextareaCustomEvent<void>) => void;
        /**
          * The textarea's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Makes the textarea readonly.
         */
        "readonly"?: boolean;
        /**
          * Makes the textarea a required field.
         */
        "required"?: boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize"?: 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows"?: number;
        /**
          * Should we show the label
         */
        "showLabel"?: boolean;
        /**
          * The textarea's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Enables spell checking on the textarea.
         */
        "spellcheck"?: boolean;
        /**
          * The textarea's value attribute.
         */
        "value"?: string;
    }
    interface ScToggle {
        /**
          * Is this a borderless toggle?
         */
        "borderless"?: boolean;
        /**
          * Are these collapsible?
         */
        "collapsible"?: boolean;
        /**
          * Disables the details so it can't be toggled.
         */
        "disabled"?: boolean;
        /**
          * Show the toggle
         */
        "onScHide"?: (event: ScToggleCustomEvent<void>) => void;
        /**
          * Show the toggle
         */
        "onScShow"?: (event: ScToggleCustomEvent<void>) => void;
        /**
          * Indicates whether or not the details is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * Is this a shady
         */
        "shady"?: boolean;
        /**
          * Should we show a radio control?
         */
        "showControl"?: boolean;
        /**
          * Should we show the arrow icon?
         */
        "showIcon"?: boolean;
        /**
          * The summary to show in the details header. If you need to display HTML, use the `summary` slot instead.
         */
        "summary"?: string;
    }
    interface ScToggles {
        /**
          * Should this function as an accordion?
         */
        "accordion"?: boolean;
        /**
          * Are these collapsible?
         */
        "collapsible"?: boolean;
        /**
          * Theme for the toggles
         */
        "theme"?: 'default' | 'container';
    }
    interface ScTooltip {
        /**
          * Freeze open or closed.
         */
        "freeze"?: boolean;
        /**
          * Open or not
         */
        "open"?: boolean;
        /**
          * The tooltip's padding.
         */
        "padding"?: number;
        /**
          * Tooltip text
         */
        "text"?: string;
        /**
          * The tooltip's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text';
        /**
          * Tooltip fixed width
         */
        "width"?: string;
    }
    interface ScTotal {
        "order"?: Checkout;
        "total"?: 'total' | 'subtotal' | 'amount_due';
    }
    interface ScUpcomingInvoice {
        "adHocAmount"?: number;
        "discount"?: {
    promotion_code?: string;
    coupon?: string;
  };
        "heading"?: string;
        "payment_method"?: PaymentMethod;
        "priceId"?: string;
        "quantity"?: number;
        "quantityUpdatesEnabled"?: boolean;
        "subscriptionId"?: string;
        "successUrl"?: string;
        "variantId"?: string;
    }
    interface ScUpgradeRequired {
        /**
          * Whether to render upgrade modal by default
         */
        "open"?: boolean;
        /**
          * Is this required?
         */
        "required"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
    }
    interface ScUpsell {
    }
    interface ScUpsellCountdownTimer {
        /**
          * Whether to show the icon.
         */
        "showIcon"?: boolean;
    }
    interface ScUpsellNoThanksButton {
    }
    interface ScUpsellSubmitButton {
    }
    interface ScUpsellTotals {
    }
    interface ScVisuallyHidden {
    }
    interface ScWordpressPasswordEdit {
        /**
          * Ensures strong password validation.
         */
        "enableValidation"?: boolean;
        "heading"?: string;
        "successUrl"?: string;
        "user"?: WordPressUser;
    }
    interface ScWordpressUser {
        "heading"?: string;
        "user"?: WordPressUser;
    }
    interface ScWordpressUserEdit {
        "heading"?: string;
        "successUrl"?: string;
        "user"?: WordPressUser;
    }
    interface IntrinsicElements {
        "sc-address": ScAddress;
        "sc-alert": ScAlert;
        "sc-avatar": ScAvatar;
        "sc-badge-notice": ScBadgeNotice;
        "sc-block-ui": ScBlockUi;
        "sc-breadcrumb": ScBreadcrumb;
        "sc-breadcrumbs": ScBreadcrumbs;
        "sc-button": ScButton;
        "sc-button-group": ScButtonGroup;
        "sc-cancel-dialog": ScCancelDialog;
        "sc-cancel-discount": ScCancelDiscount;
        "sc-cancel-survey": ScCancelSurvey;
        "sc-card": ScCard;
        "sc-cart": ScCart;
        "sc-cart-button": ScCartButton;
        "sc-cart-form": ScCartForm;
        "sc-cart-form-submit": ScCartFormSubmit;
        "sc-cart-header": ScCartHeader;
        "sc-cart-icon": ScCartIcon;
        "sc-cart-loader": ScCartLoader;
        "sc-cart-session-provider": ScCartSessionProvider;
        "sc-cart-submit": ScCartSubmit;
        "sc-cc-logo": ScCcLogo;
        "sc-charges-list": ScChargesList;
        "sc-checkbox": ScCheckbox;
        "sc-checkout": ScCheckout;
        "sc-checkout-form-errors": ScCheckoutFormErrors;
        "sc-checkout-mollie-payment": ScCheckoutMolliePayment;
        "sc-checkout-paystack-payment-provider": ScCheckoutPaystackPaymentProvider;
        "sc-checkout-product-price-variant-selector": ScCheckoutProductPriceVariantSelector;
        "sc-checkout-stock-alert": ScCheckoutStockAlert;
        "sc-checkout-test-complete": ScCheckoutTestComplete;
        "sc-checkout-unsaved-changes-warning": ScCheckoutUnsavedChangesWarning;
        "sc-choice": ScChoice;
        "sc-choice-container": ScChoiceContainer;
        "sc-choices": ScChoices;
        "sc-column": ScColumn;
        "sc-columns": ScColumns;
        "sc-compact-address": ScCompactAddress;
        "sc-conditional-form": ScConditionalForm;
        "sc-consumer": ScConsumer;
        "sc-coupon-form": ScCouponForm;
        "sc-custom-order-price-input": ScCustomOrderPriceInput;
        "sc-customer-details": ScCustomerDetails;
        "sc-customer-edit": ScCustomerEdit;
        "sc-customer-email": ScCustomerEmail;
        "sc-customer-firstname": ScCustomerFirstname;
        "sc-customer-lastname": ScCustomerLastname;
        "sc-customer-name": ScCustomerName;
        "sc-customer-phone": ScCustomerPhone;
        "sc-dashboard-customer-details": ScDashboardCustomerDetails;
        "sc-dashboard-downloads-list": ScDashboardDownloadsList;
        "sc-dashboard-module": ScDashboardModule;
        "sc-dialog": ScDialog;
        "sc-divider": ScDivider;
        "sc-donation-choices": ScDonationChoices;
        "sc-downloads-list": ScDownloadsList;
        "sc-drawer": ScDrawer;
        "sc-dropdown": ScDropdown;
        "sc-empty": ScEmpty;
        "sc-error": ScError;
        "sc-express-payment": ScExpressPayment;
        "sc-feature-demo-banner": ScFeatureDemoBanner;
        "sc-flex": ScFlex;
        "sc-form": ScForm;
        "sc-form-components-validator": ScFormComponentsValidator;
        "sc-form-control": ScFormControl;
        "sc-form-error-provider": ScFormErrorProvider;
        "sc-form-row": ScFormRow;
        "sc-form-state-provider": ScFormStateProvider;
        "sc-format-bytes": ScFormatBytes;
        "sc-format-interval": ScFormatInterval;
        "sc-format-number": ScFormatNumber;
        "sc-fulfillment-shipping-status-badge": ScFulfillmentShippingStatusBadge;
        "sc-fulfillments": ScFulfillments;
        "sc-heading": ScHeading;
        "sc-icon": ScIcon;
        "sc-image-slider": ScImageSlider;
        "sc-input": ScInput;
        "sc-invoice-details": ScInvoiceDetails;
        "sc-invoice-memo": ScInvoiceMemo;
        "sc-invoice-status-badge": ScInvoiceStatusBadge;
        "sc-invoices-list": ScInvoicesList;
        "sc-license": ScLicense;
        "sc-licenses-list": ScLicensesList;
        "sc-line-item": ScLineItem;
        "sc-line-item-bump": ScLineItemBump;
        "sc-line-item-invoice-due-date": ScLineItemInvoiceDueDate;
        "sc-line-item-invoice-number": ScLineItemInvoiceNumber;
        "sc-line-item-invoice-receipt-download": ScLineItemInvoiceReceiptDownload;
        "sc-line-item-shipping": ScLineItemShipping;
        "sc-line-item-tax": ScLineItemTax;
        "sc-line-item-total": ScLineItemTotal;
        "sc-line-item-trial": ScLineItemTrial;
        "sc-line-items": ScLineItems;
        "sc-line-items-provider": ScLineItemsProvider;
        "sc-login-form": ScLoginForm;
        "sc-login-provider": ScLoginProvider;
        "sc-manual-payment-method": ScManualPaymentMethod;
        "sc-menu": ScMenu;
        "sc-menu-divider": ScMenuDivider;
        "sc-menu-item": ScMenuItem;
        "sc-menu-label": ScMenuLabel;
        "sc-mollie-add-method": ScMollieAddMethod;
        "sc-order": ScOrder;
        "sc-order-billing-address": ScOrderBillingAddress;
        "sc-order-bump": ScOrderBump;
        "sc-order-bumps": ScOrderBumps;
        "sc-order-confirm-components-validator": ScOrderConfirmComponentsValidator;
        "sc-order-confirm-provider": ScOrderConfirmProvider;
        "sc-order-confirmation": ScOrderConfirmation;
        "sc-order-confirmation-customer": ScOrderConfirmationCustomer;
        "sc-order-confirmation-details": ScOrderConfirmationDetails;
        "sc-order-confirmation-line-items": ScOrderConfirmationLineItems;
        "sc-order-confirmation-totals": ScOrderConfirmationTotals;
        "sc-order-coupon-form": ScOrderCouponForm;
        "sc-order-detail": ScOrderDetail;
        "sc-order-fulfillment-badge": ScOrderFulfillmentBadge;
        "sc-order-manual-instructions": ScOrderManualInstructions;
        "sc-order-password": ScOrderPassword;
        "sc-order-return-badge": ScOrderReturnBadge;
        "sc-order-shipment-badge": ScOrderShipmentBadge;
        "sc-order-shipping-address": ScOrderShippingAddress;
        "sc-order-status-badge": ScOrderStatusBadge;
        "sc-order-submit": ScOrderSubmit;
        "sc-order-summary": ScOrderSummary;
        "sc-order-tax-id-input": ScOrderTaxIdInput;
        "sc-orders-list": ScOrdersList;
        "sc-pagination": ScPagination;
        "sc-password": ScPassword;
        "sc-password-nag": ScPasswordNag;
        "sc-payment": ScPayment;
        "sc-payment-method": ScPaymentMethod;
        "sc-payment-method-choice": ScPaymentMethodChoice;
        "sc-payment-method-details": ScPaymentMethodDetails;
        "sc-payment-methods-list": ScPaymentMethodsList;
        "sc-payment-selected": ScPaymentSelected;
        "sc-paypal-add-method": ScPaypalAddMethod;
        "sc-paypal-buttons": ScPaypalButtons;
        "sc-paystack-add-method": ScPaystackAddMethod;
        "sc-phone-input": ScPhoneInput;
        "sc-pill-option": ScPillOption;
        "sc-premium-tag": ScPremiumTag;
        "sc-price": ScPrice;
        "sc-price-choice": ScPriceChoice;
        "sc-price-choice-container": ScPriceChoiceContainer;
        "sc-price-choices": ScPriceChoices;
        "sc-price-input": ScPriceInput;
        "sc-price-range": ScPriceRange;
        "sc-product-buy-button": ScProductBuyButton;
        "sc-product-donation-amount-choice": ScProductDonationAmountChoice;
        "sc-product-donation-choices": ScProductDonationChoices;
        "sc-product-donation-custom-amount": ScProductDonationCustomAmount;
        "sc-product-item": ScProductItem;
        "sc-product-item-image": ScProductItemImage;
        "sc-product-item-list": ScProductItemList;
        "sc-product-item-price": ScProductItemPrice;
        "sc-product-item-title": ScProductItemTitle;
        "sc-product-line-item": ScProductLineItem;
        "sc-product-pills-variant-option": ScProductPillsVariantOption;
        "sc-product-price": ScProductPrice;
        "sc-product-price-choices": ScProductPriceChoices;
        "sc-product-price-modal": ScProductPriceModal;
        "sc-product-quantity": ScProductQuantity;
        "sc-product-selected-price": ScProductSelectedPrice;
        "sc-product-text": ScProductText;
        "sc-prose": ScProse;
        "sc-provider": ScProvider;
        "sc-provisional-banner": ScProvisionalBanner;
        "sc-purchase-downloads-list": ScPurchaseDownloadsList;
        "sc-quantity-select": ScQuantitySelect;
        "sc-radio": ScRadio;
        "sc-radio-group": ScRadioGroup;
        "sc-recurring-price-choice-container": ScRecurringPriceChoiceContainer;
        "sc-rich-text": ScRichText;
        "sc-secure-notice": ScSecureNotice;
        "sc-select": ScSelect;
        "sc-session-provider": ScSessionProvider;
        "sc-shipping-choices": ScShippingChoices;
        "sc-skeleton": ScSkeleton;
        "sc-spacing": ScSpacing;
        "sc-spinner": ScSpinner;
        "sc-stacked-list": ScStackedList;
        "sc-stacked-list-row": ScStackedListRow;
        "sc-stripe-add-method": ScStripeAddMethod;
        "sc-stripe-element": ScStripeElement;
        "sc-stripe-payment-element": ScStripePaymentElement;
        "sc-stripe-payment-request": ScStripePaymentRequest;
        "sc-subscription": ScSubscription;
        "sc-subscription-ad-hoc-confirm": ScSubscriptionAdHocConfirm;
        "sc-subscription-cancel": ScSubscriptionCancel;
        "sc-subscription-details": ScSubscriptionDetails;
        "sc-subscription-next-payment": ScSubscriptionNextPayment;
        "sc-subscription-payment": ScSubscriptionPayment;
        "sc-subscription-payment-method": ScSubscriptionPaymentMethod;
        "sc-subscription-reactivate": ScSubscriptionReactivate;
        "sc-subscription-status-badge": ScSubscriptionStatusBadge;
        "sc-subscription-switch": ScSubscriptionSwitch;
        "sc-subscription-variation-confirm": ScSubscriptionVariationConfirm;
        "sc-subscriptions-list": ScSubscriptionsList;
        "sc-summary": ScSummary;
        "sc-switch": ScSwitch;
        "sc-tab": ScTab;
        "sc-tab-group": ScTabGroup;
        "sc-tab-panel": ScTabPanel;
        "sc-table": ScTable;
        "sc-table-cell": ScTableCell;
        "sc-table-head": ScTableHead;
        "sc-table-row": ScTableRow;
        "sc-tag": ScTag;
        "sc-tax-id-input": ScTaxIdInput;
        "sc-text": ScText;
        "sc-textarea": ScTextarea;
        "sc-toggle": ScToggle;
        "sc-toggles": ScToggles;
        "sc-tooltip": ScTooltip;
        "sc-total": ScTotal;
        "sc-upcoming-invoice": ScUpcomingInvoice;
        "sc-upgrade-required": ScUpgradeRequired;
        "sc-upsell": ScUpsell;
        "sc-upsell-countdown-timer": ScUpsellCountdownTimer;
        "sc-upsell-no-thanks-button": ScUpsellNoThanksButton;
        "sc-upsell-submit-button": ScUpsellSubmitButton;
        "sc-upsell-totals": ScUpsellTotals;
        "sc-visually-hidden": ScVisuallyHidden;
        "sc-wordpress-password-edit": ScWordpressPasswordEdit;
        "sc-wordpress-user": ScWordpressUser;
        "sc-wordpress-user-edit": ScWordpressUserEdit;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "sc-address": LocalJSX.ScAddress & JSXBase.HTMLAttributes<HTMLScAddressElement>;
            "sc-alert": LocalJSX.ScAlert & JSXBase.HTMLAttributes<HTMLScAlertElement>;
            "sc-avatar": LocalJSX.ScAvatar & JSXBase.HTMLAttributes<HTMLScAvatarElement>;
            "sc-badge-notice": LocalJSX.ScBadgeNotice & JSXBase.HTMLAttributes<HTMLScBadgeNoticeElement>;
            "sc-block-ui": LocalJSX.ScBlockUi & JSXBase.HTMLAttributes<HTMLScBlockUiElement>;
            "sc-breadcrumb": LocalJSX.ScBreadcrumb & JSXBase.HTMLAttributes<HTMLScBreadcrumbElement>;
            "sc-breadcrumbs": LocalJSX.ScBreadcrumbs & JSXBase.HTMLAttributes<HTMLScBreadcrumbsElement>;
            "sc-button": LocalJSX.ScButton & JSXBase.HTMLAttributes<HTMLScButtonElement>;
            "sc-button-group": LocalJSX.ScButtonGroup & JSXBase.HTMLAttributes<HTMLScButtonGroupElement>;
            "sc-cancel-dialog": LocalJSX.ScCancelDialog & JSXBase.HTMLAttributes<HTMLScCancelDialogElement>;
            "sc-cancel-discount": LocalJSX.ScCancelDiscount & JSXBase.HTMLAttributes<HTMLScCancelDiscountElement>;
            "sc-cancel-survey": LocalJSX.ScCancelSurvey & JSXBase.HTMLAttributes<HTMLScCancelSurveyElement>;
            "sc-card": LocalJSX.ScCard & JSXBase.HTMLAttributes<HTMLScCardElement>;
            "sc-cart": LocalJSX.ScCart & JSXBase.HTMLAttributes<HTMLScCartElement>;
            "sc-cart-button": LocalJSX.ScCartButton & JSXBase.HTMLAttributes<HTMLScCartButtonElement>;
            "sc-cart-form": LocalJSX.ScCartForm & JSXBase.HTMLAttributes<HTMLScCartFormElement>;
            "sc-cart-form-submit": LocalJSX.ScCartFormSubmit & JSXBase.HTMLAttributes<HTMLScCartFormSubmitElement>;
            "sc-cart-header": LocalJSX.ScCartHeader & JSXBase.HTMLAttributes<HTMLScCartHeaderElement>;
            "sc-cart-icon": LocalJSX.ScCartIcon & JSXBase.HTMLAttributes<HTMLScCartIconElement>;
            "sc-cart-loader": LocalJSX.ScCartLoader & JSXBase.HTMLAttributes<HTMLScCartLoaderElement>;
            "sc-cart-session-provider": LocalJSX.ScCartSessionProvider & JSXBase.HTMLAttributes<HTMLScCartSessionProviderElement>;
            "sc-cart-submit": LocalJSX.ScCartSubmit & JSXBase.HTMLAttributes<HTMLScCartSubmitElement>;
            "sc-cc-logo": LocalJSX.ScCcLogo & JSXBase.HTMLAttributes<HTMLScCcLogoElement>;
            "sc-charges-list": LocalJSX.ScChargesList & JSXBase.HTMLAttributes<HTMLScChargesListElement>;
            "sc-checkbox": LocalJSX.ScCheckbox & JSXBase.HTMLAttributes<HTMLScCheckboxElement>;
            "sc-checkout": LocalJSX.ScCheckout & JSXBase.HTMLAttributes<HTMLScCheckoutElement>;
            /**
             * This component listens for a confirmed event and redirects to the success url.
             */
            "sc-checkout-form-errors": LocalJSX.ScCheckoutFormErrors & JSXBase.HTMLAttributes<HTMLScCheckoutFormErrorsElement>;
            "sc-checkout-mollie-payment": LocalJSX.ScCheckoutMolliePayment & JSXBase.HTMLAttributes<HTMLScCheckoutMolliePaymentElement>;
            "sc-checkout-paystack-payment-provider": LocalJSX.ScCheckoutPaystackPaymentProvider & JSXBase.HTMLAttributes<HTMLScCheckoutPaystackPaymentProviderElement>;
            "sc-checkout-product-price-variant-selector": LocalJSX.ScCheckoutProductPriceVariantSelector & JSXBase.HTMLAttributes<HTMLScCheckoutProductPriceVariantSelectorElement>;
            /**
             * This component listens for stock requirements and displays a dialog to the user.
             */
            "sc-checkout-stock-alert": LocalJSX.ScCheckoutStockAlert & JSXBase.HTMLAttributes<HTMLScCheckoutStockAlertElement>;
            /**
             * This component listens to the order status
             * and confirms the order when payment is successful.
             */
            "sc-checkout-test-complete": LocalJSX.ScCheckoutTestComplete & JSXBase.HTMLAttributes<HTMLScCheckoutTestCompleteElement>;
            "sc-checkout-unsaved-changes-warning": LocalJSX.ScCheckoutUnsavedChangesWarning & JSXBase.HTMLAttributes<HTMLScCheckoutUnsavedChangesWarningElement>;
            "sc-choice": LocalJSX.ScChoice & JSXBase.HTMLAttributes<HTMLScChoiceElement>;
            "sc-choice-container": LocalJSX.ScChoiceContainer & JSXBase.HTMLAttributes<HTMLScChoiceContainerElement>;
            "sc-choices": LocalJSX.ScChoices & JSXBase.HTMLAttributes<HTMLScChoicesElement>;
            "sc-column": LocalJSX.ScColumn & JSXBase.HTMLAttributes<HTMLScColumnElement>;
            "sc-columns": LocalJSX.ScColumns & JSXBase.HTMLAttributes<HTMLScColumnsElement>;
            "sc-compact-address": LocalJSX.ScCompactAddress & JSXBase.HTMLAttributes<HTMLScCompactAddressElement>;
            "sc-conditional-form": LocalJSX.ScConditionalForm & JSXBase.HTMLAttributes<HTMLScConditionalFormElement>;
            "sc-consumer": LocalJSX.ScConsumer & JSXBase.HTMLAttributes<HTMLScConsumerElement>;
            "sc-coupon-form": LocalJSX.ScCouponForm & JSXBase.HTMLAttributes<HTMLScCouponFormElement>;
            "sc-custom-order-price-input": LocalJSX.ScCustomOrderPriceInput & JSXBase.HTMLAttributes<HTMLScCustomOrderPriceInputElement>;
            "sc-customer-details": LocalJSX.ScCustomerDetails & JSXBase.HTMLAttributes<HTMLScCustomerDetailsElement>;
            "sc-customer-edit": LocalJSX.ScCustomerEdit & JSXBase.HTMLAttributes<HTMLScCustomerEditElement>;
            "sc-customer-email": LocalJSX.ScCustomerEmail & JSXBase.HTMLAttributes<HTMLScCustomerEmailElement>;
            "sc-customer-firstname": LocalJSX.ScCustomerFirstname & JSXBase.HTMLAttributes<HTMLScCustomerFirstnameElement>;
            "sc-customer-lastname": LocalJSX.ScCustomerLastname & JSXBase.HTMLAttributes<HTMLScCustomerLastnameElement>;
            "sc-customer-name": LocalJSX.ScCustomerName & JSXBase.HTMLAttributes<HTMLScCustomerNameElement>;
            "sc-customer-phone": LocalJSX.ScCustomerPhone & JSXBase.HTMLAttributes<HTMLScCustomerPhoneElement>;
            "sc-dashboard-customer-details": LocalJSX.ScDashboardCustomerDetails & JSXBase.HTMLAttributes<HTMLScDashboardCustomerDetailsElement>;
            "sc-dashboard-downloads-list": LocalJSX.ScDashboardDownloadsList & JSXBase.HTMLAttributes<HTMLScDashboardDownloadsListElement>;
            "sc-dashboard-module": LocalJSX.ScDashboardModule & JSXBase.HTMLAttributes<HTMLScDashboardModuleElement>;
            "sc-dialog": LocalJSX.ScDialog & JSXBase.HTMLAttributes<HTMLScDialogElement>;
            "sc-divider": LocalJSX.ScDivider & JSXBase.HTMLAttributes<HTMLScDividerElement>;
            "sc-donation-choices": LocalJSX.ScDonationChoices & JSXBase.HTMLAttributes<HTMLScDonationChoicesElement>;
            "sc-downloads-list": LocalJSX.ScDownloadsList & JSXBase.HTMLAttributes<HTMLScDownloadsListElement>;
            "sc-drawer": LocalJSX.ScDrawer & JSXBase.HTMLAttributes<HTMLScDrawerElement>;
            "sc-dropdown": LocalJSX.ScDropdown & JSXBase.HTMLAttributes<HTMLScDropdownElement>;
            "sc-empty": LocalJSX.ScEmpty & JSXBase.HTMLAttributes<HTMLScEmptyElement>;
            "sc-error": LocalJSX.ScError & JSXBase.HTMLAttributes<HTMLScErrorElement>;
            "sc-express-payment": LocalJSX.ScExpressPayment & JSXBase.HTMLAttributes<HTMLScExpressPaymentElement>;
            "sc-feature-demo-banner": LocalJSX.ScFeatureDemoBanner & JSXBase.HTMLAttributes<HTMLScFeatureDemoBannerElement>;
            "sc-flex": LocalJSX.ScFlex & JSXBase.HTMLAttributes<HTMLScFlexElement>;
            "sc-form": LocalJSX.ScForm & JSXBase.HTMLAttributes<HTMLScFormElement>;
            "sc-form-components-validator": LocalJSX.ScFormComponentsValidator & JSXBase.HTMLAttributes<HTMLScFormComponentsValidatorElement>;
            "sc-form-control": LocalJSX.ScFormControl & JSXBase.HTMLAttributes<HTMLScFormControlElement>;
            /**
             * This component checks to make sure there is an error component
             * and adds one if it's missing.
             */
            "sc-form-error-provider": LocalJSX.ScFormErrorProvider & JSXBase.HTMLAttributes<HTMLScFormErrorProviderElement>;
            "sc-form-row": LocalJSX.ScFormRow & JSXBase.HTMLAttributes<HTMLScFormRowElement>;
            /**
             * This component listens for a confirmed event and redirects to the success url.
             */
            "sc-form-state-provider": LocalJSX.ScFormStateProvider & JSXBase.HTMLAttributes<HTMLScFormStateProviderElement>;
            "sc-format-bytes": LocalJSX.ScFormatBytes & JSXBase.HTMLAttributes<HTMLScFormatBytesElement>;
            "sc-format-interval": LocalJSX.ScFormatInterval & JSXBase.HTMLAttributes<HTMLScFormatIntervalElement>;
            "sc-format-number": LocalJSX.ScFormatNumber & JSXBase.HTMLAttributes<HTMLScFormatNumberElement>;
            "sc-fulfillment-shipping-status-badge": LocalJSX.ScFulfillmentShippingStatusBadge & JSXBase.HTMLAttributes<HTMLScFulfillmentShippingStatusBadgeElement>;
            "sc-fulfillments": LocalJSX.ScFulfillments & JSXBase.HTMLAttributes<HTMLScFulfillmentsElement>;
            "sc-heading": LocalJSX.ScHeading & JSXBase.HTMLAttributes<HTMLScHeadingElement>;
            "sc-icon": LocalJSX.ScIcon & JSXBase.HTMLAttributes<HTMLScIconElement>;
            "sc-image-slider": LocalJSX.ScImageSlider & JSXBase.HTMLAttributes<HTMLScImageSliderElement>;
            "sc-input": LocalJSX.ScInput & JSXBase.HTMLAttributes<HTMLScInputElement>;
            "sc-invoice-details": LocalJSX.ScInvoiceDetails & JSXBase.HTMLAttributes<HTMLScInvoiceDetailsElement>;
            "sc-invoice-memo": LocalJSX.ScInvoiceMemo & JSXBase.HTMLAttributes<HTMLScInvoiceMemoElement>;
            "sc-invoice-status-badge": LocalJSX.ScInvoiceStatusBadge & JSXBase.HTMLAttributes<HTMLScInvoiceStatusBadgeElement>;
            "sc-invoices-list": LocalJSX.ScInvoicesList & JSXBase.HTMLAttributes<HTMLScInvoicesListElement>;
            "sc-license": LocalJSX.ScLicense & JSXBase.HTMLAttributes<HTMLScLicenseElement>;
            "sc-licenses-list": LocalJSX.ScLicensesList & JSXBase.HTMLAttributes<HTMLScLicensesListElement>;
            "sc-line-item": LocalJSX.ScLineItem & JSXBase.HTMLAttributes<HTMLScLineItemElement>;
            "sc-line-item-bump": LocalJSX.ScLineItemBump & JSXBase.HTMLAttributes<HTMLScLineItemBumpElement>;
            "sc-line-item-invoice-due-date": LocalJSX.ScLineItemInvoiceDueDate & JSXBase.HTMLAttributes<HTMLScLineItemInvoiceDueDateElement>;
            "sc-line-item-invoice-number": LocalJSX.ScLineItemInvoiceNumber & JSXBase.HTMLAttributes<HTMLScLineItemInvoiceNumberElement>;
            "sc-line-item-invoice-receipt-download": LocalJSX.ScLineItemInvoiceReceiptDownload & JSXBase.HTMLAttributes<HTMLScLineItemInvoiceReceiptDownloadElement>;
            "sc-line-item-shipping": LocalJSX.ScLineItemShipping & JSXBase.HTMLAttributes<HTMLScLineItemShippingElement>;
            "sc-line-item-tax": LocalJSX.ScLineItemTax & JSXBase.HTMLAttributes<HTMLScLineItemTaxElement>;
            "sc-line-item-total": LocalJSX.ScLineItemTotal & JSXBase.HTMLAttributes<HTMLScLineItemTotalElement>;
            "sc-line-item-trial": LocalJSX.ScLineItemTrial & JSXBase.HTMLAttributes<HTMLScLineItemTrialElement>;
            "sc-line-items": LocalJSX.ScLineItems & JSXBase.HTMLAttributes<HTMLScLineItemsElement>;
            "sc-line-items-provider": LocalJSX.ScLineItemsProvider & JSXBase.HTMLAttributes<HTMLScLineItemsProviderElement>;
            "sc-login-form": LocalJSX.ScLoginForm & JSXBase.HTMLAttributes<HTMLScLoginFormElement>;
            "sc-login-provider": LocalJSX.ScLoginProvider & JSXBase.HTMLAttributes<HTMLScLoginProviderElement>;
            "sc-manual-payment-method": LocalJSX.ScManualPaymentMethod & JSXBase.HTMLAttributes<HTMLScManualPaymentMethodElement>;
            "sc-menu": LocalJSX.ScMenu & JSXBase.HTMLAttributes<HTMLScMenuElement>;
            "sc-menu-divider": LocalJSX.ScMenuDivider & JSXBase.HTMLAttributes<HTMLScMenuDividerElement>;
            "sc-menu-item": LocalJSX.ScMenuItem & JSXBase.HTMLAttributes<HTMLScMenuItemElement>;
            "sc-menu-label": LocalJSX.ScMenuLabel & JSXBase.HTMLAttributes<HTMLScMenuLabelElement>;
            "sc-mollie-add-method": LocalJSX.ScMollieAddMethod & JSXBase.HTMLAttributes<HTMLScMollieAddMethodElement>;
            "sc-order": LocalJSX.ScOrder & JSXBase.HTMLAttributes<HTMLScOrderElement>;
            "sc-order-billing-address": LocalJSX.ScOrderBillingAddress & JSXBase.HTMLAttributes<HTMLScOrderBillingAddressElement>;
            "sc-order-bump": LocalJSX.ScOrderBump & JSXBase.HTMLAttributes<HTMLScOrderBumpElement>;
            "sc-order-bumps": LocalJSX.ScOrderBumps & JSXBase.HTMLAttributes<HTMLScOrderBumpsElement>;
            "sc-order-confirm-components-validator": LocalJSX.ScOrderConfirmComponentsValidator & JSXBase.HTMLAttributes<HTMLScOrderConfirmComponentsValidatorElement>;
            /**
             * This component listens to the order status
             * and confirms the order when payment is successful.
             */
            "sc-order-confirm-provider": LocalJSX.ScOrderConfirmProvider & JSXBase.HTMLAttributes<HTMLScOrderConfirmProviderElement>;
            "sc-order-confirmation": LocalJSX.ScOrderConfirmation & JSXBase.HTMLAttributes<HTMLScOrderConfirmationElement>;
            "sc-order-confirmation-customer": LocalJSX.ScOrderConfirmationCustomer & JSXBase.HTMLAttributes<HTMLScOrderConfirmationCustomerElement>;
            "sc-order-confirmation-details": LocalJSX.ScOrderConfirmationDetails & JSXBase.HTMLAttributes<HTMLScOrderConfirmationDetailsElement>;
            "sc-order-confirmation-line-items": LocalJSX.ScOrderConfirmationLineItems & JSXBase.HTMLAttributes<HTMLScOrderConfirmationLineItemsElement>;
            "sc-order-confirmation-totals": LocalJSX.ScOrderConfirmationTotals & JSXBase.HTMLAttributes<HTMLScOrderConfirmationTotalsElement>;
            "sc-order-coupon-form": LocalJSX.ScOrderCouponForm & JSXBase.HTMLAttributes<HTMLScOrderCouponFormElement>;
            "sc-order-detail": LocalJSX.ScOrderDetail & JSXBase.HTMLAttributes<HTMLScOrderDetailElement>;
            "sc-order-fulfillment-badge": LocalJSX.ScOrderFulfillmentBadge & JSXBase.HTMLAttributes<HTMLScOrderFulfillmentBadgeElement>;
            "sc-order-manual-instructions": LocalJSX.ScOrderManualInstructions & JSXBase.HTMLAttributes<HTMLScOrderManualInstructionsElement>;
            "sc-order-password": LocalJSX.ScOrderPassword & JSXBase.HTMLAttributes<HTMLScOrderPasswordElement>;
            "sc-order-return-badge": LocalJSX.ScOrderReturnBadge & JSXBase.HTMLAttributes<HTMLScOrderReturnBadgeElement>;
            "sc-order-shipment-badge": LocalJSX.ScOrderShipmentBadge & JSXBase.HTMLAttributes<HTMLScOrderShipmentBadgeElement>;
            "sc-order-shipping-address": LocalJSX.ScOrderShippingAddress & JSXBase.HTMLAttributes<HTMLScOrderShippingAddressElement>;
            "sc-order-status-badge": LocalJSX.ScOrderStatusBadge & JSXBase.HTMLAttributes<HTMLScOrderStatusBadgeElement>;
            "sc-order-submit": LocalJSX.ScOrderSubmit & JSXBase.HTMLAttributes<HTMLScOrderSubmitElement>;
            "sc-order-summary": LocalJSX.ScOrderSummary & JSXBase.HTMLAttributes<HTMLScOrderSummaryElement>;
            "sc-order-tax-id-input": LocalJSX.ScOrderTaxIdInput & JSXBase.HTMLAttributes<HTMLScOrderTaxIdInputElement>;
            "sc-orders-list": LocalJSX.ScOrdersList & JSXBase.HTMLAttributes<HTMLScOrdersListElement>;
            "sc-pagination": LocalJSX.ScPagination & JSXBase.HTMLAttributes<HTMLScPaginationElement>;
            "sc-password": LocalJSX.ScPassword & JSXBase.HTMLAttributes<HTMLScPasswordElement>;
            "sc-password-nag": LocalJSX.ScPasswordNag & JSXBase.HTMLAttributes<HTMLScPasswordNagElement>;
            "sc-payment": LocalJSX.ScPayment & JSXBase.HTMLAttributes<HTMLScPaymentElement>;
            "sc-payment-method": LocalJSX.ScPaymentMethod & JSXBase.HTMLAttributes<HTMLScPaymentMethodElement>;
            "sc-payment-method-choice": LocalJSX.ScPaymentMethodChoice & JSXBase.HTMLAttributes<HTMLScPaymentMethodChoiceElement>;
            "sc-payment-method-details": LocalJSX.ScPaymentMethodDetails & JSXBase.HTMLAttributes<HTMLScPaymentMethodDetailsElement>;
            "sc-payment-methods-list": LocalJSX.ScPaymentMethodsList & JSXBase.HTMLAttributes<HTMLScPaymentMethodsListElement>;
            "sc-payment-selected": LocalJSX.ScPaymentSelected & JSXBase.HTMLAttributes<HTMLScPaymentSelectedElement>;
            "sc-paypal-add-method": LocalJSX.ScPaypalAddMethod & JSXBase.HTMLAttributes<HTMLScPaypalAddMethodElement>;
            "sc-paypal-buttons": LocalJSX.ScPaypalButtons & JSXBase.HTMLAttributes<HTMLScPaypalButtonsElement>;
            "sc-paystack-add-method": LocalJSX.ScPaystackAddMethod & JSXBase.HTMLAttributes<HTMLScPaystackAddMethodElement>;
            "sc-phone-input": LocalJSX.ScPhoneInput & JSXBase.HTMLAttributes<HTMLScPhoneInputElement>;
            "sc-pill-option": LocalJSX.ScPillOption & JSXBase.HTMLAttributes<HTMLScPillOptionElement>;
            "sc-premium-tag": LocalJSX.ScPremiumTag & JSXBase.HTMLAttributes<HTMLScPremiumTagElement>;
            /**
             * Internal dependencies.
             */
            "sc-price": LocalJSX.ScPrice & JSXBase.HTMLAttributes<HTMLScPriceElement>;
            "sc-price-choice": LocalJSX.ScPriceChoice & JSXBase.HTMLAttributes<HTMLScPriceChoiceElement>;
            "sc-price-choice-container": LocalJSX.ScPriceChoiceContainer & JSXBase.HTMLAttributes<HTMLScPriceChoiceContainerElement>;
            "sc-price-choices": LocalJSX.ScPriceChoices & JSXBase.HTMLAttributes<HTMLScPriceChoicesElement>;
            "sc-price-input": LocalJSX.ScPriceInput & JSXBase.HTMLAttributes<HTMLScPriceInputElement>;
            "sc-price-range": LocalJSX.ScPriceRange & JSXBase.HTMLAttributes<HTMLScPriceRangeElement>;
            "sc-product-buy-button": LocalJSX.ScProductBuyButton & JSXBase.HTMLAttributes<HTMLScProductBuyButtonElement>;
            "sc-product-donation-amount-choice": LocalJSX.ScProductDonationAmountChoice & JSXBase.HTMLAttributes<HTMLScProductDonationAmountChoiceElement>;
            "sc-product-donation-choices": LocalJSX.ScProductDonationChoices & JSXBase.HTMLAttributes<HTMLScProductDonationChoicesElement>;
            "sc-product-donation-custom-amount": LocalJSX.ScProductDonationCustomAmount & JSXBase.HTMLAttributes<HTMLScProductDonationCustomAmountElement>;
            "sc-product-item": LocalJSX.ScProductItem & JSXBase.HTMLAttributes<HTMLScProductItemElement>;
            "sc-product-item-image": LocalJSX.ScProductItemImage & JSXBase.HTMLAttributes<HTMLScProductItemImageElement>;
            "sc-product-item-list": LocalJSX.ScProductItemList & JSXBase.HTMLAttributes<HTMLScProductItemListElement>;
            "sc-product-item-price": LocalJSX.ScProductItemPrice & JSXBase.HTMLAttributes<HTMLScProductItemPriceElement>;
            "sc-product-item-title": LocalJSX.ScProductItemTitle & JSXBase.HTMLAttributes<HTMLScProductItemTitleElement>;
            "sc-product-line-item": LocalJSX.ScProductLineItem & JSXBase.HTMLAttributes<HTMLScProductLineItemElement>;
            "sc-product-pills-variant-option": LocalJSX.ScProductPillsVariantOption & JSXBase.HTMLAttributes<HTMLScProductPillsVariantOptionElement>;
            "sc-product-price": LocalJSX.ScProductPrice & JSXBase.HTMLAttributes<HTMLScProductPriceElement>;
            "sc-product-price-choices": LocalJSX.ScProductPriceChoices & JSXBase.HTMLAttributes<HTMLScProductPriceChoicesElement>;
            "sc-product-price-modal": LocalJSX.ScProductPriceModal & JSXBase.HTMLAttributes<HTMLScProductPriceModalElement>;
            "sc-product-quantity": LocalJSX.ScProductQuantity & JSXBase.HTMLAttributes<HTMLScProductQuantityElement>;
            "sc-product-selected-price": LocalJSX.ScProductSelectedPrice & JSXBase.HTMLAttributes<HTMLScProductSelectedPriceElement>;
            "sc-product-text": LocalJSX.ScProductText & JSXBase.HTMLAttributes<HTMLScProductTextElement>;
            "sc-prose": LocalJSX.ScProse & JSXBase.HTMLAttributes<HTMLScProseElement>;
            "sc-provider": LocalJSX.ScProvider & JSXBase.HTMLAttributes<HTMLScProviderElement>;
            "sc-provisional-banner": LocalJSX.ScProvisionalBanner & JSXBase.HTMLAttributes<HTMLScProvisionalBannerElement>;
            "sc-purchase-downloads-list": LocalJSX.ScPurchaseDownloadsList & JSXBase.HTMLAttributes<HTMLScPurchaseDownloadsListElement>;
            "sc-quantity-select": LocalJSX.ScQuantitySelect & JSXBase.HTMLAttributes<HTMLScQuantitySelectElement>;
            "sc-radio": LocalJSX.ScRadio & JSXBase.HTMLAttributes<HTMLScRadioElement>;
            "sc-radio-group": LocalJSX.ScRadioGroup & JSXBase.HTMLAttributes<HTMLScRadioGroupElement>;
            "sc-recurring-price-choice-container": LocalJSX.ScRecurringPriceChoiceContainer & JSXBase.HTMLAttributes<HTMLScRecurringPriceChoiceContainerElement>;
            "sc-rich-text": LocalJSX.ScRichText & JSXBase.HTMLAttributes<HTMLScRichTextElement>;
            "sc-secure-notice": LocalJSX.ScSecureNotice & JSXBase.HTMLAttributes<HTMLScSecureNoticeElement>;
            "sc-select": LocalJSX.ScSelect & JSXBase.HTMLAttributes<HTMLScSelectElement>;
            "sc-session-provider": LocalJSX.ScSessionProvider & JSXBase.HTMLAttributes<HTMLScSessionProviderElement>;
            "sc-shipping-choices": LocalJSX.ScShippingChoices & JSXBase.HTMLAttributes<HTMLScShippingChoicesElement>;
            "sc-skeleton": LocalJSX.ScSkeleton & JSXBase.HTMLAttributes<HTMLScSkeletonElement>;
            "sc-spacing": LocalJSX.ScSpacing & JSXBase.HTMLAttributes<HTMLScSpacingElement>;
            "sc-spinner": LocalJSX.ScSpinner & JSXBase.HTMLAttributes<HTMLScSpinnerElement>;
            "sc-stacked-list": LocalJSX.ScStackedList & JSXBase.HTMLAttributes<HTMLScStackedListElement>;
            "sc-stacked-list-row": LocalJSX.ScStackedListRow & JSXBase.HTMLAttributes<HTMLScStackedListRowElement>;
            "sc-stripe-add-method": LocalJSX.ScStripeAddMethod & JSXBase.HTMLAttributes<HTMLScStripeAddMethodElement>;
            "sc-stripe-element": LocalJSX.ScStripeElement & JSXBase.HTMLAttributes<HTMLScStripeElementElement>;
            "sc-stripe-payment-element": LocalJSX.ScStripePaymentElement & JSXBase.HTMLAttributes<HTMLScStripePaymentElementElement>;
            "sc-stripe-payment-request": LocalJSX.ScStripePaymentRequest & JSXBase.HTMLAttributes<HTMLScStripePaymentRequestElement>;
            "sc-subscription": LocalJSX.ScSubscription & JSXBase.HTMLAttributes<HTMLScSubscriptionElement>;
            "sc-subscription-ad-hoc-confirm": LocalJSX.ScSubscriptionAdHocConfirm & JSXBase.HTMLAttributes<HTMLScSubscriptionAdHocConfirmElement>;
            "sc-subscription-cancel": LocalJSX.ScSubscriptionCancel & JSXBase.HTMLAttributes<HTMLScSubscriptionCancelElement>;
            "sc-subscription-details": LocalJSX.ScSubscriptionDetails & JSXBase.HTMLAttributes<HTMLScSubscriptionDetailsElement>;
            "sc-subscription-next-payment": LocalJSX.ScSubscriptionNextPayment & JSXBase.HTMLAttributes<HTMLScSubscriptionNextPaymentElement>;
            "sc-subscription-payment": LocalJSX.ScSubscriptionPayment & JSXBase.HTMLAttributes<HTMLScSubscriptionPaymentElement>;
            "sc-subscription-payment-method": LocalJSX.ScSubscriptionPaymentMethod & JSXBase.HTMLAttributes<HTMLScSubscriptionPaymentMethodElement>;
            "sc-subscription-reactivate": LocalJSX.ScSubscriptionReactivate & JSXBase.HTMLAttributes<HTMLScSubscriptionReactivateElement>;
            "sc-subscription-status-badge": LocalJSX.ScSubscriptionStatusBadge & JSXBase.HTMLAttributes<HTMLScSubscriptionStatusBadgeElement>;
            "sc-subscription-switch": LocalJSX.ScSubscriptionSwitch & JSXBase.HTMLAttributes<HTMLScSubscriptionSwitchElement>;
            "sc-subscription-variation-confirm": LocalJSX.ScSubscriptionVariationConfirm & JSXBase.HTMLAttributes<HTMLScSubscriptionVariationConfirmElement>;
            "sc-subscriptions-list": LocalJSX.ScSubscriptionsList & JSXBase.HTMLAttributes<HTMLScSubscriptionsListElement>;
            "sc-summary": LocalJSX.ScSummary & JSXBase.HTMLAttributes<HTMLScSummaryElement>;
            "sc-switch": LocalJSX.ScSwitch & JSXBase.HTMLAttributes<HTMLScSwitchElement>;
            "sc-tab": LocalJSX.ScTab & JSXBase.HTMLAttributes<HTMLScTabElement>;
            "sc-tab-group": LocalJSX.ScTabGroup & JSXBase.HTMLAttributes<HTMLScTabGroupElement>;
            "sc-tab-panel": LocalJSX.ScTabPanel & JSXBase.HTMLAttributes<HTMLScTabPanelElement>;
            "sc-table": LocalJSX.ScTable & JSXBase.HTMLAttributes<HTMLScTableElement>;
            "sc-table-cell": LocalJSX.ScTableCell & JSXBase.HTMLAttributes<HTMLScTableCellElement>;
            "sc-table-head": LocalJSX.ScTableHead & JSXBase.HTMLAttributes<HTMLScTableHeadElement>;
            "sc-table-row": LocalJSX.ScTableRow & JSXBase.HTMLAttributes<HTMLScTableRowElement>;
            "sc-tag": LocalJSX.ScTag & JSXBase.HTMLAttributes<HTMLScTagElement>;
            "sc-tax-id-input": LocalJSX.ScTaxIdInput & JSXBase.HTMLAttributes<HTMLScTaxIdInputElement>;
            "sc-text": LocalJSX.ScText & JSXBase.HTMLAttributes<HTMLScTextElement>;
            "sc-textarea": LocalJSX.ScTextarea & JSXBase.HTMLAttributes<HTMLScTextareaElement>;
            "sc-toggle": LocalJSX.ScToggle & JSXBase.HTMLAttributes<HTMLScToggleElement>;
            "sc-toggles": LocalJSX.ScToggles & JSXBase.HTMLAttributes<HTMLScTogglesElement>;
            "sc-tooltip": LocalJSX.ScTooltip & JSXBase.HTMLAttributes<HTMLScTooltipElement>;
            "sc-total": LocalJSX.ScTotal & JSXBase.HTMLAttributes<HTMLScTotalElement>;
            "sc-upcoming-invoice": LocalJSX.ScUpcomingInvoice & JSXBase.HTMLAttributes<HTMLScUpcomingInvoiceElement>;
            "sc-upgrade-required": LocalJSX.ScUpgradeRequired & JSXBase.HTMLAttributes<HTMLScUpgradeRequiredElement>;
            "sc-upsell": LocalJSX.ScUpsell & JSXBase.HTMLAttributes<HTMLScUpsellElement>;
            "sc-upsell-countdown-timer": LocalJSX.ScUpsellCountdownTimer & JSXBase.HTMLAttributes<HTMLScUpsellCountdownTimerElement>;
            "sc-upsell-no-thanks-button": LocalJSX.ScUpsellNoThanksButton & JSXBase.HTMLAttributes<HTMLScUpsellNoThanksButtonElement>;
            "sc-upsell-submit-button": LocalJSX.ScUpsellSubmitButton & JSXBase.HTMLAttributes<HTMLScUpsellSubmitButtonElement>;
            "sc-upsell-totals": LocalJSX.ScUpsellTotals & JSXBase.HTMLAttributes<HTMLScUpsellTotalsElement>;
            "sc-visually-hidden": LocalJSX.ScVisuallyHidden & JSXBase.HTMLAttributes<HTMLScVisuallyHiddenElement>;
            "sc-wordpress-password-edit": LocalJSX.ScWordpressPasswordEdit & JSXBase.HTMLAttributes<HTMLScWordpressPasswordEditElement>;
            "sc-wordpress-user": LocalJSX.ScWordpressUser & JSXBase.HTMLAttributes<HTMLScWordpressUserElement>;
            "sc-wordpress-user-edit": LocalJSX.ScWordpressUserEdit & JSXBase.HTMLAttributes<HTMLScWordpressUserEditElement>;
        }
    }
}
